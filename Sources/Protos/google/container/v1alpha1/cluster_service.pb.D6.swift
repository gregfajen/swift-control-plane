// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/container/v1alpha1/cluster_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Parameters that describe the nodes in a cluster.
public struct Google_Container_V1alpha1_NodeConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of a Google Compute Engine [machine
  /// type](/compute/docs/machine-types) (e.g.
  /// `n1-standard-1`).
  ///
  /// If unspecified, the default machine type is
  /// `n1-standard-1`.
  public var machineType: String = String()

  /// Size of the disk attached to each node, specified in GB.
  /// The smallest allowed disk size is 10GB.
  ///
  /// If unspecified, the default disk size is 100GB.
  public var diskSizeGb: Int32 = 0

  /// The set of Google API scopes to be made available on all of the
  /// node VMs under the "default" service account.
  ///
  /// The following scopes are recommended, but not required, and by default are
  /// not included:
  ///
  /// * `https://www.googleapis.com/auth/compute` is required for mounting
  /// persistent storage on your nodes.
  /// * `https://www.googleapis.com/auth/devstorage.read_only` is required for
  /// communicating with **gcr.io**
  /// (the [Google Container Registry](/container-registry/)).
  ///
  /// If unspecified, no scopes are added, unless Cloud Logging or Cloud
  /// Monitoring are enabled, in which case their required scopes will be added.
  public var oauthScopes: [String] = []

  /// The Google Cloud Platform Service Account to be used by the node VMs. If
  /// no Service Account is specified, the "default" service account is used.
  public var serviceAccount: String = String()

  /// The metadata key/value pairs assigned to instances in the cluster.
  ///
  /// Keys must conform to the regexp [a-zA-Z0-9-_]+ and be less than 128 bytes
  /// in length. These are reflected as part of a URL in the metadata server.
  /// Additionally, to avoid ambiguity, keys must not conflict with any other
  /// metadata keys for the project or be one of the four reserved keys:
  /// "instance-template", "kube-env", "startup-script", and "user-data"
  ///
  /// Values are free-form strings, and only have meaning as interpreted by
  /// the image running in the instance. The only restriction placed on them is
  /// that each value's size must be less than or equal to 32 KB.
  ///
  /// The total size of all keys and values must be less than 512 KB.
  public var metadata: Dictionary<String,String> = [:]

  /// The image type to use for this node. Note that for a given image type,
  /// the latest version of it will be used.
  public var imageType: String = String()

  /// The map of Kubernetes labels (key/value pairs) to be applied to each node.
  /// These will added in addition to any default label(s) that
  /// Kubernetes may apply to the node.
  /// In case of conflict in label keys, the applied set may differ depending on
  /// the Kubernetes version -- it's best to assume the behavior is undefined
  /// and conflicts should be avoided.
  /// For more information, including usage and the valid values, see:
  /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
  public var labels: Dictionary<String,String> = [:]

  /// The number of local SSD disks to be attached to the node.
  ///
  /// The limit for this value is dependant upon the maximum number of
  /// disks available on a machine per zone. See:
  /// https://cloud.google.com/compute/docs/disks/local-ssd#local_ssd_limits
  /// for more information.
  public var localSsdCount: Int32 = 0

  /// The list of instance tags applied to all nodes. Tags are used to identify
  /// valid sources or targets for network firewalls and are specified by
  /// the client during cluster or node pool creation. Each tag within the list
  /// must comply with RFC1035.
  public var tags: [String] = []

  /// Whether the nodes are created as preemptible VM instances. See:
  /// https://cloud.google.com/compute/docs/instances/preemptible for more
  /// inforamtion about preemptible VM instances.
  public var preemptible: Bool = false

  /// A list of hardware accelerators to be attached to each node.
  /// See https://cloud.google.com/compute/docs/gpus for more information about
  /// support for GPUs.
  public var accelerators: [Google_Container_V1alpha1_AcceleratorConfig] = []

  /// Minimum CPU platform to be used by this instance. The instance may be
  /// scheduled on the specified or newer CPU platform. Applicable values are the
  /// friendly names of CPU platforms, such as
  /// <code>minCpuPlatform: &quot;Intel Haswell&quot;</code> or
  /// <code>minCpuPlatform: &quot;Intel Sandy Bridge&quot;</code>. For more
  /// information, read [how to specify min CPU platform](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform)
  public var minCpuPlatform: String = String()

  /// List of kubernetes taints to be applied to each node.
  ///
  /// For more information, including usage and the valid values, see:
  /// https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
  public var taints: [Google_Container_V1alpha1_NodeTaint] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Kubernetes taint is comprised of three fields: key, value, and effect. Effect
/// can only be one of three types:  NoSchedule, PreferNoSchedule or NoExecute.
///
/// For more information, including usage and the valid values, see:
/// https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
public struct Google_Container_V1alpha1_NodeTaint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Key for taint.
  public var key: String = String()

  /// Value for taint.
  public var value: String = String()

  /// Effect for taint.
  public var effect: Google_Container_V1alpha1_NodeTaint.Effect = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Possible values for Effect in taint.
  public enum Effect: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Not set
    case unspecified // = 0

    /// NoSchedule
    case noSchedule // = 1

    /// PreferNoSchedule
    case preferNoSchedule // = 2

    /// NoExecute
    case noExecute // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .noSchedule
      case 2: self = .preferNoSchedule
      case 3: self = .noExecute
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .noSchedule: return 1
      case .preferNoSchedule: return 2
      case .noExecute: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Container_V1alpha1_NodeTaint.Effect: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Container_V1alpha1_NodeTaint.Effect] = [
    .unspecified,
    .noSchedule,
    .preferNoSchedule,
    .noExecute,
  ]
}

#endif  // swift(>=4.2)

/// The authentication information for accessing the master endpoint.
/// Authentication can be done using HTTP basic auth or using client
/// certificates.
public struct Google_Container_V1alpha1_MasterAuth {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The username to use for HTTP basic authentication to the master endpoint.
  /// For clusters v1.6.0 and later, you can disable basic authentication by
  /// providing an empty username.
  public var username: String = String()

  /// The password to use for HTTP basic authentication to the master endpoint.
  /// Because the master endpoint is open to the Internet, you should create a
  /// strong password.  If a password is provided for cluster creation, username
  /// must be non-empty.
  public var password: String = String()

  /// Configuration for client certificate authentication on the cluster.  If no
  /// configuration is specified, a client certificate is issued.
  public var clientCertificateConfig: Google_Container_V1alpha1_ClientCertificateConfig {
    get {return _clientCertificateConfig ?? Google_Container_V1alpha1_ClientCertificateConfig()}
    set {_clientCertificateConfig = newValue}
  }
  /// Returns true if `clientCertificateConfig` has been explicitly set.
  public var hasClientCertificateConfig: Bool {return self._clientCertificateConfig != nil}
  /// Clears the value of `clientCertificateConfig`. Subsequent reads from it will return its default value.
  public mutating func clearClientCertificateConfig() {self._clientCertificateConfig = nil}

  /// [Output only] Base64-encoded public certificate that is the root of
  /// trust for the cluster.
  public var clusterCaCertificate: String = String()

  /// [Output only] Base64-encoded public certificate used by clients to
  /// authenticate to the cluster endpoint.
  public var clientCertificate: String = String()

  /// [Output only] Base64-encoded private key used by clients to authenticate
  /// to the cluster endpoint.
  public var clientKey: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _clientCertificateConfig: Google_Container_V1alpha1_ClientCertificateConfig? = nil
}

/// Configuration for client certificates on the cluster.
public struct Google_Container_V1alpha1_ClientCertificateConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Issue a client certificate.
  public var issueClientCertificate: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Configuration for the addons that can be automatically spun up in the
/// cluster, enabling additional functionality.
public struct Google_Container_V1alpha1_AddonsConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Configuration for the HTTP (L7) load balancing controller addon, which
  /// makes it easy to set up HTTP load balancers for services in a cluster.
  public var httpLoadBalancing: Google_Container_V1alpha1_HttpLoadBalancing {
    get {return _httpLoadBalancing ?? Google_Container_V1alpha1_HttpLoadBalancing()}
    set {_httpLoadBalancing = newValue}
  }
  /// Returns true if `httpLoadBalancing` has been explicitly set.
  public var hasHTTPLoadBalancing: Bool {return self._httpLoadBalancing != nil}
  /// Clears the value of `httpLoadBalancing`. Subsequent reads from it will return its default value.
  public mutating func clearHTTPLoadBalancing() {self._httpLoadBalancing = nil}

  /// Configuration for the horizontal pod autoscaling feature, which
  /// increases or decreases the number of replica pods a replication controller
  /// has based on the resource usage of the existing pods.
  public var horizontalPodAutoscaling: Google_Container_V1alpha1_HorizontalPodAutoscaling {
    get {return _horizontalPodAutoscaling ?? Google_Container_V1alpha1_HorizontalPodAutoscaling()}
    set {_horizontalPodAutoscaling = newValue}
  }
  /// Returns true if `horizontalPodAutoscaling` has been explicitly set.
  public var hasHorizontalPodAutoscaling: Bool {return self._horizontalPodAutoscaling != nil}
  /// Clears the value of `horizontalPodAutoscaling`. Subsequent reads from it will return its default value.
  public mutating func clearHorizontalPodAutoscaling() {self._horizontalPodAutoscaling = nil}

  /// Configuration for the Kubernetes Dashboard.
  public var kubernetesDashboard: Google_Container_V1alpha1_KubernetesDashboard {
    get {return _kubernetesDashboard ?? Google_Container_V1alpha1_KubernetesDashboard()}
    set {_kubernetesDashboard = newValue}
  }
  /// Returns true if `kubernetesDashboard` has been explicitly set.
  public var hasKubernetesDashboard: Bool {return self._kubernetesDashboard != nil}
  /// Clears the value of `kubernetesDashboard`. Subsequent reads from it will return its default value.
  public mutating func clearKubernetesDashboard() {self._kubernetesDashboard = nil}

  /// Configuration for NetworkPolicy. This only tracks whether the addon
  /// is enabled or not on the Master, it does not track whether network policy
  /// is enabled for the nodes.
  public var networkPolicyConfig: Google_Container_V1alpha1_NetworkPolicyConfig {
    get {return _networkPolicyConfig ?? Google_Container_V1alpha1_NetworkPolicyConfig()}
    set {_networkPolicyConfig = newValue}
  }
  /// Returns true if `networkPolicyConfig` has been explicitly set.
  public var hasNetworkPolicyConfig: Bool {return self._networkPolicyConfig != nil}
  /// Clears the value of `networkPolicyConfig`. Subsequent reads from it will return its default value.
  public mutating func clearNetworkPolicyConfig() {self._networkPolicyConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _httpLoadBalancing: Google_Container_V1alpha1_HttpLoadBalancing? = nil
  fileprivate var _horizontalPodAutoscaling: Google_Container_V1alpha1_HorizontalPodAutoscaling? = nil
  fileprivate var _kubernetesDashboard: Google_Container_V1alpha1_KubernetesDashboard? = nil
  fileprivate var _networkPolicyConfig: Google_Container_V1alpha1_NetworkPolicyConfig? = nil
}

/// Configuration options for the HTTP (L7) load balancing controller addon,
/// which makes it easy to set up HTTP load balancers for services in a cluster.
public struct Google_Container_V1alpha1_HttpLoadBalancing {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether the HTTP Load Balancing controller is enabled in the cluster.
  /// When enabled, it runs a small pod in the cluster that manages the load
  /// balancers.
  public var disabled: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Configuration options for the horizontal pod autoscaling feature, which
/// increases or decreases the number of replica pods a replication controller
/// has based on the resource usage of the existing pods.
public struct Google_Container_V1alpha1_HorizontalPodAutoscaling {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether the Horizontal Pod Autoscaling feature is enabled in the cluster.
  /// When enabled, it ensures that a Heapster pod is running in the cluster,
  /// which is also used by the Cloud Monitoring service.
  public var disabled: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Configuration for the Kubernetes Dashboard.
public struct Google_Container_V1alpha1_KubernetesDashboard {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether the Kubernetes Dashboard is enabled for this cluster.
  public var disabled: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Configuration for NetworkPolicy. This only tracks whether the addon
/// is enabled or not on the Master, it does not track whether network policy
/// is enabled for the nodes.
public struct Google_Container_V1alpha1_NetworkPolicyConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether NetworkPolicy is enabled for this cluster.
  public var disabled: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Configuration options for the master authorized networks feature. Enabled
/// master authorized networks will disallow all external traffic to access
/// Kubernetes master through HTTPS except traffic from the given CIDR blocks,
/// Google Compute Engine Public IPs and Google Prod IPs.
public struct Google_Container_V1alpha1_MasterAuthorizedNetworksConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether or not master authorized networks is enabled.
  public var enabled: Bool = false

  /// cidr_blocks define up to 10 external networks that could access
  /// Kubernetes master through HTTPS.
  public var cidrBlocks: [Google_Container_V1alpha1_MasterAuthorizedNetworksConfig.CidrBlock] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// CidrBlock contains an optional name and one CIDR block.
  public struct CidrBlock {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// display_name is an optional field for users to identify CIDR blocks.
    public var displayName: String = String()

    /// cidr_block must be specified in CIDR notation.
    public var cidrBlock: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Configuration options for the NetworkPolicy feature.
/// https://kubernetes.io/docs/concepts/services-networking/networkpolicies/
public struct Google_Container_V1alpha1_NetworkPolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The selected network policy provider.
  public var provider: Google_Container_V1alpha1_NetworkPolicy.Provider = .unspecified

  /// Whether network policy is enabled on the cluster.
  public var enabled: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Allowed Network Policy providers.
  public enum Provider: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Not set
    case unspecified // = 0

    /// Tigera (Calico Felix).
    case calico // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .calico
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .calico: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Container_V1alpha1_NetworkPolicy.Provider: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Container_V1alpha1_NetworkPolicy.Provider] = [
    .unspecified,
    .calico,
  ]
}

#endif  // swift(>=4.2)

/// Configuration for controlling how IPs are allocated in the cluster.
public struct Google_Container_V1alpha1_IPAllocationPolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether alias IPs will be used for pod IPs in the cluster.
  public var useIpAliases: Bool = false

  /// Whether a new subnetwork will be created automatically for the cluster.
  ///
  /// This field is only applicable when `use_ip_aliases` is true.
  public var createSubnetwork: Bool = false

  /// A custom subnetwork name to be used if `create_subnetwork` is true.  If
  /// this field is empty, then an automatic name will be chosen for the new
  /// subnetwork.
  public var subnetworkName: String = String()

  /// This field is deprecated, use cluster_ipv4_cidr_block.
  public var clusterIpv4Cidr: String = String()

  /// This field is deprecated, use node_ipv4_cidr_block.
  public var nodeIpv4Cidr: String = String()

  /// This field is deprecated, use services_ipv4_cidr_block.
  public var servicesIpv4Cidr: String = String()

  /// The name of the secondary range to be used for the cluster CIDR
  /// block.  The secondary range will be used for pod IP
  /// addresses. This must be an existing secondary range associated
  /// with the cluster subnetwork.
  ///
  /// This field is only applicable if use_ip_aliases is true and
  /// create_subnetwork is false.
  public var clusterSecondaryRangeName: String = String()

  /// The name of the secondary range to be used as for the services
  /// CIDR block.  The secondary range will be used for service
  /// ClusterIPs. This must be an existing secondary range associated
  /// with the cluster subnetwork.
  ///
  /// This field is only applicable with use_ip_aliases is true and
  /// create_subnetwork is false.
  public var servicesSecondaryRangeName: String = String()

  /// The IP address range for the cluster pod IPs. If this field is set, then
  /// `cluster.cluster_ipv4_cidr` must be left blank.
  ///
  /// This field is only applicable when `use_ip_aliases` is true.
  ///
  /// Set to blank to have a range chosen with the default size.
  ///
  /// Set to /netmask (e.g. `/14`) to have a range chosen with a specific
  /// netmask.
  ///
  /// Set to a
  /// [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
  /// notation (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g.
  /// `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range
  /// to use.
  public var clusterIpv4CidrBlock: String = String()

  /// The IP address range of the instance IPs in this cluster.
  ///
  /// This is applicable only if `create_subnetwork` is true.
  ///
  /// Set to blank to have a range chosen with the default size.
  ///
  /// Set to /netmask (e.g. `/14`) to have a range chosen with a specific
  /// netmask.
  ///
  /// Set to a
  /// [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
  /// notation (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g.
  /// `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range
  /// to use.
  public var nodeIpv4CidrBlock: String = String()

  /// The IP address range of the services IPs in this cluster. If blank, a range
  /// will be automatically chosen with the default size.
  ///
  /// This field is only applicable when `use_ip_aliases` is true.
  ///
  /// Set to blank to have a range chosen with the default size.
  ///
  /// Set to /netmask (e.g. `/14`) to have a range chosen with a specific
  /// netmask.
  ///
  /// Set to a
  /// [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
  /// notation (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g.
  /// `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range
  /// to use.
  public var servicesIpv4CidrBlock: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Configuration for the PodSecurityPolicy feature.
public struct Google_Container_V1alpha1_PodSecurityPolicyConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Enable the PodSecurityPolicy controller for this cluster. If enabled, pods
  /// must be valid under a PodSecurityPolicy to be created.
  public var enabled: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A Google Container Engine cluster.
public struct Google_Container_V1alpha1_Cluster {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of this cluster. The name must be unique within this project
  /// and zone, and can be up to 40 characters with the following restrictions:
  ///
  /// * Lowercase letters, numbers, and hyphens only.
  /// * Must start with a letter.
  /// * Must end with a number or a letter.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// An optional description of this cluster.
  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// The number of nodes to create in this cluster. You must ensure that your
  /// Compute Engine <a href="/compute/docs/resource-quotas">resource quota</a>
  /// is sufficient for this number of instances. You must also have available
  /// firewall and routes quota.
  /// For requests, this field should only be used in lieu of a
  /// "node_pool" object, since this configuration (along with the
  /// "node_config") will be used to create a "NodePool" object with an
  /// auto-generated name. Do not use this and a node_pool at the same time.
  public var initialNodeCount: Int32 {
    get {return _storage._initialNodeCount}
    set {_uniqueStorage()._initialNodeCount = newValue}
  }

  /// Parameters used in creating the cluster's nodes.
  /// See `nodeConfig` for the description of its properties.
  /// For requests, this field should only be used in lieu of a
  /// "node_pool" object, since this configuration (along with the
  /// "initial_node_count") will be used to create a "NodePool" object with an
  /// auto-generated name. Do not use this and a node_pool at the same time.
  /// For responses, this field will be populated with the node configuration of
  /// the first node pool.
  ///
  /// If unspecified, the defaults are used.
  public var nodeConfig: Google_Container_V1alpha1_NodeConfig {
    get {return _storage._nodeConfig ?? Google_Container_V1alpha1_NodeConfig()}
    set {_uniqueStorage()._nodeConfig = newValue}
  }
  /// Returns true if `nodeConfig` has been explicitly set.
  public var hasNodeConfig: Bool {return _storage._nodeConfig != nil}
  /// Clears the value of `nodeConfig`. Subsequent reads from it will return its default value.
  public mutating func clearNodeConfig() {_uniqueStorage()._nodeConfig = nil}

  /// The authentication information for accessing the master endpoint.
  public var masterAuth: Google_Container_V1alpha1_MasterAuth {
    get {return _storage._masterAuth ?? Google_Container_V1alpha1_MasterAuth()}
    set {_uniqueStorage()._masterAuth = newValue}
  }
  /// Returns true if `masterAuth` has been explicitly set.
  public var hasMasterAuth: Bool {return _storage._masterAuth != nil}
  /// Clears the value of `masterAuth`. Subsequent reads from it will return its default value.
  public mutating func clearMasterAuth() {_uniqueStorage()._masterAuth = nil}

  /// The logging service the cluster should use to write logs.
  /// Currently available options:
  ///
  /// * `logging.googleapis.com` - the Google Cloud Logging service.
  /// * `none` - no logs will be exported from the cluster.
  /// * if left as an empty string,`logging.googleapis.com` will be used.
  public var loggingService: String {
    get {return _storage._loggingService}
    set {_uniqueStorage()._loggingService = newValue}
  }

  /// The monitoring service the cluster should use to write metrics.
  /// Currently available options:
  ///
  /// * `monitoring.googleapis.com` - the Google Cloud Monitoring service.
  /// * `none` - no metrics will be exported from the cluster.
  /// * if left as an empty string, `monitoring.googleapis.com` will be used.
  public var monitoringService: String {
    get {return _storage._monitoringService}
    set {_uniqueStorage()._monitoringService = newValue}
  }

  /// The name of the Google Compute Engine
  /// [network](/compute/docs/networks-and-firewalls#networks) to which the
  /// cluster is connected. If left unspecified, the `default` network
  /// will be used.
  public var network: String {
    get {return _storage._network}
    set {_uniqueStorage()._network = newValue}
  }

  /// The IP address range of the container pods in this cluster, in
  /// [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
  /// notation (e.g. `10.96.0.0/14`). Leave blank to have
  /// one automatically chosen or specify a `/14` block in `10.0.0.0/8`.
  public var clusterIpv4Cidr: String {
    get {return _storage._clusterIpv4Cidr}
    set {_uniqueStorage()._clusterIpv4Cidr = newValue}
  }

  /// Configurations for the various addons available to run in the cluster.
  public var addonsConfig: Google_Container_V1alpha1_AddonsConfig {
    get {return _storage._addonsConfig ?? Google_Container_V1alpha1_AddonsConfig()}
    set {_uniqueStorage()._addonsConfig = newValue}
  }
  /// Returns true if `addonsConfig` has been explicitly set.
  public var hasAddonsConfig: Bool {return _storage._addonsConfig != nil}
  /// Clears the value of `addonsConfig`. Subsequent reads from it will return its default value.
  public mutating func clearAddonsConfig() {_uniqueStorage()._addonsConfig = nil}

  /// The name of the Google Compute Engine
  /// [subnetwork](/compute/docs/subnetworks) to which the
  /// cluster is connected.
  public var subnetwork: String {
    get {return _storage._subnetwork}
    set {_uniqueStorage()._subnetwork = newValue}
  }

  /// The node pools associated with this cluster.
  /// This field should not be set if "node_config" or "initial_node_count" are
  /// specified.
  public var nodePools: [Google_Container_V1alpha1_NodePool] {
    get {return _storage._nodePools}
    set {_uniqueStorage()._nodePools = newValue}
  }

  /// The list of Google Compute Engine
  /// [locations](/compute/docs/zones#available) in which the cluster's nodes
  /// should be located.
  public var locations: [String] {
    get {return _storage._locations}
    set {_uniqueStorage()._locations = newValue}
  }

  /// Kubernetes alpha features are enabled on this cluster. This includes alpha
  /// API groups (e.g. v1alpha1) and features that may not be production ready in
  /// the kubernetes version of the master and nodes.
  /// The cluster has no SLA for uptime and master/node upgrades are disabled.
  /// Alpha enabled clusters are automatically deleted thirty days after
  /// creation.
  public var enableKubernetesAlpha: Bool {
    get {return _storage._enableKubernetesAlpha}
    set {_uniqueStorage()._enableKubernetesAlpha = newValue}
  }

  /// Configuration options for the NetworkPolicy feature.
  public var networkPolicy: Google_Container_V1alpha1_NetworkPolicy {
    get {return _storage._networkPolicy ?? Google_Container_V1alpha1_NetworkPolicy()}
    set {_uniqueStorage()._networkPolicy = newValue}
  }
  /// Returns true if `networkPolicy` has been explicitly set.
  public var hasNetworkPolicy: Bool {return _storage._networkPolicy != nil}
  /// Clears the value of `networkPolicy`. Subsequent reads from it will return its default value.
  public mutating func clearNetworkPolicy() {_uniqueStorage()._networkPolicy = nil}

  /// Configuration for cluster IP allocation.
  public var ipAllocationPolicy: Google_Container_V1alpha1_IPAllocationPolicy {
    get {return _storage._ipAllocationPolicy ?? Google_Container_V1alpha1_IPAllocationPolicy()}
    set {_uniqueStorage()._ipAllocationPolicy = newValue}
  }
  /// Returns true if `ipAllocationPolicy` has been explicitly set.
  public var hasIpAllocationPolicy: Bool {return _storage._ipAllocationPolicy != nil}
  /// Clears the value of `ipAllocationPolicy`. Subsequent reads from it will return its default value.
  public mutating func clearIpAllocationPolicy() {_uniqueStorage()._ipAllocationPolicy = nil}

  /// The configuration options for master authorized networks feature.
  public var masterAuthorizedNetworksConfig: Google_Container_V1alpha1_MasterAuthorizedNetworksConfig {
    get {return _storage._masterAuthorizedNetworksConfig ?? Google_Container_V1alpha1_MasterAuthorizedNetworksConfig()}
    set {_uniqueStorage()._masterAuthorizedNetworksConfig = newValue}
  }
  /// Returns true if `masterAuthorizedNetworksConfig` has been explicitly set.
  public var hasMasterAuthorizedNetworksConfig: Bool {return _storage._masterAuthorizedNetworksConfig != nil}
  /// Clears the value of `masterAuthorizedNetworksConfig`. Subsequent reads from it will return its default value.
  public mutating func clearMasterAuthorizedNetworksConfig() {_uniqueStorage()._masterAuthorizedNetworksConfig = nil}

  /// Configure the maintenance policy for this cluster.
  public var maintenancePolicy: Google_Container_V1alpha1_MaintenancePolicy {
    get {return _storage._maintenancePolicy ?? Google_Container_V1alpha1_MaintenancePolicy()}
    set {_uniqueStorage()._maintenancePolicy = newValue}
  }
  /// Returns true if `maintenancePolicy` has been explicitly set.
  public var hasMaintenancePolicy: Bool {return _storage._maintenancePolicy != nil}
  /// Clears the value of `maintenancePolicy`. Subsequent reads from it will return its default value.
  public mutating func clearMaintenancePolicy() {_uniqueStorage()._maintenancePolicy = nil}

  /// Configuration for the PodSecurityPolicy feature.
  public var podSecurityPolicyConfig: Google_Container_V1alpha1_PodSecurityPolicyConfig {
    get {return _storage._podSecurityPolicyConfig ?? Google_Container_V1alpha1_PodSecurityPolicyConfig()}
    set {_uniqueStorage()._podSecurityPolicyConfig = newValue}
  }
  /// Returns true if `podSecurityPolicyConfig` has been explicitly set.
  public var hasPodSecurityPolicyConfig: Bool {return _storage._podSecurityPolicyConfig != nil}
  /// Clears the value of `podSecurityPolicyConfig`. Subsequent reads from it will return its default value.
  public mutating func clearPodSecurityPolicyConfig() {_uniqueStorage()._podSecurityPolicyConfig = nil}

  /// [Output only] Server-defined URL for the resource.
  public var selfLink: String {
    get {return _storage._selfLink}
    set {_uniqueStorage()._selfLink = newValue}
  }

  /// [Output only] The name of the Google Compute Engine
  /// [zone](/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field is deprecated, use location instead.
  public var zone: String {
    get {return _storage._zone}
    set {_uniqueStorage()._zone = newValue}
  }

  /// [Output only] The IP address of this cluster's master endpoint.
  /// The endpoint can be accessed from the internet at
  /// `https://username:password@endpoint/`.
  ///
  /// See the `masterAuth` property of this resource for username and
  /// password information.
  public var endpoint: String {
    get {return _storage._endpoint}
    set {_uniqueStorage()._endpoint = newValue}
  }

  /// The initial Kubernetes version for this cluster.  Valid versions are those
  /// found in validMasterVersions returned by getServerConfig.  The version can
  /// be upgraded over time; such upgrades are reflected in
  /// currentMasterVersion and currentNodeVersion.
  public var initialClusterVersion: String {
    get {return _storage._initialClusterVersion}
    set {_uniqueStorage()._initialClusterVersion = newValue}
  }

  /// [Output only] The current software version of the master endpoint.
  public var currentMasterVersion: String {
    get {return _storage._currentMasterVersion}
    set {_uniqueStorage()._currentMasterVersion = newValue}
  }

  /// [Output only] The current version of the node software components.
  /// If they are currently at multiple versions because they're in the process
  /// of being upgraded, this reflects the minimum version of all nodes.
  public var currentNodeVersion: String {
    get {return _storage._currentNodeVersion}
    set {_uniqueStorage()._currentNodeVersion = newValue}
  }

  /// [Output only] The time the cluster was created, in
  /// [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
  public var createTime: String {
    get {return _storage._createTime}
    set {_uniqueStorage()._createTime = newValue}
  }

  /// [Output only] The current status of this cluster.
  public var status: Google_Container_V1alpha1_Cluster.Status {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// [Output only] Additional information about the current status of this
  /// cluster, if available.
  public var statusMessage: String {
    get {return _storage._statusMessage}
    set {_uniqueStorage()._statusMessage = newValue}
  }

  /// [Output only] The size of the address space on each node for hosting
  /// containers. This is provisioned from within the `container_ipv4_cidr`
  /// range.
  public var nodeIpv4CidrSize: Int32 {
    get {return _storage._nodeIpv4CidrSize}
    set {_uniqueStorage()._nodeIpv4CidrSize = newValue}
  }

  /// [Output only] The IP address range of the Kubernetes services in
  /// this cluster, in
  /// [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
  /// notation (e.g. `1.2.3.4/29`). Service addresses are
  /// typically put in the last `/16` from the container CIDR.
  public var servicesIpv4Cidr: String {
    get {return _storage._servicesIpv4Cidr}
    set {_uniqueStorage()._servicesIpv4Cidr = newValue}
  }

  /// [Output only] The resource URLs of [instance
  /// groups](/compute/docs/instance-groups/) associated with this
  /// cluster.
  public var instanceGroupUrls: [String] {
    get {return _storage._instanceGroupUrls}
    set {_uniqueStorage()._instanceGroupUrls = newValue}
  }

  /// [Output only] The number of nodes currently in the cluster.
  public var currentNodeCount: Int32 {
    get {return _storage._currentNodeCount}
    set {_uniqueStorage()._currentNodeCount = newValue}
  }

  /// [Output only] The time the cluster will be automatically
  /// deleted in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
  public var expireTime: String {
    get {return _storage._expireTime}
    set {_uniqueStorage()._expireTime = newValue}
  }

  /// [Output only] The name of the Google Compute Engine
  /// [zone](/compute/docs/regions-zones/regions-zones#available) or
  /// [region](/compute/docs/regions-zones/regions-zones#available) in which
  /// the cluster resides.
  public var location: String {
    get {return _storage._location}
    set {_uniqueStorage()._location = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The current status of the cluster.
  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Not set.
    case unspecified // = 0

    /// The PROVISIONING state indicates the cluster is being created.
    case provisioning // = 1

    /// The RUNNING state indicates the cluster has been created and is fully
    /// usable.
    case running // = 2

    /// The RECONCILING state indicates that some work is actively being done on
    /// the cluster, such as upgrading the master or node software. Details can
    /// be found in the `statusMessage` field.
    case reconciling // = 3

    /// The STOPPING state indicates the cluster is being deleted.
    case stopping // = 4

    /// The ERROR state indicates the cluster may be unusable. Details
    /// can be found in the `statusMessage` field.
    case error // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .provisioning
      case 2: self = .running
      case 3: self = .reconciling
      case 4: self = .stopping
      case 5: self = .error
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .provisioning: return 1
      case .running: return 2
      case .reconciling: return 3
      case .stopping: return 4
      case .error: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Google_Container_V1alpha1_Cluster.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Container_V1alpha1_Cluster.Status] = [
    .unspecified,
    .provisioning,
    .running,
    .reconciling,
    .stopping,
    .error,
  ]
}

#endif  // swift(>=4.2)

/// ClusterUpdate describes an update to the cluster. Exactly one update can
/// be applied to a cluster with each request, so at most one field can be
/// provided.
public struct Google_Container_V1alpha1_ClusterUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Kubernetes version to change the nodes to (typically an
  /// upgrade). Use `-` to upgrade to the latest version supported by
  /// the server.
  public var desiredNodeVersion: String = String()

  /// The monitoring service the cluster should use to write metrics.
  /// Currently available options:
  ///
  /// * "monitoring.googleapis.com" - the Google Cloud Monitoring service
  /// * "none" - no metrics will be exported from the cluster
  public var desiredMonitoringService: String = String()

  /// Configurations for the various addons available to run in the cluster.
  public var desiredAddonsConfig: Google_Container_V1alpha1_AddonsConfig {
    get {return _desiredAddonsConfig ?? Google_Container_V1alpha1_AddonsConfig()}
    set {_desiredAddonsConfig = newValue}
  }
  /// Returns true if `desiredAddonsConfig` has been explicitly set.
  public var hasDesiredAddonsConfig: Bool {return self._desiredAddonsConfig != nil}
  /// Clears the value of `desiredAddonsConfig`. Subsequent reads from it will return its default value.
  public mutating func clearDesiredAddonsConfig() {self._desiredAddonsConfig = nil}

  /// The node pool to be upgraded. This field is mandatory if
  /// "desired_node_version", "desired_image_family" or
  /// "desired_node_pool_autoscaling" is specified and there is more than one
  /// node pool on the cluster.
  public var desiredNodePoolID: String = String()

  /// The desired image type for the node pool.
  /// NOTE: Set the "desired_node_pool" field as well.
  public var desiredImageType: String = String()

  /// Autoscaler configuration for the node pool specified in
  /// desired_node_pool_id. If there is only one pool in the
  /// cluster and desired_node_pool_id is not provided then
  /// the change applies to that single node pool.
  public var desiredNodePoolAutoscaling: Google_Container_V1alpha1_NodePoolAutoscaling {
    get {return _desiredNodePoolAutoscaling ?? Google_Container_V1alpha1_NodePoolAutoscaling()}
    set {_desiredNodePoolAutoscaling = newValue}
  }
  /// Returns true if `desiredNodePoolAutoscaling` has been explicitly set.
  public var hasDesiredNodePoolAutoscaling: Bool {return self._desiredNodePoolAutoscaling != nil}
  /// Clears the value of `desiredNodePoolAutoscaling`. Subsequent reads from it will return its default value.
  public mutating func clearDesiredNodePoolAutoscaling() {self._desiredNodePoolAutoscaling = nil}

  /// The desired list of Google Compute Engine
  /// [locations](/compute/docs/zones#available) in which the cluster's nodes
  /// should be located. Changing the locations a cluster is in will result
  /// in nodes being either created or removed from the cluster, depending on
  /// whether locations are being added or removed.
  ///
  /// This list must always include the cluster's primary zone.
  public var desiredLocations: [String] = []

  /// The desired configuration options for master authorized networks feature.
  public var desiredMasterAuthorizedNetworksConfig: Google_Container_V1alpha1_MasterAuthorizedNetworksConfig {
    get {return _desiredMasterAuthorizedNetworksConfig ?? Google_Container_V1alpha1_MasterAuthorizedNetworksConfig()}
    set {_desiredMasterAuthorizedNetworksConfig = newValue}
  }
  /// Returns true if `desiredMasterAuthorizedNetworksConfig` has been explicitly set.
  public var hasDesiredMasterAuthorizedNetworksConfig: Bool {return self._desiredMasterAuthorizedNetworksConfig != nil}
  /// Clears the value of `desiredMasterAuthorizedNetworksConfig`. Subsequent reads from it will return its default value.
  public mutating func clearDesiredMasterAuthorizedNetworksConfig() {self._desiredMasterAuthorizedNetworksConfig = nil}

  /// The desired configuration options for the PodSecurityPolicy feature.
  public var desiredPodSecurityPolicyConfig: Google_Container_V1alpha1_PodSecurityPolicyConfig {
    get {return _desiredPodSecurityPolicyConfig ?? Google_Container_V1alpha1_PodSecurityPolicyConfig()}
    set {_desiredPodSecurityPolicyConfig = newValue}
  }
  /// Returns true if `desiredPodSecurityPolicyConfig` has been explicitly set.
  public var hasDesiredPodSecurityPolicyConfig: Bool {return self._desiredPodSecurityPolicyConfig != nil}
  /// Clears the value of `desiredPodSecurityPolicyConfig`. Subsequent reads from it will return its default value.
  public mutating func clearDesiredPodSecurityPolicyConfig() {self._desiredPodSecurityPolicyConfig = nil}

  /// The Kubernetes version to change the master to. The only valid value is the
  /// latest supported version. Use "-" to have the server automatically select
  /// the latest version.
  public var desiredMasterVersion: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _desiredAddonsConfig: Google_Container_V1alpha1_AddonsConfig? = nil
  fileprivate var _desiredNodePoolAutoscaling: Google_Container_V1alpha1_NodePoolAutoscaling? = nil
  fileprivate var _desiredMasterAuthorizedNetworksConfig: Google_Container_V1alpha1_MasterAuthorizedNetworksConfig? = nil
  fileprivate var _desiredPodSecurityPolicyConfig: Google_Container_V1alpha1_PodSecurityPolicyConfig? = nil
}

/// This operation resource represents operations that may have happened or are
/// happening on the cluster. All fields are output only.
public struct Google_Container_V1alpha1_Operation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The server-assigned ID for the operation.
  public var name: String = String()

  /// The name of the Google Compute Engine
  /// [zone](/compute/docs/zones#available) in which the operation
  /// is taking place.
  /// This field is deprecated, use location instead.
  public var zone: String = String()

  /// The operation type.
  public var operationType: Google_Container_V1alpha1_Operation.TypeEnum = .unspecified

  /// The current status of the operation.
  public var status: Google_Container_V1alpha1_Operation.Status = .unspecified

  /// Detailed operation progress, if available.
  public var detail: String = String()

  /// If an error has occurred, a textual description of the error.
  public var statusMessage: String = String()

  /// Server-defined URL for the resource.
  public var selfLink: String = String()

  /// Server-defined URL for the target of the operation.
  public var targetLink: String = String()

  /// [Output only] The name of the Google Compute Engine
  /// [zone](/compute/docs/regions-zones/regions-zones#available) or
  /// [region](/compute/docs/regions-zones/regions-zones#available) in which
  /// the cluster resides.
  public var location: String = String()

  /// [Output only] The time the operation started, in
  /// [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
  public var startTime: String = String()

  /// [Output only] The time the operation completed, in
  /// [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
  public var endTime: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Current status of the operation.
  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Not set.
    case unspecified // = 0

    /// The operation has been created.
    case pending // = 1

    /// The operation is currently running.
    case running // = 2

    /// The operation is done, either cancelled or completed.
    case done // = 3

    /// The operation is aborting.
    case aborting // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .pending
      case 2: self = .running
      case 3: self = .done
      case 4: self = .aborting
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .pending: return 1
      case .running: return 2
      case .done: return 3
      case .aborting: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Operation type.
  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Not set.
    case unspecified // = 0

    /// Cluster create.
    case createCluster // = 1

    /// Cluster delete.
    case deleteCluster // = 2

    /// A master upgrade.
    case upgradeMaster // = 3

    /// A node upgrade.
    case upgradeNodes // = 4

    /// Cluster repair.
    case repairCluster // = 5

    /// Cluster update.
    case updateCluster // = 6

    /// Node pool create.
    case createNodePool // = 7

    /// Node pool delete.
    case deleteNodePool // = 8

    /// Set node pool management.
    case setNodePoolManagement // = 9

    /// Automatic node pool repair.
    case autoRepairNodes // = 10

    /// Automatic node upgrade.
    case autoUpgradeNodes // = 11

    /// Set labels.
    case setLabels // = 12

    /// Set/generate master auth materials
    case setMasterAuth // = 13

    /// Set node pool size.
    case setNodePoolSize // = 14

    /// Updates network policy for a cluster.
    case setNetworkPolicy // = 15

    /// Set the maintenance policy.
    case setMaintenancePolicy // = 16
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .createCluster
      case 2: self = .deleteCluster
      case 3: self = .upgradeMaster
      case 4: self = .upgradeNodes
      case 5: self = .repairCluster
      case 6: self = .updateCluster
      case 7: self = .createNodePool
      case 8: self = .deleteNodePool
      case 9: self = .setNodePoolManagement
      case 10: self = .autoRepairNodes
      case 11: self = .autoUpgradeNodes
      case 12: self = .setLabels
      case 13: self = .setMasterAuth
      case 14: self = .setNodePoolSize
      case 15: self = .setNetworkPolicy
      case 16: self = .setMaintenancePolicy
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .createCluster: return 1
      case .deleteCluster: return 2
      case .upgradeMaster: return 3
      case .upgradeNodes: return 4
      case .repairCluster: return 5
      case .updateCluster: return 6
      case .createNodePool: return 7
      case .deleteNodePool: return 8
      case .setNodePoolManagement: return 9
      case .autoRepairNodes: return 10
      case .autoUpgradeNodes: return 11
      case .setLabels: return 12
      case .setMasterAuth: return 13
      case .setNodePoolSize: return 14
      case .setNetworkPolicy: return 15
      case .setMaintenancePolicy: return 16
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Container_V1alpha1_Operation.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Container_V1alpha1_Operation.Status] = [
    .unspecified,
    .pending,
    .running,
    .done,
    .aborting,
  ]
}

extension Google_Container_V1alpha1_Operation.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Container_V1alpha1_Operation.TypeEnum] = [
    .unspecified,
    .createCluster,
    .deleteCluster,
    .upgradeMaster,
    .upgradeNodes,
    .repairCluster,
    .updateCluster,
    .createNodePool,
    .deleteNodePool,
    .setNodePoolManagement,
    .autoRepairNodes,
    .autoUpgradeNodes,
    .setLabels,
    .setMasterAuth,
    .setNodePoolSize,
    .setNetworkPolicy,
    .setMaintenancePolicy,
  ]
}

#endif  // swift(>=4.2)

/// CreateClusterRequest creates a cluster.
public struct Google_Container_V1alpha1_CreateClusterRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Google Developers Console [project ID or project
  /// number](https://support.google.com/cloud/answer/6158840).
  /// This field is deprecated, use parent instead.
  public var projectID: String = String()

  /// The name of the Google Compute Engine
  /// [zone](/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field is deprecated, use parent instead.
  public var zone: String = String()

  /// A [cluster
  /// resource](/container-engine/reference/rest/v1alpha1/projects.zones.clusters)
  public var cluster: Google_Container_V1alpha1_Cluster {
    get {return _cluster ?? Google_Container_V1alpha1_Cluster()}
    set {_cluster = newValue}
  }
  /// Returns true if `cluster` has been explicitly set.
  public var hasCluster: Bool {return self._cluster != nil}
  /// Clears the value of `cluster`. Subsequent reads from it will return its default value.
  public mutating func clearCluster() {self._cluster = nil}

  /// The parent (project and location) where the cluster will be created.
  /// Specified in the format 'projects/*/locations/*'.
  public var parent: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _cluster: Google_Container_V1alpha1_Cluster? = nil
}

/// GetClusterRequest gets the settings of a cluster.
public struct Google_Container_V1alpha1_GetClusterRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Google Developers Console [project ID or project
  /// number](https://support.google.com/cloud/answer/6158840).
  /// This field is deprecated, use name instead.
  public var projectID: String = String()

  /// The name of the Google Compute Engine
  /// [zone](/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field is deprecated, use name instead.
  public var zone: String = String()

  /// The name of the cluster to retrieve.
  /// This field is deprecated, use name instead.
  public var clusterID: String = String()

  /// The name (project, location, cluster) of the cluster to retrieve.
  /// Specified in the format 'projects/*/locations/*/clusters/*'.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// UpdateClusterRequest updates the settings of a cluster.
public struct Google_Container_V1alpha1_UpdateClusterRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Google Developers Console [project ID or project
  /// number](https://support.google.com/cloud/answer/6158840).
  /// This field is deprecated, use name instead.
  public var projectID: String {
    get {return _storage._projectID}
    set {_uniqueStorage()._projectID = newValue}
  }

  /// The name of the Google Compute Engine
  /// [zone](/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field is deprecated, use name instead.
  public var zone: String {
    get {return _storage._zone}
    set {_uniqueStorage()._zone = newValue}
  }

  /// The name of the cluster to upgrade.
  /// This field is deprecated, use name instead.
  public var clusterID: String {
    get {return _storage._clusterID}
    set {_uniqueStorage()._clusterID = newValue}
  }

  /// A description of the update.
  public var update: Google_Container_V1alpha1_ClusterUpdate {
    get {return _storage._update ?? Google_Container_V1alpha1_ClusterUpdate()}
    set {_uniqueStorage()._update = newValue}
  }
  /// Returns true if `update` has been explicitly set.
  public var hasUpdate: Bool {return _storage._update != nil}
  /// Clears the value of `update`. Subsequent reads from it will return its default value.
  public mutating func clearUpdate() {_uniqueStorage()._update = nil}

  /// The name (project, location, cluster) of the cluster to update.
  /// Specified in the format 'projects/*/locations/*/clusters/*'.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// SetNodePoolVersionRequest updates the version of a node pool.
public struct Google_Container_V1alpha1_UpdateNodePoolRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Google Developers Console [project ID or project
  /// number](https://support.google.com/cloud/answer/6158840).
  /// This field is deprecated, use name instead.
  public var projectID: String = String()

  /// The name of the Google Compute Engine
  /// [zone](/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field is deprecated, use name instead.
  public var zone: String = String()

  /// The name of the cluster to upgrade.
  /// This field is deprecated, use name instead.
  public var clusterID: String = String()

  /// The name of the node pool to upgrade.
  /// This field is deprecated, use name instead.
  public var nodePoolID: String = String()

  /// The Kubernetes version to change the nodes to (typically an
  /// upgrade). Use `-` to upgrade to the latest version supported by
  /// the server.
  public var nodeVersion: String = String()

  /// The desired image type for the node pool.
  public var imageType: String = String()

  /// The name (project, location, cluster, node pool) of the node pool to update.
  /// Specified in the format 'projects/*/locations/*/clusters/*/nodePools/*'.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// SetNodePoolAutoscalingRequest sets the autoscaler settings of a node pool.
public struct Google_Container_V1alpha1_SetNodePoolAutoscalingRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Google Developers Console [project ID or project
  /// number](https://support.google.com/cloud/answer/6158840).
  /// This field is deprecated, use name instead.
  public var projectID: String = String()

  /// The name of the Google Compute Engine
  /// [zone](/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field is deprecated, use name instead.
  public var zone: String = String()

  /// The name of the cluster to upgrade.
  /// This field is deprecated, use name instead.
  public var clusterID: String = String()

  /// The name of the node pool to upgrade.
  /// This field is deprecated, use name instead.
  public var nodePoolID: String = String()

  /// Autoscaling configuration for the node pool.
  public var autoscaling: Google_Container_V1alpha1_NodePoolAutoscaling {
    get {return _autoscaling ?? Google_Container_V1alpha1_NodePoolAutoscaling()}
    set {_autoscaling = newValue}
  }
  /// Returns true if `autoscaling` has been explicitly set.
  public var hasAutoscaling: Bool {return self._autoscaling != nil}
  /// Clears the value of `autoscaling`. Subsequent reads from it will return its default value.
  public mutating func clearAutoscaling() {self._autoscaling = nil}

  /// The name (project, location, cluster, node pool) of the node pool to set
  /// autoscaler settings. Specified in the format
  /// 'projects/*/locations/*/clusters/*/nodePools/*'.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _autoscaling: Google_Container_V1alpha1_NodePoolAutoscaling? = nil
}

/// SetLoggingServiceRequest sets the logging service of a cluster.
public struct Google_Container_V1alpha1_SetLoggingServiceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Google Developers Console [project ID or project
  /// number](https://support.google.com/cloud/answer/6158840).
  /// This field is deprecated, use name instead.
  public var projectID: String = String()

  /// The name of the Google Compute Engine
  /// [zone](/compute/docs/zones#available) in which the cluster
  /// resides.
  public var zone: String = String()

  /// The name of the cluster to upgrade.
  /// This field is deprecated, use name instead.
  public var clusterID: String = String()

  /// The logging service the cluster should use to write metrics.
  /// Currently available options:
  ///
  /// * "logging.googleapis.com" - the Google Cloud Logging service
  /// * "none" - no metrics will be exported from the cluster
  public var loggingService: String = String()

  /// The name (project, location, cluster) of the cluster to set logging.
  /// Specified in the format 'projects/*/locations/*/clusters/*'.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// SetMonitoringServiceRequest sets the monitoring service of a cluster.
public struct Google_Container_V1alpha1_SetMonitoringServiceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Google Developers Console [project ID or project
  /// number](https://support.google.com/cloud/answer/6158840).
  /// This field is deprecated, use name instead.
  public var projectID: String = String()

  /// The name of the Google Compute Engine
  /// [zone](/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field is deprecated, use name instead.
  public var zone: String = String()

  /// The name of the cluster to upgrade.
  /// This field is deprecated, use name instead.
  public var clusterID: String = String()

  /// The monitoring service the cluster should use to write metrics.
  /// Currently available options:
  ///
  /// * "monitoring.googleapis.com" - the Google Cloud Monitoring service
  /// * "none" - no metrics will be exported from the cluster
  public var monitoringService: String = String()

  /// The name (project, location, cluster) of the cluster to set monitoring.
  /// Specified in the format 'projects/*/locations/*/clusters/*'.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// SetAddonsRequest sets the addons associated with the cluster.
public struct Google_Container_V1alpha1_SetAddonsConfigRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Google Developers Console [project ID or project
  /// number](https://support.google.com/cloud/answer/6158840).
  /// This field is deprecated, use name instead.
  public var projectID: String = String()

  /// The name of the Google Compute Engine
  /// [zone](/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field is deprecated, use name instead.
  public var zone: String = String()

  /// The name of the cluster to upgrade.
  /// This field is deprecated, use name instead.
  public var clusterID: String = String()

  /// The desired configurations for the various addons available to run in the
  /// cluster.
  public var addonsConfig: Google_Container_V1alpha1_AddonsConfig {
    get {return _addonsConfig ?? Google_Container_V1alpha1_AddonsConfig()}
    set {_addonsConfig = newValue}
  }
  /// Returns true if `addonsConfig` has been explicitly set.
  public var hasAddonsConfig: Bool {return self._addonsConfig != nil}
  /// Clears the value of `addonsConfig`. Subsequent reads from it will return its default value.
  public mutating func clearAddonsConfig() {self._addonsConfig = nil}

  /// The name (project, location, cluster) of the cluster to set addons.
  /// Specified in the format 'projects/*/locations/*/clusters/*'.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _addonsConfig: Google_Container_V1alpha1_AddonsConfig? = nil
}

/// SetLocationsRequest sets the locations of the cluster.
public struct Google_Container_V1alpha1_SetLocationsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Google Developers Console [project ID or project
  /// number](https://support.google.com/cloud/answer/6158840).
  /// This field is deprecated, use name instead.
  public var projectID: String = String()

  /// The name of the Google Compute Engine
  /// [zone](/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field is deprecated, use name instead.
  public var zone: String = String()

  /// The name of the cluster to upgrade.
  /// This field is deprecated, use name instead.
  public var clusterID: String = String()

  /// The desired list of Google Compute Engine
  /// [locations](/compute/docs/zones#available) in which the cluster's nodes
  /// should be located. Changing the locations a cluster is in will result
  /// in nodes being either created or removed from the cluster, depending on
  /// whether locations are being added or removed.
  ///
  /// This list must always include the cluster's primary zone.
  public var locations: [String] = []

  /// The name (project, location, cluster) of the cluster to set locations.
  /// Specified in the format 'projects/*/locations/*/clusters/*'.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// UpdateMasterRequest updates the master of the cluster.
public struct Google_Container_V1alpha1_UpdateMasterRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Google Developers Console [project ID or project
  /// number](https://support.google.com/cloud/answer/6158840).
  public var projectID: String = String()

  /// The name of the Google Compute Engine
  /// [zone](/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field is deprecated, use name instead.
  public var zone: String = String()

  /// The name of the cluster to upgrade.
  /// This field is deprecated, use name instead.
  public var clusterID: String = String()

  /// The Kubernetes version to change the master to. The only valid value is the
  /// latest supported version. Use "-" to have the server automatically select
  /// the latest version.
  public var masterVersion: String = String()

  /// The name (project, location, cluster) of the cluster to update.
  /// Specified in the format 'projects/*/locations/*/clusters/*'.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// SetMasterAuthRequest updates the admin password of a cluster.
public struct Google_Container_V1alpha1_SetMasterAuthRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Google Developers Console [project ID or project
  /// number](https://support.google.com/cloud/answer/6158840).
  /// This field is deprecated, use name instead.
  public var projectID: String = String()

  /// The name of the Google Compute Engine
  /// [zone](/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field is deprecated, use name instead.
  public var zone: String = String()

  /// The name of the cluster to upgrade.
  /// This field is deprecated, use name instead.
  public var clusterID: String = String()

  /// The exact form of action to be taken on the master auth.
  public var action: Google_Container_V1alpha1_SetMasterAuthRequest.Action = .unknown

  /// A description of the update.
  public var update: Google_Container_V1alpha1_MasterAuth {
    get {return _update ?? Google_Container_V1alpha1_MasterAuth()}
    set {_update = newValue}
  }
  /// Returns true if `update` has been explicitly set.
  public var hasUpdate: Bool {return self._update != nil}
  /// Clears the value of `update`. Subsequent reads from it will return its default value.
  public mutating func clearUpdate() {self._update = nil}

  /// The name (project, location, cluster) of the cluster to set auth.
  /// Specified in the format 'projects/*/locations/*/clusters/*'.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Operation type: what type update to perform.
  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Operation is unknown and will error out.
    case unknown // = 0

    /// Set the password to a user generated value.
    case setPassword // = 1

    /// Generate a new password and set it to that.
    case generatePassword // = 2

    /// Set the username.  If an empty username is provided, basic authentication
    /// is disabled for the cluster.  If a non-empty username is provided, basic
    /// authentication is enabled, with either a provided password or a generated
    /// one.
    case setUsername // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .setPassword
      case 2: self = .generatePassword
      case 3: self = .setUsername
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .setPassword: return 1
      case .generatePassword: return 2
      case .setUsername: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _update: Google_Container_V1alpha1_MasterAuth? = nil
}

#if swift(>=4.2)

extension Google_Container_V1alpha1_SetMasterAuthRequest.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Container_V1alpha1_SetMasterAuthRequest.Action] = [
    .unknown,
    .setPassword,
    .generatePassword,
    .setUsername,
  ]
}

#endif  // swift(>=4.2)

/// DeleteClusterRequest deletes a cluster.
public struct Google_Container_V1alpha1_DeleteClusterRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Google Developers Console [project ID or project
  /// number](https://support.google.com/cloud/answer/6158840).
  /// This field is deprecated, use name instead.
  public var projectID: String = String()

  /// The name of the Google Compute Engine
  /// [zone](/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field is deprecated, use name instead.
  public var zone: String = String()

  /// The name of the cluster to delete.
  /// This field is deprecated, use name instead.
  public var clusterID: String = String()

  /// The name (project, location, cluster) of the cluster to delete.
  /// Specified in the format 'projects/*/locations/*/clusters/*'.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ListClustersRequest lists clusters.
public struct Google_Container_V1alpha1_ListClustersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Google Developers Console [project ID or project
  /// number](https://support.google.com/cloud/answer/6158840).
  /// This field is deprecated, use parent instead.
  public var projectID: String = String()

  /// The name of the Google Compute Engine
  /// [zone](/compute/docs/zones#available) in which the cluster
  /// resides, or "-" for all zones.
  /// This field is deprecated, use parent instead.
  public var zone: String = String()

  /// The parent (project and location) where the clusters will be listed.
  /// Specified in the format 'projects/*/locations/*'.
  /// Location "-" matches all zones and all regions.
  public var parent: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ListClustersResponse is the result of ListClustersRequest.
public struct Google_Container_V1alpha1_ListClustersResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of clusters in the project in the specified zone, or
  /// across all ones.
  public var clusters: [Google_Container_V1alpha1_Cluster] = []

  /// If any zones are listed here, the list of clusters returned
  /// may be missing those zones.
  public var missingZones: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// GetOperationRequest gets a single operation.
public struct Google_Container_V1alpha1_GetOperationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Google Developers Console [project ID or project
  /// number](https://support.google.com/cloud/answer/6158840).
  /// This field is deprecated, use name instead.
  public var projectID: String = String()

  /// The name of the Google Compute Engine
  /// [zone](/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field is deprecated, use name instead.
  public var zone: String = String()

  /// The server-assigned `name` of the operation.
  /// This field is deprecated, use name instead.
  public var operationID: String = String()

  /// The name (project, location, operation id) of the operation to get.
  /// Specified in the format 'projects/*/locations/*/operations/*'.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ListOperationsRequest lists operations.
public struct Google_Container_V1alpha1_ListOperationsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Google Developers Console [project ID or project
  /// number](https://support.google.com/cloud/answer/6158840).
  /// This field is deprecated, use parent instead.
  public var projectID: String = String()

  /// The name of the Google Compute Engine [zone](/compute/docs/zones#available)
  /// to return operations for, or `-` for all zones.
  /// This field is deprecated, use parent instead.
  public var zone: String = String()

  /// The parent (project and location) where the operations will be listed.
  /// Specified in the format 'projects/*/locations/*'.
  /// Location "-" matches all zones and all regions.
  public var parent: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// CancelOperationRequest cancels a single operation.
public struct Google_Container_V1alpha1_CancelOperationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Google Developers Console [project ID or project
  /// number](https://support.google.com/cloud/answer/6158840).
  /// This field is deprecated, use name instead.
  public var projectID: String = String()

  /// The name of the Google Compute Engine
  /// [zone](/compute/docs/zones#available) in which the operation resides.
  /// This field is deprecated, use name instead.
  public var zone: String = String()

  /// The server-assigned `name` of the operation.
  /// This field is deprecated, use name instead.
  public var operationID: String = String()

  /// The name (project, location, operation id) of the operation to cancel.
  /// Specified in the format 'projects/*/locations/*/operations/*'.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ListOperationsResponse is the result of ListOperationsRequest.
public struct Google_Container_V1alpha1_ListOperationsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of operations in the project in the specified zone.
  public var operations: [Google_Container_V1alpha1_Operation] = []

  /// If any zones are listed here, the list of operations returned
  /// may be missing the operations from those zones.
  public var missingZones: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Gets the current Container Engine service configuration.
public struct Google_Container_V1alpha1_GetServerConfigRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Google Developers Console [project ID or project
  /// number](https://support.google.com/cloud/answer/6158840).
  /// This field is deprecated, use name instead.
  public var projectID: String = String()

  /// The name of the Google Compute Engine [zone](/compute/docs/zones#available)
  /// to return operations for.
  /// This field is deprecated, use name instead.
  public var zone: String = String()

  /// The name (project and location) of the server config to get
  /// Specified in the format 'projects/*/locations/*'.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Container Engine service configuration.
public struct Google_Container_V1alpha1_ServerConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Version of Kubernetes the service deploys by default.
  public var defaultClusterVersion: String = String()

  /// List of valid node upgrade target versions.
  public var validNodeVersions: [String] = []

  /// Default image type.
  public var defaultImageType: String = String()

  /// List of valid image types.
  public var validImageTypes: [String] = []

  /// List of valid master versions.
  public var validMasterVersions: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// CreateNodePoolRequest creates a node pool for a cluster.
public struct Google_Container_V1alpha1_CreateNodePoolRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Google Developers Console [project ID or project
  /// number](https://developers.google.com/console/help/new/#projectnumber).
  /// This field is deprecated, use parent instead.
  public var projectID: String = String()

  /// The name of the Google Compute Engine
  /// [zone](/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field is deprecated, use parent instead.
  public var zone: String = String()

  /// The name of the cluster.
  /// This field is deprecated, use parent instead.
  public var clusterID: String = String()

  /// The node pool to create.
  public var nodePool: Google_Container_V1alpha1_NodePool {
    get {return _nodePool ?? Google_Container_V1alpha1_NodePool()}
    set {_nodePool = newValue}
  }
  /// Returns true if `nodePool` has been explicitly set.
  public var hasNodePool: Bool {return self._nodePool != nil}
  /// Clears the value of `nodePool`. Subsequent reads from it will return its default value.
  public mutating func clearNodePool() {self._nodePool = nil}

  /// The parent (project, location, cluster id) where the node pool will be created.
  /// Specified in the format 'projects/*/locations/*/clusters/*/nodePools/*'.
  public var parent: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _nodePool: Google_Container_V1alpha1_NodePool? = nil
}

/// DeleteNodePoolRequest deletes a node pool for a cluster.
public struct Google_Container_V1alpha1_DeleteNodePoolRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Google Developers Console [project ID or project
  /// number](https://developers.google.com/console/help/new/#projectnumber).
  /// This field is deprecated, use name instead.
  public var projectID: String = String()

  /// The name of the Google Compute Engine
  /// [zone](/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field is deprecated, use name instead.
  public var zone: String = String()

  /// The name of the cluster.
  /// This field is deprecated, use name instead.
  public var clusterID: String = String()

  /// The name of the node pool to delete.
  /// This field is deprecated, use name instead.
  public var nodePoolID: String = String()

  /// The name (project, location, cluster, node pool id) of the node pool to delete.
  /// Specified in the format 'projects/*/locations/*/clusters/*/nodePools/*'.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ListNodePoolsRequest lists the node pool(s) for a cluster.
public struct Google_Container_V1alpha1_ListNodePoolsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Google Developers Console [project ID or project
  /// number](https://developers.google.com/console/help/new/#projectnumber).
  /// This field is deprecated, use parent instead.
  public var projectID: String = String()

  /// The name of the Google Compute Engine
  /// [zone](/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field is deprecated, use parent instead.
  public var zone: String = String()

  /// The name of the cluster.
  /// This field is deprecated, use parent instead.
  public var clusterID: String = String()

  /// The parent (project, location, cluster id) where the node pools will be listed.
  /// Specified in the format 'projects/*/locations/*/clusters/*'.
  public var parent: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// GetNodePoolRequest retrieves a node pool for a cluster.
public struct Google_Container_V1alpha1_GetNodePoolRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Google Developers Console [project ID or project
  /// number](https://developers.google.com/console/help/new/#projectnumber).
  /// This field is deprecated, use name instead.
  public var projectID: String = String()

  /// The name of the Google Compute Engine
  /// [zone](/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field is deprecated, use name instead.
  public var zone: String = String()

  /// The name of the cluster.
  /// This field is deprecated, use name instead.
  public var clusterID: String = String()

  /// The name of the node pool.
  /// This field is deprecated, use name instead.
  public var nodePoolID: String = String()

  /// The name (project, location, cluster, node pool id) of the node pool to get.
  /// Specified in the format 'projects/*/locations/*/clusters/*/nodePools/*'.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// NodePool contains the name and configuration for a cluster's node pool.
/// Node pools are a set of nodes (i.e. VM's), with a common configuration and
/// specification, under the control of the cluster master. They may have a set
/// of Kubernetes labels applied to them, which may be used to reference them
/// during pod scheduling. They may also be resized up or down, to accommodate
/// the workload.
public struct Google_Container_V1alpha1_NodePool {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the node pool.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// The node configuration of the pool.
  public var config: Google_Container_V1alpha1_NodeConfig {
    get {return _storage._config ?? Google_Container_V1alpha1_NodeConfig()}
    set {_uniqueStorage()._config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  public var hasConfig: Bool {return _storage._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  public mutating func clearConfig() {_uniqueStorage()._config = nil}

  /// The initial node count for the pool. You must ensure that your
  /// Compute Engine <a href="/compute/docs/resource-quotas">resource quota</a>
  /// is sufficient for this number of instances. You must also have available
  /// firewall and routes quota.
  public var initialNodeCount: Int32 {
    get {return _storage._initialNodeCount}
    set {_uniqueStorage()._initialNodeCount = newValue}
  }

  /// Autoscaler configuration for this NodePool. Autoscaler is enabled
  /// only if a valid configuration is present.
  public var autoscaling: Google_Container_V1alpha1_NodePoolAutoscaling {
    get {return _storage._autoscaling ?? Google_Container_V1alpha1_NodePoolAutoscaling()}
    set {_uniqueStorage()._autoscaling = newValue}
  }
  /// Returns true if `autoscaling` has been explicitly set.
  public var hasAutoscaling: Bool {return _storage._autoscaling != nil}
  /// Clears the value of `autoscaling`. Subsequent reads from it will return its default value.
  public mutating func clearAutoscaling() {_uniqueStorage()._autoscaling = nil}

  /// NodeManagement configuration for this NodePool.
  public var management: Google_Container_V1alpha1_NodeManagement {
    get {return _storage._management ?? Google_Container_V1alpha1_NodeManagement()}
    set {_uniqueStorage()._management = newValue}
  }
  /// Returns true if `management` has been explicitly set.
  public var hasManagement: Bool {return _storage._management != nil}
  /// Clears the value of `management`. Subsequent reads from it will return its default value.
  public mutating func clearManagement() {_uniqueStorage()._management = nil}

  /// [Output only] Server-defined URL for the resource.
  public var selfLink: String {
    get {return _storage._selfLink}
    set {_uniqueStorage()._selfLink = newValue}
  }

  /// [Output only] The version of the Kubernetes of this node.
  public var version: String {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  /// [Output only] The resource URLs of [instance
  /// groups](/compute/docs/instance-groups/) associated with this
  /// node pool.
  public var instanceGroupUrls: [String] {
    get {return _storage._instanceGroupUrls}
    set {_uniqueStorage()._instanceGroupUrls = newValue}
  }

  /// [Output only] The status of the nodes in this pool instance.
  public var status: Google_Container_V1alpha1_NodePool.Status {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// [Output only] Additional information about the current status of this
  /// node pool instance, if available.
  public var statusMessage: String {
    get {return _storage._statusMessage}
    set {_uniqueStorage()._statusMessage = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The current status of the node pool instance.
  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Not set.
    case unspecified // = 0

    /// The PROVISIONING state indicates the node pool is being created.
    case provisioning // = 1

    /// The RUNNING state indicates the node pool has been created
    /// and is fully usable.
    case running // = 2

    /// The RUNNING_WITH_ERROR state indicates the node pool has been created
    /// and is partially usable. Some error state has occurred and some
    /// functionality may be impaired. Customer may need to reissue a request
    /// or trigger a new update.
    case runningWithError // = 3

    /// The RECONCILING state indicates that some work is actively being done on
    /// the node pool, such as upgrading node software. Details can
    /// be found in the `statusMessage` field.
    case reconciling // = 4

    /// The STOPPING state indicates the node pool is being deleted.
    case stopping // = 5

    /// The ERROR state indicates the node pool may be unusable. Details
    /// can be found in the `statusMessage` field.
    case error // = 6
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .provisioning
      case 2: self = .running
      case 3: self = .runningWithError
      case 4: self = .reconciling
      case 5: self = .stopping
      case 6: self = .error
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .provisioning: return 1
      case .running: return 2
      case .runningWithError: return 3
      case .reconciling: return 4
      case .stopping: return 5
      case .error: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Google_Container_V1alpha1_NodePool.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Container_V1alpha1_NodePool.Status] = [
    .unspecified,
    .provisioning,
    .running,
    .runningWithError,
    .reconciling,
    .stopping,
    .error,
  ]
}

#endif  // swift(>=4.2)

/// NodeManagement defines the set of node management services turned on for the
/// node pool.
public struct Google_Container_V1alpha1_NodeManagement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether the nodes will be automatically upgraded.
  public var autoUpgrade: Bool = false

  /// Whether the nodes will be automatically repaired.
  public var autoRepair: Bool = false

  /// Specifies the Auto Upgrade knobs for the node pool.
  public var upgradeOptions: Google_Container_V1alpha1_AutoUpgradeOptions {
    get {return _upgradeOptions ?? Google_Container_V1alpha1_AutoUpgradeOptions()}
    set {_upgradeOptions = newValue}
  }
  /// Returns true if `upgradeOptions` has been explicitly set.
  public var hasUpgradeOptions: Bool {return self._upgradeOptions != nil}
  /// Clears the value of `upgradeOptions`. Subsequent reads from it will return its default value.
  public mutating func clearUpgradeOptions() {self._upgradeOptions = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _upgradeOptions: Google_Container_V1alpha1_AutoUpgradeOptions? = nil
}

/// AutoUpgradeOptions defines the set of options for the user to control how
/// the Auto Upgrades will proceed.
public struct Google_Container_V1alpha1_AutoUpgradeOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// [Output only] This field is set when upgrades are about to commence
  /// with the approximate start time for the upgrades, in
  /// [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
  public var autoUpgradeStartTime: String = String()

  /// [Output only] This field is set when upgrades are about to commence
  /// with the description of the upgrade.
  public var description_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// MaintenancePolicy defines the maintenance policy to be used for the cluster.
public struct Google_Container_V1alpha1_MaintenancePolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies the maintenance window in which maintenance may be performed.
  public var window: Google_Container_V1alpha1_MaintenanceWindow {
    get {return _window ?? Google_Container_V1alpha1_MaintenanceWindow()}
    set {_window = newValue}
  }
  /// Returns true if `window` has been explicitly set.
  public var hasWindow: Bool {return self._window != nil}
  /// Clears the value of `window`. Subsequent reads from it will return its default value.
  public mutating func clearWindow() {self._window = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _window: Google_Container_V1alpha1_MaintenanceWindow? = nil
}

/// MaintenanceWindow defines the maintenance window to be used for the cluster.
public struct Google_Container_V1alpha1_MaintenanceWindow {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unimplemented, reserved for future use.
  /// HourlyMaintenanceWindow hourly_maintenance_window = 1;
  public var policy: Google_Container_V1alpha1_MaintenanceWindow.OneOf_Policy? = nil

  /// DailyMaintenanceWindow specifies a daily maintenance operation window.
  public var dailyMaintenanceWindow: Google_Container_V1alpha1_DailyMaintenanceWindow {
    get {
      if case .dailyMaintenanceWindow(let v)? = policy {return v}
      return Google_Container_V1alpha1_DailyMaintenanceWindow()
    }
    set {policy = .dailyMaintenanceWindow(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Unimplemented, reserved for future use.
  /// HourlyMaintenanceWindow hourly_maintenance_window = 1;
  public enum OneOf_Policy: Equatable {
    /// DailyMaintenanceWindow specifies a daily maintenance operation window.
    case dailyMaintenanceWindow(Google_Container_V1alpha1_DailyMaintenanceWindow)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Container_V1alpha1_MaintenanceWindow.OneOf_Policy, rhs: Google_Container_V1alpha1_MaintenanceWindow.OneOf_Policy) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.dailyMaintenanceWindow, .dailyMaintenanceWindow): return {
        guard case .dailyMaintenanceWindow(let l) = lhs, case .dailyMaintenanceWindow(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

/// Time window specified for daily maintenance operations.
public struct Google_Container_V1alpha1_DailyMaintenanceWindow {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Time within the maintenance window to start the maintenance operations.
  /// It must be in format "HH:MM”, where HH : [00-23] and MM : [00-59] GMT.
  public var startTime: String = String()

  /// [Output only] Duration of the time window, automatically chosen to be
  /// smallest possible in the given scenario.
  public var duration: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// SetNodePoolManagementRequest sets the node management properties of a node
/// pool.
public struct Google_Container_V1alpha1_SetNodePoolManagementRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Google Developers Console [project ID or project
  /// number](https://support.google.com/cloud/answer/6158840).
  /// This field is deprecated, use name instead.
  public var projectID: String = String()

  /// The name of the Google Compute Engine
  /// [zone](/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field is deprecated, use name instead.
  public var zone: String = String()

  /// The name of the cluster to update.
  /// This field is deprecated, use name instead.
  public var clusterID: String = String()

  /// The name of the node pool to update.
  /// This field is deprecated, use name instead.
  public var nodePoolID: String = String()

  /// NodeManagement configuration for the node pool.
  public var management: Google_Container_V1alpha1_NodeManagement {
    get {return _management ?? Google_Container_V1alpha1_NodeManagement()}
    set {_management = newValue}
  }
  /// Returns true if `management` has been explicitly set.
  public var hasManagement: Bool {return self._management != nil}
  /// Clears the value of `management`. Subsequent reads from it will return its default value.
  public mutating func clearManagement() {self._management = nil}

  /// The name (project, location, cluster, node pool id) of the node pool to set
  /// management properties. Specified in the format
  /// 'projects/*/locations/*/clusters/*/nodePools/*'.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _management: Google_Container_V1alpha1_NodeManagement? = nil
}

/// SetNodePoolSizeRequest sets the size a node
/// pool.
public struct Google_Container_V1alpha1_SetNodePoolSizeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Google Developers Console [project ID or project
  /// number](https://support.google.com/cloud/answer/6158840).
  public var projectID: String = String()

  /// The name of the Google Compute Engine
  /// [zone](/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field is deprecated, use name instead.
  public var zone: String = String()

  /// The name of the cluster to update.
  /// This field is deprecated, use name instead.
  public var clusterID: String = String()

  /// The name of the node pool to update.
  /// This field is deprecated, use name instead.
  public var nodePoolID: String = String()

  /// The desired node count for the pool.
  public var nodeCount: Int32 = 0

  /// The name (project, location, cluster, node pool id) of the node pool to set
  /// size.
  /// Specified in the format 'projects/*/locations/*/clusters/*/nodePools/*'.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// RollbackNodePoolUpgradeRequest rollbacks the previously Aborted or Failed
/// NodePool upgrade. This will be an no-op if the last upgrade successfully
/// completed.
public struct Google_Container_V1alpha1_RollbackNodePoolUpgradeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Google Developers Console [project ID or project
  /// number](https://support.google.com/cloud/answer/6158840).
  /// This field is deprecated, use name instead.
  public var projectID: String = String()

  /// The name of the Google Compute Engine
  /// [zone](/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field is deprecated, use name instead.
  public var zone: String = String()

  /// The name of the cluster to rollback.
  /// This field is deprecated, use name instead.
  public var clusterID: String = String()

  /// The name of the node pool to rollback.
  /// This field is deprecated, use name instead.
  public var nodePoolID: String = String()

  /// The name (project, location, cluster, node pool id) of the node poll to
  /// rollback upgrade.
  /// Specified in the format 'projects/*/locations/*/clusters/*/nodePools/*'.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ListNodePoolsResponse is the result of ListNodePoolsRequest.
public struct Google_Container_V1alpha1_ListNodePoolsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of node pools for a cluster.
  public var nodePools: [Google_Container_V1alpha1_NodePool] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// NodePoolAutoscaling contains information required by cluster autoscaler to
/// adjust the size of the node pool to the current cluster usage.
public struct Google_Container_V1alpha1_NodePoolAutoscaling {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Is autoscaling enabled for this node pool.
  public var enabled: Bool = false

  /// Minimum number of nodes in the NodePool. Must be >= 1 and <=
  /// max_node_count.
  public var minNodeCount: Int32 = 0

  /// Maximum number of nodes in the NodePool. Must be >= min_node_count. There
  /// has to enough quota to scale up the cluster.
  public var maxNodeCount: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// SetLabelsRequest sets the Google Cloud Platform labels on a Google Container
/// Engine cluster, which will in turn set them for Google Compute Engine
/// resources used by that cluster
public struct Google_Container_V1alpha1_SetLabelsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Google Developers Console [project ID or project
  /// number](https://developers.google.com/console/help/new/#projectnumber).
  /// This field is deprecated, use name instead.
  public var projectID: String = String()

  /// The name of the Google Compute Engine
  /// [zone](/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field is deprecated, use name instead.
  public var zone: String = String()

  /// The name of the cluster.
  /// This field is deprecated, use name instead.
  public var clusterID: String = String()

  /// The labels to set for that cluster.
  public var resourceLabels: Dictionary<String,String> = [:]

  /// The fingerprint of the previous set of labels for this resource,
  /// used to detect conflicts. The fingerprint is initially generated by
  /// Container Engine and changes after every request to modify or update
  /// labels. You must always provide an up-to-date fingerprint hash when
  /// updating or changing labels. Make a <code>get()</code> request to the
  /// resource to get the latest fingerprint.
  public var labelFingerprint: String = String()

  /// The name (project, location, cluster id) of the cluster to set labels.
  /// Specified in the format 'projects/*/locations/*/clusters/*'.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// SetLegacyAbacRequest enables or disables the ABAC authorization mechanism for
/// a cluster.
public struct Google_Container_V1alpha1_SetLegacyAbacRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Google Developers Console [project ID or project
  /// number](https://support.google.com/cloud/answer/6158840).
  /// This field is deprecated, use name instead.
  public var projectID: String = String()

  /// The name of the Google Compute Engine
  /// [zone](/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field is deprecated, use name instead.
  public var zone: String = String()

  /// The name of the cluster to update.
  /// This field is deprecated, use name instead.
  public var clusterID: String = String()

  /// Whether ABAC authorization will be enabled in the cluster.
  public var enabled: Bool = false

  /// The name (project, location, cluster id) of the cluster to set legacy abac.
  /// Specified in the format 'projects/*/locations/*/clusters/*'.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// StartIPRotationRequest creates a new IP for the cluster and then performs
/// a node upgrade on each node pool to point to the new IP.
public struct Google_Container_V1alpha1_StartIPRotationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Google Developers Console [project ID or project
  /// number](https://developers.google.com/console/help/new/#projectnumber).
  /// This field is deprecated, use name instead.
  public var projectID: String = String()

  /// The name of the Google Compute Engine
  /// [zone](/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field is deprecated, use name instead.
  public var zone: String = String()

  /// The name of the cluster.
  /// This field is deprecated, use name instead.
  public var clusterID: String = String()

  /// The name (project, location, cluster id) of the cluster to start IP rotation.
  /// Specified in the format 'projects/*/locations/*/clusters/*'.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// CompleteIPRotationRequest moves the cluster master back into single-IP mode.
public struct Google_Container_V1alpha1_CompleteIPRotationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Google Developers Console [project ID or project
  /// number](https://developers.google.com/console/help/new/#projectnumber).
  /// This field is deprecated, use name instead.
  public var projectID: String = String()

  /// The name of the Google Compute Engine
  /// [zone](/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field is deprecated, use name instead.
  public var zone: String = String()

  /// The name of the cluster.
  /// This field is deprecated, use name instead.
  public var clusterID: String = String()

  /// The name (project, location, cluster id) of the cluster to complete IP rotation.
  /// Specified in the format 'projects/*/locations/*/clusters/*'.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// AcceleratorConfig represents a Hardware Accelerator request.
public struct Google_Container_V1alpha1_AcceleratorConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The number of the accelerator cards exposed to an instance.
  public var acceleratorCount: Int64 = 0

  /// The accelerator type resource name. List of supported accelerators
  /// [here](/compute/docs/gpus/#Introduction)
  public var acceleratorType: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// SetNetworkPolicyRequest enables/disables network policy for a cluster.
public struct Google_Container_V1alpha1_SetNetworkPolicyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Google Developers Console [project ID or project
  /// number](https://developers.google.com/console/help/new/#projectnumber).
  /// This field is deprecated, use name instead.
  public var projectID: String = String()

  /// The name of the Google Compute Engine
  /// [zone](/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field is deprecated, use name instead.
  public var zone: String = String()

  /// The name of the cluster.
  /// This field is deprecated, use name instead.
  public var clusterID: String = String()

  /// Configuration options for the NetworkPolicy feature.
  public var networkPolicy: Google_Container_V1alpha1_NetworkPolicy {
    get {return _networkPolicy ?? Google_Container_V1alpha1_NetworkPolicy()}
    set {_networkPolicy = newValue}
  }
  /// Returns true if `networkPolicy` has been explicitly set.
  public var hasNetworkPolicy: Bool {return self._networkPolicy != nil}
  /// Clears the value of `networkPolicy`. Subsequent reads from it will return its default value.
  public mutating func clearNetworkPolicy() {self._networkPolicy = nil}

  /// The name (project, location, cluster id) of the cluster to set networking
  /// policy.
  /// Specified in the format 'projects/*/locations/*/clusters/*'.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _networkPolicy: Google_Container_V1alpha1_NetworkPolicy? = nil
}

/// SetMaintenancePolicyRequest sets the maintenance policy for a cluster.
public struct Google_Container_V1alpha1_SetMaintenancePolicyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Google Developers Console [project ID or project
  /// number](https://support.google.com/cloud/answer/6158840).
  public var projectID: String = String()

  /// The name of the Google Compute Engine
  /// [zone](/compute/docs/zones#available) in which the cluster
  /// resides.
  public var zone: String = String()

  /// The name of the cluster to update.
  public var clusterID: String = String()

  /// The maintenance policy to be set for the cluster. An empty field
  /// clears the existing maintenance policy.
  public var maintenancePolicy: Google_Container_V1alpha1_MaintenancePolicy {
    get {return _maintenancePolicy ?? Google_Container_V1alpha1_MaintenancePolicy()}
    set {_maintenancePolicy = newValue}
  }
  /// Returns true if `maintenancePolicy` has been explicitly set.
  public var hasMaintenancePolicy: Bool {return self._maintenancePolicy != nil}
  /// Clears the value of `maintenancePolicy`. Subsequent reads from it will return its default value.
  public mutating func clearMaintenancePolicy() {self._maintenancePolicy = nil}

  /// The name (project, location, cluster id) of the cluster to set maintenance
  /// policy.
  /// Specified in the format 'projects/*/locations/*/clusters/*'.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _maintenancePolicy: Google_Container_V1alpha1_MaintenancePolicy? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.container.v1alpha1"

extension Google_Container_V1alpha1_NodeConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NodeConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "machine_type"),
    2: .standard(proto: "disk_size_gb"),
    3: .standard(proto: "oauth_scopes"),
    9: .standard(proto: "service_account"),
    4: .same(proto: "metadata"),
    5: .standard(proto: "image_type"),
    6: .same(proto: "labels"),
    7: .standard(proto: "local_ssd_count"),
    8: .same(proto: "tags"),
    10: .same(proto: "preemptible"),
    11: .same(proto: "accelerators"),
    13: .standard(proto: "min_cpu_platform"),
    15: .same(proto: "taints"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.machineType) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.diskSizeGb) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.oauthScopes) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.metadata) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.imageType) }()
      case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.localSsdCount) }()
      case 8: try { try decoder.decodeRepeatedStringField(value: &self.tags) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.serviceAccount) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.preemptible) }()
      case 11: try { try decoder.decodeRepeatedMessageField(value: &self.accelerators) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.minCpuPlatform) }()
      case 15: try { try decoder.decodeRepeatedMessageField(value: &self.taints) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.machineType.isEmpty {
      try visitor.visitSingularStringField(value: self.machineType, fieldNumber: 1)
    }
    if self.diskSizeGb != 0 {
      try visitor.visitSingularInt32Field(value: self.diskSizeGb, fieldNumber: 2)
    }
    if !self.oauthScopes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.oauthScopes, fieldNumber: 3)
    }
    if !self.metadata.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.metadata, fieldNumber: 4)
    }
    if !self.imageType.isEmpty {
      try visitor.visitSingularStringField(value: self.imageType, fieldNumber: 5)
    }
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 6)
    }
    if self.localSsdCount != 0 {
      try visitor.visitSingularInt32Field(value: self.localSsdCount, fieldNumber: 7)
    }
    if !self.tags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tags, fieldNumber: 8)
    }
    if !self.serviceAccount.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceAccount, fieldNumber: 9)
    }
    if self.preemptible != false {
      try visitor.visitSingularBoolField(value: self.preemptible, fieldNumber: 10)
    }
    if !self.accelerators.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accelerators, fieldNumber: 11)
    }
    if !self.minCpuPlatform.isEmpty {
      try visitor.visitSingularStringField(value: self.minCpuPlatform, fieldNumber: 13)
    }
    if !self.taints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.taints, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_NodeConfig, rhs: Google_Container_V1alpha1_NodeConfig) -> Bool {
    if lhs.machineType != rhs.machineType {return false}
    if lhs.diskSizeGb != rhs.diskSizeGb {return false}
    if lhs.oauthScopes != rhs.oauthScopes {return false}
    if lhs.serviceAccount != rhs.serviceAccount {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.imageType != rhs.imageType {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.localSsdCount != rhs.localSsdCount {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.preemptible != rhs.preemptible {return false}
    if lhs.accelerators != rhs.accelerators {return false}
    if lhs.minCpuPlatform != rhs.minCpuPlatform {return false}
    if lhs.taints != rhs.taints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_NodeTaint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NodeTaint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
    3: .same(proto: "effect"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.effect) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    if self.effect != .unspecified {
      try visitor.visitSingularEnumField(value: self.effect, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_NodeTaint, rhs: Google_Container_V1alpha1_NodeTaint) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.effect != rhs.effect {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_NodeTaint.Effect: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EFFECT_UNSPECIFIED"),
    1: .same(proto: "NO_SCHEDULE"),
    2: .same(proto: "PREFER_NO_SCHEDULE"),
    3: .same(proto: "NO_EXECUTE"),
  ]
}

extension Google_Container_V1alpha1_MasterAuth: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MasterAuth"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "username"),
    2: .same(proto: "password"),
    3: .standard(proto: "client_certificate_config"),
    100: .standard(proto: "cluster_ca_certificate"),
    101: .standard(proto: "client_certificate"),
    102: .standard(proto: "client_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._clientCertificateConfig) }()
      case 100: try { try decoder.decodeSingularStringField(value: &self.clusterCaCertificate) }()
      case 101: try { try decoder.decodeSingularStringField(value: &self.clientCertificate) }()
      case 102: try { try decoder.decodeSingularStringField(value: &self.clientKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    if let v = self._clientCertificateConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.clusterCaCertificate.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterCaCertificate, fieldNumber: 100)
    }
    if !self.clientCertificate.isEmpty {
      try visitor.visitSingularStringField(value: self.clientCertificate, fieldNumber: 101)
    }
    if !self.clientKey.isEmpty {
      try visitor.visitSingularStringField(value: self.clientKey, fieldNumber: 102)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_MasterAuth, rhs: Google_Container_V1alpha1_MasterAuth) -> Bool {
    if lhs.username != rhs.username {return false}
    if lhs.password != rhs.password {return false}
    if lhs._clientCertificateConfig != rhs._clientCertificateConfig {return false}
    if lhs.clusterCaCertificate != rhs.clusterCaCertificate {return false}
    if lhs.clientCertificate != rhs.clientCertificate {return false}
    if lhs.clientKey != rhs.clientKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_ClientCertificateConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientCertificateConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "issue_client_certificate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.issueClientCertificate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.issueClientCertificate != false {
      try visitor.visitSingularBoolField(value: self.issueClientCertificate, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_ClientCertificateConfig, rhs: Google_Container_V1alpha1_ClientCertificateConfig) -> Bool {
    if lhs.issueClientCertificate != rhs.issueClientCertificate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_AddonsConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddonsConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "http_load_balancing"),
    2: .standard(proto: "horizontal_pod_autoscaling"),
    3: .standard(proto: "kubernetes_dashboard"),
    4: .standard(proto: "network_policy_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._httpLoadBalancing) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._horizontalPodAutoscaling) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._kubernetesDashboard) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._networkPolicyConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._httpLoadBalancing {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._horizontalPodAutoscaling {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._kubernetesDashboard {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._networkPolicyConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_AddonsConfig, rhs: Google_Container_V1alpha1_AddonsConfig) -> Bool {
    if lhs._httpLoadBalancing != rhs._httpLoadBalancing {return false}
    if lhs._horizontalPodAutoscaling != rhs._horizontalPodAutoscaling {return false}
    if lhs._kubernetesDashboard != rhs._kubernetesDashboard {return false}
    if lhs._networkPolicyConfig != rhs._networkPolicyConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_HttpLoadBalancing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HttpLoadBalancing"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "disabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.disabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.disabled != false {
      try visitor.visitSingularBoolField(value: self.disabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_HttpLoadBalancing, rhs: Google_Container_V1alpha1_HttpLoadBalancing) -> Bool {
    if lhs.disabled != rhs.disabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_HorizontalPodAutoscaling: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HorizontalPodAutoscaling"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "disabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.disabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.disabled != false {
      try visitor.visitSingularBoolField(value: self.disabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_HorizontalPodAutoscaling, rhs: Google_Container_V1alpha1_HorizontalPodAutoscaling) -> Bool {
    if lhs.disabled != rhs.disabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_KubernetesDashboard: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KubernetesDashboard"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "disabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.disabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.disabled != false {
      try visitor.visitSingularBoolField(value: self.disabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_KubernetesDashboard, rhs: Google_Container_V1alpha1_KubernetesDashboard) -> Bool {
    if lhs.disabled != rhs.disabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_NetworkPolicyConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NetworkPolicyConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "disabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.disabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.disabled != false {
      try visitor.visitSingularBoolField(value: self.disabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_NetworkPolicyConfig, rhs: Google_Container_V1alpha1_NetworkPolicyConfig) -> Bool {
    if lhs.disabled != rhs.disabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_MasterAuthorizedNetworksConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MasterAuthorizedNetworksConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .standard(proto: "cidr_blocks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.cidrBlocks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if !self.cidrBlocks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cidrBlocks, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_MasterAuthorizedNetworksConfig, rhs: Google_Container_V1alpha1_MasterAuthorizedNetworksConfig) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.cidrBlocks != rhs.cidrBlocks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_MasterAuthorizedNetworksConfig.CidrBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Container_V1alpha1_MasterAuthorizedNetworksConfig.protoMessageName + ".CidrBlock"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "display_name"),
    2: .standard(proto: "cidr_block"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cidrBlock) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 1)
    }
    if !self.cidrBlock.isEmpty {
      try visitor.visitSingularStringField(value: self.cidrBlock, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_MasterAuthorizedNetworksConfig.CidrBlock, rhs: Google_Container_V1alpha1_MasterAuthorizedNetworksConfig.CidrBlock) -> Bool {
    if lhs.displayName != rhs.displayName {return false}
    if lhs.cidrBlock != rhs.cidrBlock {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_NetworkPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NetworkPolicy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "provider"),
    2: .same(proto: "enabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.provider) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.provider != .unspecified {
      try visitor.visitSingularEnumField(value: self.provider, fieldNumber: 1)
    }
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_NetworkPolicy, rhs: Google_Container_V1alpha1_NetworkPolicy) -> Bool {
    if lhs.provider != rhs.provider {return false}
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_NetworkPolicy.Provider: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PROVIDER_UNSPECIFIED"),
    1: .same(proto: "CALICO"),
  ]
}

extension Google_Container_V1alpha1_IPAllocationPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IPAllocationPolicy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "use_ip_aliases"),
    2: .standard(proto: "create_subnetwork"),
    3: .standard(proto: "subnetwork_name"),
    4: .standard(proto: "cluster_ipv4_cidr"),
    5: .standard(proto: "node_ipv4_cidr"),
    6: .standard(proto: "services_ipv4_cidr"),
    7: .standard(proto: "cluster_secondary_range_name"),
    8: .standard(proto: "services_secondary_range_name"),
    9: .standard(proto: "cluster_ipv4_cidr_block"),
    10: .standard(proto: "node_ipv4_cidr_block"),
    11: .standard(proto: "services_ipv4_cidr_block"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.useIpAliases) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.createSubnetwork) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.subnetworkName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.clusterIpv4Cidr) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.nodeIpv4Cidr) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.servicesIpv4Cidr) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.clusterSecondaryRangeName) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.servicesSecondaryRangeName) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.clusterIpv4CidrBlock) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.nodeIpv4CidrBlock) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.servicesIpv4CidrBlock) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.useIpAliases != false {
      try visitor.visitSingularBoolField(value: self.useIpAliases, fieldNumber: 1)
    }
    if self.createSubnetwork != false {
      try visitor.visitSingularBoolField(value: self.createSubnetwork, fieldNumber: 2)
    }
    if !self.subnetworkName.isEmpty {
      try visitor.visitSingularStringField(value: self.subnetworkName, fieldNumber: 3)
    }
    if !self.clusterIpv4Cidr.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterIpv4Cidr, fieldNumber: 4)
    }
    if !self.nodeIpv4Cidr.isEmpty {
      try visitor.visitSingularStringField(value: self.nodeIpv4Cidr, fieldNumber: 5)
    }
    if !self.servicesIpv4Cidr.isEmpty {
      try visitor.visitSingularStringField(value: self.servicesIpv4Cidr, fieldNumber: 6)
    }
    if !self.clusterSecondaryRangeName.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterSecondaryRangeName, fieldNumber: 7)
    }
    if !self.servicesSecondaryRangeName.isEmpty {
      try visitor.visitSingularStringField(value: self.servicesSecondaryRangeName, fieldNumber: 8)
    }
    if !self.clusterIpv4CidrBlock.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterIpv4CidrBlock, fieldNumber: 9)
    }
    if !self.nodeIpv4CidrBlock.isEmpty {
      try visitor.visitSingularStringField(value: self.nodeIpv4CidrBlock, fieldNumber: 10)
    }
    if !self.servicesIpv4CidrBlock.isEmpty {
      try visitor.visitSingularStringField(value: self.servicesIpv4CidrBlock, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_IPAllocationPolicy, rhs: Google_Container_V1alpha1_IPAllocationPolicy) -> Bool {
    if lhs.useIpAliases != rhs.useIpAliases {return false}
    if lhs.createSubnetwork != rhs.createSubnetwork {return false}
    if lhs.subnetworkName != rhs.subnetworkName {return false}
    if lhs.clusterIpv4Cidr != rhs.clusterIpv4Cidr {return false}
    if lhs.nodeIpv4Cidr != rhs.nodeIpv4Cidr {return false}
    if lhs.servicesIpv4Cidr != rhs.servicesIpv4Cidr {return false}
    if lhs.clusterSecondaryRangeName != rhs.clusterSecondaryRangeName {return false}
    if lhs.servicesSecondaryRangeName != rhs.servicesSecondaryRangeName {return false}
    if lhs.clusterIpv4CidrBlock != rhs.clusterIpv4CidrBlock {return false}
    if lhs.nodeIpv4CidrBlock != rhs.nodeIpv4CidrBlock {return false}
    if lhs.servicesIpv4CidrBlock != rhs.servicesIpv4CidrBlock {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_PodSecurityPolicyConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PodSecurityPolicyConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_PodSecurityPolicyConfig, rhs: Google_Container_V1alpha1_PodSecurityPolicyConfig) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_Cluster: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Cluster"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "description"),
    3: .standard(proto: "initial_node_count"),
    4: .standard(proto: "node_config"),
    5: .standard(proto: "master_auth"),
    6: .standard(proto: "logging_service"),
    7: .standard(proto: "monitoring_service"),
    8: .same(proto: "network"),
    9: .standard(proto: "cluster_ipv4_cidr"),
    10: .standard(proto: "addons_config"),
    11: .same(proto: "subnetwork"),
    12: .standard(proto: "node_pools"),
    13: .same(proto: "locations"),
    14: .standard(proto: "enable_kubernetes_alpha"),
    19: .standard(proto: "network_policy"),
    20: .standard(proto: "ip_allocation_policy"),
    22: .standard(proto: "master_authorized_networks_config"),
    23: .standard(proto: "maintenance_policy"),
    25: .standard(proto: "pod_security_policy_config"),
    100: .standard(proto: "self_link"),
    101: .same(proto: "zone"),
    102: .same(proto: "endpoint"),
    103: .standard(proto: "initial_cluster_version"),
    104: .standard(proto: "current_master_version"),
    105: .standard(proto: "current_node_version"),
    106: .standard(proto: "create_time"),
    107: .same(proto: "status"),
    108: .standard(proto: "status_message"),
    109: .standard(proto: "node_ipv4_cidr_size"),
    110: .standard(proto: "services_ipv4_cidr"),
    111: .standard(proto: "instance_group_urls"),
    112: .standard(proto: "current_node_count"),
    113: .standard(proto: "expire_time"),
    114: .same(proto: "location"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _description_p: String = String()
    var _initialNodeCount: Int32 = 0
    var _nodeConfig: Google_Container_V1alpha1_NodeConfig? = nil
    var _masterAuth: Google_Container_V1alpha1_MasterAuth? = nil
    var _loggingService: String = String()
    var _monitoringService: String = String()
    var _network: String = String()
    var _clusterIpv4Cidr: String = String()
    var _addonsConfig: Google_Container_V1alpha1_AddonsConfig? = nil
    var _subnetwork: String = String()
    var _nodePools: [Google_Container_V1alpha1_NodePool] = []
    var _locations: [String] = []
    var _enableKubernetesAlpha: Bool = false
    var _networkPolicy: Google_Container_V1alpha1_NetworkPolicy? = nil
    var _ipAllocationPolicy: Google_Container_V1alpha1_IPAllocationPolicy? = nil
    var _masterAuthorizedNetworksConfig: Google_Container_V1alpha1_MasterAuthorizedNetworksConfig? = nil
    var _maintenancePolicy: Google_Container_V1alpha1_MaintenancePolicy? = nil
    var _podSecurityPolicyConfig: Google_Container_V1alpha1_PodSecurityPolicyConfig? = nil
    var _selfLink: String = String()
    var _zone: String = String()
    var _endpoint: String = String()
    var _initialClusterVersion: String = String()
    var _currentMasterVersion: String = String()
    var _currentNodeVersion: String = String()
    var _createTime: String = String()
    var _status: Google_Container_V1alpha1_Cluster.Status = .unspecified
    var _statusMessage: String = String()
    var _nodeIpv4CidrSize: Int32 = 0
    var _servicesIpv4Cidr: String = String()
    var _instanceGroupUrls: [String] = []
    var _currentNodeCount: Int32 = 0
    var _expireTime: String = String()
    var _location: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _description_p = source._description_p
      _initialNodeCount = source._initialNodeCount
      _nodeConfig = source._nodeConfig
      _masterAuth = source._masterAuth
      _loggingService = source._loggingService
      _monitoringService = source._monitoringService
      _network = source._network
      _clusterIpv4Cidr = source._clusterIpv4Cidr
      _addonsConfig = source._addonsConfig
      _subnetwork = source._subnetwork
      _nodePools = source._nodePools
      _locations = source._locations
      _enableKubernetesAlpha = source._enableKubernetesAlpha
      _networkPolicy = source._networkPolicy
      _ipAllocationPolicy = source._ipAllocationPolicy
      _masterAuthorizedNetworksConfig = source._masterAuthorizedNetworksConfig
      _maintenancePolicy = source._maintenancePolicy
      _podSecurityPolicyConfig = source._podSecurityPolicyConfig
      _selfLink = source._selfLink
      _zone = source._zone
      _endpoint = source._endpoint
      _initialClusterVersion = source._initialClusterVersion
      _currentMasterVersion = source._currentMasterVersion
      _currentNodeVersion = source._currentNodeVersion
      _createTime = source._createTime
      _status = source._status
      _statusMessage = source._statusMessage
      _nodeIpv4CidrSize = source._nodeIpv4CidrSize
      _servicesIpv4Cidr = source._servicesIpv4Cidr
      _instanceGroupUrls = source._instanceGroupUrls
      _currentNodeCount = source._currentNodeCount
      _expireTime = source._expireTime
      _location = source._location
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._initialNodeCount) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._nodeConfig) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._masterAuth) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._loggingService) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._monitoringService) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._network) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._clusterIpv4Cidr) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._addonsConfig) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._subnetwork) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._nodePools) }()
        case 13: try { try decoder.decodeRepeatedStringField(value: &_storage._locations) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._enableKubernetesAlpha) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._networkPolicy) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._ipAllocationPolicy) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._masterAuthorizedNetworksConfig) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._maintenancePolicy) }()
        case 25: try { try decoder.decodeSingularMessageField(value: &_storage._podSecurityPolicyConfig) }()
        case 100: try { try decoder.decodeSingularStringField(value: &_storage._selfLink) }()
        case 101: try { try decoder.decodeSingularStringField(value: &_storage._zone) }()
        case 102: try { try decoder.decodeSingularStringField(value: &_storage._endpoint) }()
        case 103: try { try decoder.decodeSingularStringField(value: &_storage._initialClusterVersion) }()
        case 104: try { try decoder.decodeSingularStringField(value: &_storage._currentMasterVersion) }()
        case 105: try { try decoder.decodeSingularStringField(value: &_storage._currentNodeVersion) }()
        case 106: try { try decoder.decodeSingularStringField(value: &_storage._createTime) }()
        case 107: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        case 108: try { try decoder.decodeSingularStringField(value: &_storage._statusMessage) }()
        case 109: try { try decoder.decodeSingularInt32Field(value: &_storage._nodeIpv4CidrSize) }()
        case 110: try { try decoder.decodeSingularStringField(value: &_storage._servicesIpv4Cidr) }()
        case 111: try { try decoder.decodeRepeatedStringField(value: &_storage._instanceGroupUrls) }()
        case 112: try { try decoder.decodeSingularInt32Field(value: &_storage._currentNodeCount) }()
        case 113: try { try decoder.decodeSingularStringField(value: &_storage._expireTime) }()
        case 114: try { try decoder.decodeSingularStringField(value: &_storage._location) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 2)
      }
      if _storage._initialNodeCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._initialNodeCount, fieldNumber: 3)
      }
      if let v = _storage._nodeConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._masterAuth {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if !_storage._loggingService.isEmpty {
        try visitor.visitSingularStringField(value: _storage._loggingService, fieldNumber: 6)
      }
      if !_storage._monitoringService.isEmpty {
        try visitor.visitSingularStringField(value: _storage._monitoringService, fieldNumber: 7)
      }
      if !_storage._network.isEmpty {
        try visitor.visitSingularStringField(value: _storage._network, fieldNumber: 8)
      }
      if !_storage._clusterIpv4Cidr.isEmpty {
        try visitor.visitSingularStringField(value: _storage._clusterIpv4Cidr, fieldNumber: 9)
      }
      if let v = _storage._addonsConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if !_storage._subnetwork.isEmpty {
        try visitor.visitSingularStringField(value: _storage._subnetwork, fieldNumber: 11)
      }
      if !_storage._nodePools.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._nodePools, fieldNumber: 12)
      }
      if !_storage._locations.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._locations, fieldNumber: 13)
      }
      if _storage._enableKubernetesAlpha != false {
        try visitor.visitSingularBoolField(value: _storage._enableKubernetesAlpha, fieldNumber: 14)
      }
      if let v = _storage._networkPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }
      if let v = _storage._ipAllocationPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }
      if let v = _storage._masterAuthorizedNetworksConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      }
      if let v = _storage._maintenancePolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      }
      if let v = _storage._podSecurityPolicyConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      }
      if !_storage._selfLink.isEmpty {
        try visitor.visitSingularStringField(value: _storage._selfLink, fieldNumber: 100)
      }
      if !_storage._zone.isEmpty {
        try visitor.visitSingularStringField(value: _storage._zone, fieldNumber: 101)
      }
      if !_storage._endpoint.isEmpty {
        try visitor.visitSingularStringField(value: _storage._endpoint, fieldNumber: 102)
      }
      if !_storage._initialClusterVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._initialClusterVersion, fieldNumber: 103)
      }
      if !_storage._currentMasterVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._currentMasterVersion, fieldNumber: 104)
      }
      if !_storage._currentNodeVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._currentNodeVersion, fieldNumber: 105)
      }
      if !_storage._createTime.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createTime, fieldNumber: 106)
      }
      if _storage._status != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 107)
      }
      if !_storage._statusMessage.isEmpty {
        try visitor.visitSingularStringField(value: _storage._statusMessage, fieldNumber: 108)
      }
      if _storage._nodeIpv4CidrSize != 0 {
        try visitor.visitSingularInt32Field(value: _storage._nodeIpv4CidrSize, fieldNumber: 109)
      }
      if !_storage._servicesIpv4Cidr.isEmpty {
        try visitor.visitSingularStringField(value: _storage._servicesIpv4Cidr, fieldNumber: 110)
      }
      if !_storage._instanceGroupUrls.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._instanceGroupUrls, fieldNumber: 111)
      }
      if _storage._currentNodeCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._currentNodeCount, fieldNumber: 112)
      }
      if !_storage._expireTime.isEmpty {
        try visitor.visitSingularStringField(value: _storage._expireTime, fieldNumber: 113)
      }
      if !_storage._location.isEmpty {
        try visitor.visitSingularStringField(value: _storage._location, fieldNumber: 114)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_Cluster, rhs: Google_Container_V1alpha1_Cluster) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._initialNodeCount != rhs_storage._initialNodeCount {return false}
        if _storage._nodeConfig != rhs_storage._nodeConfig {return false}
        if _storage._masterAuth != rhs_storage._masterAuth {return false}
        if _storage._loggingService != rhs_storage._loggingService {return false}
        if _storage._monitoringService != rhs_storage._monitoringService {return false}
        if _storage._network != rhs_storage._network {return false}
        if _storage._clusterIpv4Cidr != rhs_storage._clusterIpv4Cidr {return false}
        if _storage._addonsConfig != rhs_storage._addonsConfig {return false}
        if _storage._subnetwork != rhs_storage._subnetwork {return false}
        if _storage._nodePools != rhs_storage._nodePools {return false}
        if _storage._locations != rhs_storage._locations {return false}
        if _storage._enableKubernetesAlpha != rhs_storage._enableKubernetesAlpha {return false}
        if _storage._networkPolicy != rhs_storage._networkPolicy {return false}
        if _storage._ipAllocationPolicy != rhs_storage._ipAllocationPolicy {return false}
        if _storage._masterAuthorizedNetworksConfig != rhs_storage._masterAuthorizedNetworksConfig {return false}
        if _storage._maintenancePolicy != rhs_storage._maintenancePolicy {return false}
        if _storage._podSecurityPolicyConfig != rhs_storage._podSecurityPolicyConfig {return false}
        if _storage._selfLink != rhs_storage._selfLink {return false}
        if _storage._zone != rhs_storage._zone {return false}
        if _storage._endpoint != rhs_storage._endpoint {return false}
        if _storage._initialClusterVersion != rhs_storage._initialClusterVersion {return false}
        if _storage._currentMasterVersion != rhs_storage._currentMasterVersion {return false}
        if _storage._currentNodeVersion != rhs_storage._currentNodeVersion {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._statusMessage != rhs_storage._statusMessage {return false}
        if _storage._nodeIpv4CidrSize != rhs_storage._nodeIpv4CidrSize {return false}
        if _storage._servicesIpv4Cidr != rhs_storage._servicesIpv4Cidr {return false}
        if _storage._instanceGroupUrls != rhs_storage._instanceGroupUrls {return false}
        if _storage._currentNodeCount != rhs_storage._currentNodeCount {return false}
        if _storage._expireTime != rhs_storage._expireTime {return false}
        if _storage._location != rhs_storage._location {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_Cluster.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNSPECIFIED"),
    1: .same(proto: "PROVISIONING"),
    2: .same(proto: "RUNNING"),
    3: .same(proto: "RECONCILING"),
    4: .same(proto: "STOPPING"),
    5: .same(proto: "ERROR"),
  ]
}

extension Google_Container_V1alpha1_ClusterUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClusterUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .standard(proto: "desired_node_version"),
    5: .standard(proto: "desired_monitoring_service"),
    6: .standard(proto: "desired_addons_config"),
    7: .standard(proto: "desired_node_pool_id"),
    8: .standard(proto: "desired_image_type"),
    9: .standard(proto: "desired_node_pool_autoscaling"),
    10: .standard(proto: "desired_locations"),
    12: .standard(proto: "desired_master_authorized_networks_config"),
    14: .standard(proto: "desired_pod_security_policy_config"),
    100: .standard(proto: "desired_master_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 4: try { try decoder.decodeSingularStringField(value: &self.desiredNodeVersion) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.desiredMonitoringService) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._desiredAddonsConfig) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.desiredNodePoolID) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.desiredImageType) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._desiredNodePoolAutoscaling) }()
      case 10: try { try decoder.decodeRepeatedStringField(value: &self.desiredLocations) }()
      case 12: try { try decoder.decodeSingularMessageField(value: &self._desiredMasterAuthorizedNetworksConfig) }()
      case 14: try { try decoder.decodeSingularMessageField(value: &self._desiredPodSecurityPolicyConfig) }()
      case 100: try { try decoder.decodeSingularStringField(value: &self.desiredMasterVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.desiredNodeVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.desiredNodeVersion, fieldNumber: 4)
    }
    if !self.desiredMonitoringService.isEmpty {
      try visitor.visitSingularStringField(value: self.desiredMonitoringService, fieldNumber: 5)
    }
    if let v = self._desiredAddonsConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if !self.desiredNodePoolID.isEmpty {
      try visitor.visitSingularStringField(value: self.desiredNodePoolID, fieldNumber: 7)
    }
    if !self.desiredImageType.isEmpty {
      try visitor.visitSingularStringField(value: self.desiredImageType, fieldNumber: 8)
    }
    if let v = self._desiredNodePoolAutoscaling {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    if !self.desiredLocations.isEmpty {
      try visitor.visitRepeatedStringField(value: self.desiredLocations, fieldNumber: 10)
    }
    if let v = self._desiredMasterAuthorizedNetworksConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }
    if let v = self._desiredPodSecurityPolicyConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }
    if !self.desiredMasterVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.desiredMasterVersion, fieldNumber: 100)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_ClusterUpdate, rhs: Google_Container_V1alpha1_ClusterUpdate) -> Bool {
    if lhs.desiredNodeVersion != rhs.desiredNodeVersion {return false}
    if lhs.desiredMonitoringService != rhs.desiredMonitoringService {return false}
    if lhs._desiredAddonsConfig != rhs._desiredAddonsConfig {return false}
    if lhs.desiredNodePoolID != rhs.desiredNodePoolID {return false}
    if lhs.desiredImageType != rhs.desiredImageType {return false}
    if lhs._desiredNodePoolAutoscaling != rhs._desiredNodePoolAutoscaling {return false}
    if lhs.desiredLocations != rhs.desiredLocations {return false}
    if lhs._desiredMasterAuthorizedNetworksConfig != rhs._desiredMasterAuthorizedNetworksConfig {return false}
    if lhs._desiredPodSecurityPolicyConfig != rhs._desiredPodSecurityPolicyConfig {return false}
    if lhs.desiredMasterVersion != rhs.desiredMasterVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_Operation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Operation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "zone"),
    3: .standard(proto: "operation_type"),
    4: .same(proto: "status"),
    8: .same(proto: "detail"),
    5: .standard(proto: "status_message"),
    6: .standard(proto: "self_link"),
    7: .standard(proto: "target_link"),
    9: .same(proto: "location"),
    10: .standard(proto: "start_time"),
    11: .standard(proto: "end_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.operationType) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.statusMessage) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.selfLink) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.targetLink) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.detail) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.location) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.startTime) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.endTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if self.operationType != .unspecified {
      try visitor.visitSingularEnumField(value: self.operationType, fieldNumber: 3)
    }
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 4)
    }
    if !self.statusMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.statusMessage, fieldNumber: 5)
    }
    if !self.selfLink.isEmpty {
      try visitor.visitSingularStringField(value: self.selfLink, fieldNumber: 6)
    }
    if !self.targetLink.isEmpty {
      try visitor.visitSingularStringField(value: self.targetLink, fieldNumber: 7)
    }
    if !self.detail.isEmpty {
      try visitor.visitSingularStringField(value: self.detail, fieldNumber: 8)
    }
    if !self.location.isEmpty {
      try visitor.visitSingularStringField(value: self.location, fieldNumber: 9)
    }
    if !self.startTime.isEmpty {
      try visitor.visitSingularStringField(value: self.startTime, fieldNumber: 10)
    }
    if !self.endTime.isEmpty {
      try visitor.visitSingularStringField(value: self.endTime, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_Operation, rhs: Google_Container_V1alpha1_Operation) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.operationType != rhs.operationType {return false}
    if lhs.status != rhs.status {return false}
    if lhs.detail != rhs.detail {return false}
    if lhs.statusMessage != rhs.statusMessage {return false}
    if lhs.selfLink != rhs.selfLink {return false}
    if lhs.targetLink != rhs.targetLink {return false}
    if lhs.location != rhs.location {return false}
    if lhs.startTime != rhs.startTime {return false}
    if lhs.endTime != rhs.endTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_Operation.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNSPECIFIED"),
    1: .same(proto: "PENDING"),
    2: .same(proto: "RUNNING"),
    3: .same(proto: "DONE"),
    4: .same(proto: "ABORTING"),
  ]
}

extension Google_Container_V1alpha1_Operation.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNSPECIFIED"),
    1: .same(proto: "CREATE_CLUSTER"),
    2: .same(proto: "DELETE_CLUSTER"),
    3: .same(proto: "UPGRADE_MASTER"),
    4: .same(proto: "UPGRADE_NODES"),
    5: .same(proto: "REPAIR_CLUSTER"),
    6: .same(proto: "UPDATE_CLUSTER"),
    7: .same(proto: "CREATE_NODE_POOL"),
    8: .same(proto: "DELETE_NODE_POOL"),
    9: .same(proto: "SET_NODE_POOL_MANAGEMENT"),
    10: .same(proto: "AUTO_REPAIR_NODES"),
    11: .same(proto: "AUTO_UPGRADE_NODES"),
    12: .same(proto: "SET_LABELS"),
    13: .same(proto: "SET_MASTER_AUTH"),
    14: .same(proto: "SET_NODE_POOL_SIZE"),
    15: .same(proto: "SET_NETWORK_POLICY"),
    16: .same(proto: "SET_MAINTENANCE_POLICY"),
  ]
}

extension Google_Container_V1alpha1_CreateClusterRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateClusterRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .same(proto: "cluster"),
    5: .same(proto: "parent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._cluster) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if let v = self._cluster {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_CreateClusterRequest, rhs: Google_Container_V1alpha1_CreateClusterRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs._cluster != rhs._cluster {return false}
    if lhs.parent != rhs.parent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_GetClusterRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetClusterRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    5: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_GetClusterRequest, rhs: Google_Container_V1alpha1_GetClusterRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_UpdateClusterRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateClusterRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    4: .same(proto: "update"),
    5: .same(proto: "name"),
  ]

  fileprivate class _StorageClass {
    var _projectID: String = String()
    var _zone: String = String()
    var _clusterID: String = String()
    var _update: Google_Container_V1alpha1_ClusterUpdate? = nil
    var _name: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _projectID = source._projectID
      _zone = source._zone
      _clusterID = source._clusterID
      _update = source._update
      _name = source._name
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._projectID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._zone) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._clusterID) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._update) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._projectID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._projectID, fieldNumber: 1)
      }
      if !_storage._zone.isEmpty {
        try visitor.visitSingularStringField(value: _storage._zone, fieldNumber: 2)
      }
      if !_storage._clusterID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._clusterID, fieldNumber: 3)
      }
      if let v = _storage._update {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_UpdateClusterRequest, rhs: Google_Container_V1alpha1_UpdateClusterRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._projectID != rhs_storage._projectID {return false}
        if _storage._zone != rhs_storage._zone {return false}
        if _storage._clusterID != rhs_storage._clusterID {return false}
        if _storage._update != rhs_storage._update {return false}
        if _storage._name != rhs_storage._name {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_UpdateNodePoolRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateNodePoolRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    4: .standard(proto: "node_pool_id"),
    5: .standard(proto: "node_version"),
    6: .standard(proto: "image_type"),
    8: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.nodePoolID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.nodeVersion) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.imageType) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if !self.nodePoolID.isEmpty {
      try visitor.visitSingularStringField(value: self.nodePoolID, fieldNumber: 4)
    }
    if !self.nodeVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.nodeVersion, fieldNumber: 5)
    }
    if !self.imageType.isEmpty {
      try visitor.visitSingularStringField(value: self.imageType, fieldNumber: 6)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_UpdateNodePoolRequest, rhs: Google_Container_V1alpha1_UpdateNodePoolRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs.nodePoolID != rhs.nodePoolID {return false}
    if lhs.nodeVersion != rhs.nodeVersion {return false}
    if lhs.imageType != rhs.imageType {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_SetNodePoolAutoscalingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetNodePoolAutoscalingRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    4: .standard(proto: "node_pool_id"),
    5: .same(proto: "autoscaling"),
    6: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.nodePoolID) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._autoscaling) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if !self.nodePoolID.isEmpty {
      try visitor.visitSingularStringField(value: self.nodePoolID, fieldNumber: 4)
    }
    if let v = self._autoscaling {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_SetNodePoolAutoscalingRequest, rhs: Google_Container_V1alpha1_SetNodePoolAutoscalingRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs.nodePoolID != rhs.nodePoolID {return false}
    if lhs._autoscaling != rhs._autoscaling {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_SetLoggingServiceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetLoggingServiceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    4: .standard(proto: "logging_service"),
    5: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.loggingService) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if !self.loggingService.isEmpty {
      try visitor.visitSingularStringField(value: self.loggingService, fieldNumber: 4)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_SetLoggingServiceRequest, rhs: Google_Container_V1alpha1_SetLoggingServiceRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs.loggingService != rhs.loggingService {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_SetMonitoringServiceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetMonitoringServiceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    4: .standard(proto: "monitoring_service"),
    6: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.monitoringService) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if !self.monitoringService.isEmpty {
      try visitor.visitSingularStringField(value: self.monitoringService, fieldNumber: 4)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_SetMonitoringServiceRequest, rhs: Google_Container_V1alpha1_SetMonitoringServiceRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs.monitoringService != rhs.monitoringService {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_SetAddonsConfigRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetAddonsConfigRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    4: .standard(proto: "addons_config"),
    6: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._addonsConfig) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if let v = self._addonsConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_SetAddonsConfigRequest, rhs: Google_Container_V1alpha1_SetAddonsConfigRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs._addonsConfig != rhs._addonsConfig {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_SetLocationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetLocationsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    4: .same(proto: "locations"),
    6: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.locations) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if !self.locations.isEmpty {
      try visitor.visitRepeatedStringField(value: self.locations, fieldNumber: 4)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_SetLocationsRequest, rhs: Google_Container_V1alpha1_SetLocationsRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs.locations != rhs.locations {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_UpdateMasterRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateMasterRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    4: .standard(proto: "master_version"),
    7: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.masterVersion) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if !self.masterVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.masterVersion, fieldNumber: 4)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_UpdateMasterRequest, rhs: Google_Container_V1alpha1_UpdateMasterRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs.masterVersion != rhs.masterVersion {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_SetMasterAuthRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetMasterAuthRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    4: .same(proto: "action"),
    5: .same(proto: "update"),
    7: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._update) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if self.action != .unknown {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 4)
    }
    if let v = self._update {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_SetMasterAuthRequest, rhs: Google_Container_V1alpha1_SetMasterAuthRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs.action != rhs.action {return false}
    if lhs._update != rhs._update {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_SetMasterAuthRequest.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "SET_PASSWORD"),
    2: .same(proto: "GENERATE_PASSWORD"),
    3: .same(proto: "SET_USERNAME"),
  ]
}

extension Google_Container_V1alpha1_DeleteClusterRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteClusterRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    4: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_DeleteClusterRequest, rhs: Google_Container_V1alpha1_DeleteClusterRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_ListClustersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListClustersRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    4: .same(proto: "parent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_ListClustersRequest, rhs: Google_Container_V1alpha1_ListClustersRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.parent != rhs.parent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_ListClustersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListClustersResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clusters"),
    2: .standard(proto: "missing_zones"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.clusters) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.missingZones) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.clusters, fieldNumber: 1)
    }
    if !self.missingZones.isEmpty {
      try visitor.visitRepeatedStringField(value: self.missingZones, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_ListClustersResponse, rhs: Google_Container_V1alpha1_ListClustersResponse) -> Bool {
    if lhs.clusters != rhs.clusters {return false}
    if lhs.missingZones != rhs.missingZones {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_GetOperationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetOperationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "operation_id"),
    5: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.operationID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.operationID.isEmpty {
      try visitor.visitSingularStringField(value: self.operationID, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_GetOperationRequest, rhs: Google_Container_V1alpha1_GetOperationRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.operationID != rhs.operationID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_ListOperationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListOperationsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    4: .same(proto: "parent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_ListOperationsRequest, rhs: Google_Container_V1alpha1_ListOperationsRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.parent != rhs.parent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_CancelOperationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CancelOperationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "operation_id"),
    4: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.operationID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.operationID.isEmpty {
      try visitor.visitSingularStringField(value: self.operationID, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_CancelOperationRequest, rhs: Google_Container_V1alpha1_CancelOperationRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.operationID != rhs.operationID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_ListOperationsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListOperationsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operations"),
    2: .standard(proto: "missing_zones"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.operations) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.missingZones) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.operations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.operations, fieldNumber: 1)
    }
    if !self.missingZones.isEmpty {
      try visitor.visitRepeatedStringField(value: self.missingZones, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_ListOperationsResponse, rhs: Google_Container_V1alpha1_ListOperationsResponse) -> Bool {
    if lhs.operations != rhs.operations {return false}
    if lhs.missingZones != rhs.missingZones {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_GetServerConfigRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetServerConfigRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    4: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_GetServerConfigRequest, rhs: Google_Container_V1alpha1_GetServerConfigRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_ServerConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServerConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "default_cluster_version"),
    3: .standard(proto: "valid_node_versions"),
    4: .standard(proto: "default_image_type"),
    5: .standard(proto: "valid_image_types"),
    6: .standard(proto: "valid_master_versions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.defaultClusterVersion) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.validNodeVersions) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.defaultImageType) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.validImageTypes) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.validMasterVersions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.defaultClusterVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.defaultClusterVersion, fieldNumber: 1)
    }
    if !self.validNodeVersions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.validNodeVersions, fieldNumber: 3)
    }
    if !self.defaultImageType.isEmpty {
      try visitor.visitSingularStringField(value: self.defaultImageType, fieldNumber: 4)
    }
    if !self.validImageTypes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.validImageTypes, fieldNumber: 5)
    }
    if !self.validMasterVersions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.validMasterVersions, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_ServerConfig, rhs: Google_Container_V1alpha1_ServerConfig) -> Bool {
    if lhs.defaultClusterVersion != rhs.defaultClusterVersion {return false}
    if lhs.validNodeVersions != rhs.validNodeVersions {return false}
    if lhs.defaultImageType != rhs.defaultImageType {return false}
    if lhs.validImageTypes != rhs.validImageTypes {return false}
    if lhs.validMasterVersions != rhs.validMasterVersions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_CreateNodePoolRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateNodePoolRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    4: .standard(proto: "node_pool"),
    6: .same(proto: "parent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._nodePool) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if let v = self._nodePool {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_CreateNodePoolRequest, rhs: Google_Container_V1alpha1_CreateNodePoolRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs._nodePool != rhs._nodePool {return false}
    if lhs.parent != rhs.parent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_DeleteNodePoolRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteNodePoolRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    4: .standard(proto: "node_pool_id"),
    6: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.nodePoolID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if !self.nodePoolID.isEmpty {
      try visitor.visitSingularStringField(value: self.nodePoolID, fieldNumber: 4)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_DeleteNodePoolRequest, rhs: Google_Container_V1alpha1_DeleteNodePoolRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs.nodePoolID != rhs.nodePoolID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_ListNodePoolsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListNodePoolsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    5: .same(proto: "parent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_ListNodePoolsRequest, rhs: Google_Container_V1alpha1_ListNodePoolsRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs.parent != rhs.parent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_GetNodePoolRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNodePoolRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    4: .standard(proto: "node_pool_id"),
    6: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.nodePoolID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if !self.nodePoolID.isEmpty {
      try visitor.visitSingularStringField(value: self.nodePoolID, fieldNumber: 4)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_GetNodePoolRequest, rhs: Google_Container_V1alpha1_GetNodePoolRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs.nodePoolID != rhs.nodePoolID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_NodePool: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NodePool"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "config"),
    3: .standard(proto: "initial_node_count"),
    4: .same(proto: "autoscaling"),
    5: .same(proto: "management"),
    100: .standard(proto: "self_link"),
    101: .same(proto: "version"),
    102: .standard(proto: "instance_group_urls"),
    103: .same(proto: "status"),
    104: .standard(proto: "status_message"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _config: Google_Container_V1alpha1_NodeConfig? = nil
    var _initialNodeCount: Int32 = 0
    var _autoscaling: Google_Container_V1alpha1_NodePoolAutoscaling? = nil
    var _management: Google_Container_V1alpha1_NodeManagement? = nil
    var _selfLink: String = String()
    var _version: String = String()
    var _instanceGroupUrls: [String] = []
    var _status: Google_Container_V1alpha1_NodePool.Status = .unspecified
    var _statusMessage: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _config = source._config
      _initialNodeCount = source._initialNodeCount
      _autoscaling = source._autoscaling
      _management = source._management
      _selfLink = source._selfLink
      _version = source._version
      _instanceGroupUrls = source._instanceGroupUrls
      _status = source._status
      _statusMessage = source._statusMessage
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._config) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._initialNodeCount) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._autoscaling) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._management) }()
        case 100: try { try decoder.decodeSingularStringField(value: &_storage._selfLink) }()
        case 101: try { try decoder.decodeSingularStringField(value: &_storage._version) }()
        case 102: try { try decoder.decodeRepeatedStringField(value: &_storage._instanceGroupUrls) }()
        case 103: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        case 104: try { try decoder.decodeSingularStringField(value: &_storage._statusMessage) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if let v = _storage._config {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if _storage._initialNodeCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._initialNodeCount, fieldNumber: 3)
      }
      if let v = _storage._autoscaling {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._management {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if !_storage._selfLink.isEmpty {
        try visitor.visitSingularStringField(value: _storage._selfLink, fieldNumber: 100)
      }
      if !_storage._version.isEmpty {
        try visitor.visitSingularStringField(value: _storage._version, fieldNumber: 101)
      }
      if !_storage._instanceGroupUrls.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._instanceGroupUrls, fieldNumber: 102)
      }
      if _storage._status != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 103)
      }
      if !_storage._statusMessage.isEmpty {
        try visitor.visitSingularStringField(value: _storage._statusMessage, fieldNumber: 104)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_NodePool, rhs: Google_Container_V1alpha1_NodePool) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._config != rhs_storage._config {return false}
        if _storage._initialNodeCount != rhs_storage._initialNodeCount {return false}
        if _storage._autoscaling != rhs_storage._autoscaling {return false}
        if _storage._management != rhs_storage._management {return false}
        if _storage._selfLink != rhs_storage._selfLink {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._instanceGroupUrls != rhs_storage._instanceGroupUrls {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._statusMessage != rhs_storage._statusMessage {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_NodePool.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNSPECIFIED"),
    1: .same(proto: "PROVISIONING"),
    2: .same(proto: "RUNNING"),
    3: .same(proto: "RUNNING_WITH_ERROR"),
    4: .same(proto: "RECONCILING"),
    5: .same(proto: "STOPPING"),
    6: .same(proto: "ERROR"),
  ]
}

extension Google_Container_V1alpha1_NodeManagement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NodeManagement"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "auto_upgrade"),
    2: .standard(proto: "auto_repair"),
    10: .standard(proto: "upgrade_options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.autoUpgrade) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.autoRepair) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._upgradeOptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.autoUpgrade != false {
      try visitor.visitSingularBoolField(value: self.autoUpgrade, fieldNumber: 1)
    }
    if self.autoRepair != false {
      try visitor.visitSingularBoolField(value: self.autoRepair, fieldNumber: 2)
    }
    if let v = self._upgradeOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_NodeManagement, rhs: Google_Container_V1alpha1_NodeManagement) -> Bool {
    if lhs.autoUpgrade != rhs.autoUpgrade {return false}
    if lhs.autoRepair != rhs.autoRepair {return false}
    if lhs._upgradeOptions != rhs._upgradeOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_AutoUpgradeOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AutoUpgradeOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "auto_upgrade_start_time"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.autoUpgradeStartTime) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.autoUpgradeStartTime.isEmpty {
      try visitor.visitSingularStringField(value: self.autoUpgradeStartTime, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_AutoUpgradeOptions, rhs: Google_Container_V1alpha1_AutoUpgradeOptions) -> Bool {
    if lhs.autoUpgradeStartTime != rhs.autoUpgradeStartTime {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_MaintenancePolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MaintenancePolicy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "window"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._window) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._window {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_MaintenancePolicy, rhs: Google_Container_V1alpha1_MaintenancePolicy) -> Bool {
    if lhs._window != rhs._window {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_MaintenanceWindow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MaintenanceWindow"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "daily_maintenance_window"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: Google_Container_V1alpha1_DailyMaintenanceWindow?
        if let current = self.policy {
          try decoder.handleConflictingOneOf()
          if case .dailyMaintenanceWindow(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.policy = .dailyMaintenanceWindow(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .dailyMaintenanceWindow(let v)? = self.policy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_MaintenanceWindow, rhs: Google_Container_V1alpha1_MaintenanceWindow) -> Bool {
    if lhs.policy != rhs.policy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_DailyMaintenanceWindow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DailyMaintenanceWindow"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "start_time"),
    3: .same(proto: "duration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.startTime) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.duration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.startTime.isEmpty {
      try visitor.visitSingularStringField(value: self.startTime, fieldNumber: 2)
    }
    if !self.duration.isEmpty {
      try visitor.visitSingularStringField(value: self.duration, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_DailyMaintenanceWindow, rhs: Google_Container_V1alpha1_DailyMaintenanceWindow) -> Bool {
    if lhs.startTime != rhs.startTime {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_SetNodePoolManagementRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetNodePoolManagementRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    4: .standard(proto: "node_pool_id"),
    5: .same(proto: "management"),
    7: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.nodePoolID) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._management) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if !self.nodePoolID.isEmpty {
      try visitor.visitSingularStringField(value: self.nodePoolID, fieldNumber: 4)
    }
    if let v = self._management {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_SetNodePoolManagementRequest, rhs: Google_Container_V1alpha1_SetNodePoolManagementRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs.nodePoolID != rhs.nodePoolID {return false}
    if lhs._management != rhs._management {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_SetNodePoolSizeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetNodePoolSizeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    4: .standard(proto: "node_pool_id"),
    5: .standard(proto: "node_count"),
    7: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.nodePoolID) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.nodeCount) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if !self.nodePoolID.isEmpty {
      try visitor.visitSingularStringField(value: self.nodePoolID, fieldNumber: 4)
    }
    if self.nodeCount != 0 {
      try visitor.visitSingularInt32Field(value: self.nodeCount, fieldNumber: 5)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_SetNodePoolSizeRequest, rhs: Google_Container_V1alpha1_SetNodePoolSizeRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs.nodePoolID != rhs.nodePoolID {return false}
    if lhs.nodeCount != rhs.nodeCount {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_RollbackNodePoolUpgradeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RollbackNodePoolUpgradeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    4: .standard(proto: "node_pool_id"),
    6: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.nodePoolID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if !self.nodePoolID.isEmpty {
      try visitor.visitSingularStringField(value: self.nodePoolID, fieldNumber: 4)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_RollbackNodePoolUpgradeRequest, rhs: Google_Container_V1alpha1_RollbackNodePoolUpgradeRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs.nodePoolID != rhs.nodePoolID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_ListNodePoolsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListNodePoolsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_pools"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nodePools) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodePools.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodePools, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_ListNodePoolsResponse, rhs: Google_Container_V1alpha1_ListNodePoolsResponse) -> Bool {
    if lhs.nodePools != rhs.nodePools {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_NodePoolAutoscaling: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NodePoolAutoscaling"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .standard(proto: "min_node_count"),
    3: .standard(proto: "max_node_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.minNodeCount) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.maxNodeCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if self.minNodeCount != 0 {
      try visitor.visitSingularInt32Field(value: self.minNodeCount, fieldNumber: 2)
    }
    if self.maxNodeCount != 0 {
      try visitor.visitSingularInt32Field(value: self.maxNodeCount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_NodePoolAutoscaling, rhs: Google_Container_V1alpha1_NodePoolAutoscaling) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.minNodeCount != rhs.minNodeCount {return false}
    if lhs.maxNodeCount != rhs.maxNodeCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_SetLabelsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetLabelsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    4: .standard(proto: "resource_labels"),
    5: .standard(proto: "label_fingerprint"),
    7: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.resourceLabels) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.labelFingerprint) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if !self.resourceLabels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.resourceLabels, fieldNumber: 4)
    }
    if !self.labelFingerprint.isEmpty {
      try visitor.visitSingularStringField(value: self.labelFingerprint, fieldNumber: 5)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_SetLabelsRequest, rhs: Google_Container_V1alpha1_SetLabelsRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs.resourceLabels != rhs.resourceLabels {return false}
    if lhs.labelFingerprint != rhs.labelFingerprint {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_SetLegacyAbacRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetLegacyAbacRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    4: .same(proto: "enabled"),
    6: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 4)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_SetLegacyAbacRequest, rhs: Google_Container_V1alpha1_SetLegacyAbacRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs.enabled != rhs.enabled {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_StartIPRotationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartIPRotationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    6: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_StartIPRotationRequest, rhs: Google_Container_V1alpha1_StartIPRotationRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_CompleteIPRotationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CompleteIPRotationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    7: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_CompleteIPRotationRequest, rhs: Google_Container_V1alpha1_CompleteIPRotationRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_AcceleratorConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AcceleratorConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "accelerator_count"),
    2: .standard(proto: "accelerator_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.acceleratorCount) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.acceleratorType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.acceleratorCount != 0 {
      try visitor.visitSingularInt64Field(value: self.acceleratorCount, fieldNumber: 1)
    }
    if !self.acceleratorType.isEmpty {
      try visitor.visitSingularStringField(value: self.acceleratorType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_AcceleratorConfig, rhs: Google_Container_V1alpha1_AcceleratorConfig) -> Bool {
    if lhs.acceleratorCount != rhs.acceleratorCount {return false}
    if lhs.acceleratorType != rhs.acceleratorType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_SetNetworkPolicyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetNetworkPolicyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    4: .standard(proto: "network_policy"),
    6: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._networkPolicy) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if let v = self._networkPolicy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_SetNetworkPolicyRequest, rhs: Google_Container_V1alpha1_SetNetworkPolicyRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs._networkPolicy != rhs._networkPolicy {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1alpha1_SetMaintenancePolicyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetMaintenancePolicyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    4: .standard(proto: "maintenance_policy"),
    5: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._maintenancePolicy) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if let v = self._maintenancePolicy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1alpha1_SetMaintenancePolicyRequest, rhs: Google_Container_V1alpha1_SetMaintenancePolicyRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs._maintenancePolicy != rhs._maintenancePolicy {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

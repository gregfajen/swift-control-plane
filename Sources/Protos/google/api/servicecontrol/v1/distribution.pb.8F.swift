// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/api/servicecontrol/v1/distribution.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Distribution represents a frequency distribution of double-valued sample
/// points. It contains the size of the population of sample points plus
/// additional optional information:
///
///   - the arithmetic mean of the samples
///   - the minimum and maximum of the samples
///   - the sum-squared-deviation of the samples, used to compute variance
///   - a histogram of the values of the sample points
public struct Google_Api_Servicecontrol_V1_Distribution {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The total number of samples in the distribution. Must be >= 0.
  public var count: Int64 = 0

  /// The arithmetic mean of the samples in the distribution. If `count` is
  /// zero then this field must be zero.
  public var mean: Double = 0

  /// The minimum of the population of values. Ignored if `count` is zero.
  public var minimum: Double = 0

  /// The maximum of the population of values. Ignored if `count` is zero.
  public var maximum: Double = 0

  /// The sum of squared deviations from the mean:
  ///   Sum[i=1..count]((x_i - mean)^2)
  /// where each x_i is a sample values. If `count` is zero then this field
  /// must be zero, otherwise validation of the request fails.
  public var sumOfSquaredDeviation: Double = 0

  /// The number of samples in each histogram bucket. `bucket_counts` are
  /// optional. If present, they must sum to the `count` value.
  ///
  /// The buckets are defined below in `bucket_option`. There are N buckets.
  /// `bucket_counts[0]` is the number of samples in the underflow bucket.
  /// `bucket_counts[1]` to `bucket_counts[N-1]` are the numbers of samples
  /// in each of the finite buckets. And `bucket_counts[N] is the number
  /// of samples in the overflow bucket. See the comments of `bucket_option`
  /// below for more details.
  ///
  /// Any suffix of trailing zeros may be omitted.
  public var bucketCounts: [Int64] = []

  /// Defines the buckets in the histogram. `bucket_option` and `bucket_counts`
  /// must be both set, or both unset.
  ///
  /// Buckets are numbered in the range of [0, N], with a total of N+1 buckets.
  /// There must be at least two buckets (a single-bucket histogram gives
  /// no information that isn't already provided by `count`).
  ///
  /// The first bucket is the underflow bucket which has a lower bound
  /// of -inf. The last bucket is the overflow bucket which has an
  /// upper bound of +inf. All other buckets (if any) are called "finite"
  /// buckets because they have finite lower and upper bounds. As described
  /// below, there are three ways to define the finite buckets.
  ///
  ///   (1) Buckets with constant width.
  ///   (2) Buckets with exponentially growing widths.
  ///   (3) Buckets with arbitrary user-provided widths.
  ///
  /// In all cases, the buckets cover the entire real number line (-inf,
  /// +inf). Bucket upper bounds are exclusive and lower bounds are
  /// inclusive. The upper bound of the underflow bucket is equal to the
  /// lower bound of the smallest finite bucket; the lower bound of the
  /// overflow bucket is equal to the upper bound of the largest finite
  /// bucket.
  public var bucketOption: Google_Api_Servicecontrol_V1_Distribution.OneOf_BucketOption? = nil

  /// Buckets with constant width.
  public var linearBuckets: Google_Api_Servicecontrol_V1_Distribution.LinearBuckets {
    get {
      if case .linearBuckets(let v)? = bucketOption {return v}
      return Google_Api_Servicecontrol_V1_Distribution.LinearBuckets()
    }
    set {bucketOption = .linearBuckets(newValue)}
  }

  /// Buckets with exponentially growing width.
  public var exponentialBuckets: Google_Api_Servicecontrol_V1_Distribution.ExponentialBuckets {
    get {
      if case .exponentialBuckets(let v)? = bucketOption {return v}
      return Google_Api_Servicecontrol_V1_Distribution.ExponentialBuckets()
    }
    set {bucketOption = .exponentialBuckets(newValue)}
  }

  /// Buckets with arbitrary user-provided width.
  public var explicitBuckets: Google_Api_Servicecontrol_V1_Distribution.ExplicitBuckets {
    get {
      if case .explicitBuckets(let v)? = bucketOption {return v}
      return Google_Api_Servicecontrol_V1_Distribution.ExplicitBuckets()
    }
    set {bucketOption = .explicitBuckets(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Defines the buckets in the histogram. `bucket_option` and `bucket_counts`
  /// must be both set, or both unset.
  ///
  /// Buckets are numbered in the range of [0, N], with a total of N+1 buckets.
  /// There must be at least two buckets (a single-bucket histogram gives
  /// no information that isn't already provided by `count`).
  ///
  /// The first bucket is the underflow bucket which has a lower bound
  /// of -inf. The last bucket is the overflow bucket which has an
  /// upper bound of +inf. All other buckets (if any) are called "finite"
  /// buckets because they have finite lower and upper bounds. As described
  /// below, there are three ways to define the finite buckets.
  ///
  ///   (1) Buckets with constant width.
  ///   (2) Buckets with exponentially growing widths.
  ///   (3) Buckets with arbitrary user-provided widths.
  ///
  /// In all cases, the buckets cover the entire real number line (-inf,
  /// +inf). Bucket upper bounds are exclusive and lower bounds are
  /// inclusive. The upper bound of the underflow bucket is equal to the
  /// lower bound of the smallest finite bucket; the lower bound of the
  /// overflow bucket is equal to the upper bound of the largest finite
  /// bucket.
  public enum OneOf_BucketOption: Equatable {
    /// Buckets with constant width.
    case linearBuckets(Google_Api_Servicecontrol_V1_Distribution.LinearBuckets)
    /// Buckets with exponentially growing width.
    case exponentialBuckets(Google_Api_Servicecontrol_V1_Distribution.ExponentialBuckets)
    /// Buckets with arbitrary user-provided width.
    case explicitBuckets(Google_Api_Servicecontrol_V1_Distribution.ExplicitBuckets)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Api_Servicecontrol_V1_Distribution.OneOf_BucketOption, rhs: Google_Api_Servicecontrol_V1_Distribution.OneOf_BucketOption) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.linearBuckets, .linearBuckets): return {
        guard case .linearBuckets(let l) = lhs, case .linearBuckets(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.exponentialBuckets, .exponentialBuckets): return {
        guard case .exponentialBuckets(let l) = lhs, case .exponentialBuckets(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.explicitBuckets, .explicitBuckets): return {
        guard case .explicitBuckets(let l) = lhs, case .explicitBuckets(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Describing buckets with constant width.
  public struct LinearBuckets {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The number of finite buckets. With the underflow and overflow buckets,
    /// the total number of buckets is `num_finite_buckets` + 2.
    /// See comments on `bucket_options` for details.
    public var numFiniteBuckets: Int32 = 0

    /// The i'th linear bucket covers the interval
    ///   [offset + (i-1) * width, offset + i * width)
    /// where i ranges from 1 to num_finite_buckets, inclusive.
    /// Must be strictly positive.
    public var width: Double = 0

    /// The i'th linear bucket covers the interval
    ///   [offset + (i-1) * width, offset + i * width)
    /// where i ranges from 1 to num_finite_buckets, inclusive.
    public var offset: Double = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Describing buckets with exponentially growing width.
  public struct ExponentialBuckets {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The number of finite buckets. With the underflow and overflow buckets,
    /// the total number of buckets is `num_finite_buckets` + 2.
    /// See comments on `bucket_options` for details.
    public var numFiniteBuckets: Int32 = 0

    /// The i'th exponential bucket covers the interval
    ///   [scale * growth_factor^(i-1), scale * growth_factor^i)
    /// where i ranges from 1 to num_finite_buckets inclusive.
    /// Must be larger than 1.0.
    public var growthFactor: Double = 0

    /// The i'th exponential bucket covers the interval
    ///   [scale * growth_factor^(i-1), scale * growth_factor^i)
    /// where i ranges from 1 to num_finite_buckets inclusive.
    /// Must be > 0.
    public var scale: Double = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Describing buckets with arbitrary user-provided width.
  public struct ExplicitBuckets {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// 'bound' is a list of strictly increasing boundaries between
    /// buckets. Note that a list of length N-1 defines N buckets because
    /// of fenceposting. See comments on `bucket_options` for details.
    ///
    /// The i'th finite bucket covers the interval
    ///   [bound[i-1], bound[i])
    /// where i ranges from 1 to bound_size() - 1. Note that there are no
    /// finite buckets at all if 'bound' only contains a single element; in
    /// that special case the single bound defines the boundary between the
    /// underflow and overflow buckets.
    ///
    /// bucket number                   lower bound    upper bound
    ///  i == 0 (underflow)              -inf           bound[i]
    ///  0 < i < bound_size()            bound[i-1]     bound[i]
    ///  i == bound_size() (overflow)    bound[i-1]     +inf
    public var bounds: [Double] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.api.servicecontrol.v1"

extension Google_Api_Servicecontrol_V1_Distribution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Distribution"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "count"),
    2: .same(proto: "mean"),
    3: .same(proto: "minimum"),
    4: .same(proto: "maximum"),
    5: .standard(proto: "sum_of_squared_deviation"),
    6: .standard(proto: "bucket_counts"),
    7: .standard(proto: "linear_buckets"),
    8: .standard(proto: "exponential_buckets"),
    9: .standard(proto: "explicit_buckets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.count) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.mean) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.minimum) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.maximum) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.sumOfSquaredDeviation) }()
      case 6: try { try decoder.decodeRepeatedInt64Field(value: &self.bucketCounts) }()
      case 7: try {
        var v: Google_Api_Servicecontrol_V1_Distribution.LinearBuckets?
        if let current = self.bucketOption {
          try decoder.handleConflictingOneOf()
          if case .linearBuckets(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.bucketOption = .linearBuckets(v)}
      }()
      case 8: try {
        var v: Google_Api_Servicecontrol_V1_Distribution.ExponentialBuckets?
        if let current = self.bucketOption {
          try decoder.handleConflictingOneOf()
          if case .exponentialBuckets(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.bucketOption = .exponentialBuckets(v)}
      }()
      case 9: try {
        var v: Google_Api_Servicecontrol_V1_Distribution.ExplicitBuckets?
        if let current = self.bucketOption {
          try decoder.handleConflictingOneOf()
          if case .explicitBuckets(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.bucketOption = .explicitBuckets(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.count != 0 {
      try visitor.visitSingularInt64Field(value: self.count, fieldNumber: 1)
    }
    if self.mean != 0 {
      try visitor.visitSingularDoubleField(value: self.mean, fieldNumber: 2)
    }
    if self.minimum != 0 {
      try visitor.visitSingularDoubleField(value: self.minimum, fieldNumber: 3)
    }
    if self.maximum != 0 {
      try visitor.visitSingularDoubleField(value: self.maximum, fieldNumber: 4)
    }
    if self.sumOfSquaredDeviation != 0 {
      try visitor.visitSingularDoubleField(value: self.sumOfSquaredDeviation, fieldNumber: 5)
    }
    if !self.bucketCounts.isEmpty {
      try visitor.visitPackedInt64Field(value: self.bucketCounts, fieldNumber: 6)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.bucketOption {
    case .linearBuckets?: try {
      guard case .linearBuckets(let v)? = self.bucketOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .exponentialBuckets?: try {
      guard case .exponentialBuckets(let v)? = self.bucketOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .explicitBuckets?: try {
      guard case .explicitBuckets(let v)? = self.bucketOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Api_Servicecontrol_V1_Distribution, rhs: Google_Api_Servicecontrol_V1_Distribution) -> Bool {
    if lhs.count != rhs.count {return false}
    if lhs.mean != rhs.mean {return false}
    if lhs.minimum != rhs.minimum {return false}
    if lhs.maximum != rhs.maximum {return false}
    if lhs.sumOfSquaredDeviation != rhs.sumOfSquaredDeviation {return false}
    if lhs.bucketCounts != rhs.bucketCounts {return false}
    if lhs.bucketOption != rhs.bucketOption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Api_Servicecontrol_V1_Distribution.LinearBuckets: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Api_Servicecontrol_V1_Distribution.protoMessageName + ".LinearBuckets"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "num_finite_buckets"),
    2: .same(proto: "width"),
    3: .same(proto: "offset"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.numFiniteBuckets) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.width) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.offset) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.numFiniteBuckets != 0 {
      try visitor.visitSingularInt32Field(value: self.numFiniteBuckets, fieldNumber: 1)
    }
    if self.width != 0 {
      try visitor.visitSingularDoubleField(value: self.width, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularDoubleField(value: self.offset, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Api_Servicecontrol_V1_Distribution.LinearBuckets, rhs: Google_Api_Servicecontrol_V1_Distribution.LinearBuckets) -> Bool {
    if lhs.numFiniteBuckets != rhs.numFiniteBuckets {return false}
    if lhs.width != rhs.width {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Api_Servicecontrol_V1_Distribution.ExponentialBuckets: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Api_Servicecontrol_V1_Distribution.protoMessageName + ".ExponentialBuckets"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "num_finite_buckets"),
    2: .standard(proto: "growth_factor"),
    3: .same(proto: "scale"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.numFiniteBuckets) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.growthFactor) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.scale) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.numFiniteBuckets != 0 {
      try visitor.visitSingularInt32Field(value: self.numFiniteBuckets, fieldNumber: 1)
    }
    if self.growthFactor != 0 {
      try visitor.visitSingularDoubleField(value: self.growthFactor, fieldNumber: 2)
    }
    if self.scale != 0 {
      try visitor.visitSingularDoubleField(value: self.scale, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Api_Servicecontrol_V1_Distribution.ExponentialBuckets, rhs: Google_Api_Servicecontrol_V1_Distribution.ExponentialBuckets) -> Bool {
    if lhs.numFiniteBuckets != rhs.numFiniteBuckets {return false}
    if lhs.growthFactor != rhs.growthFactor {return false}
    if lhs.scale != rhs.scale {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Api_Servicecontrol_V1_Distribution.ExplicitBuckets: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Api_Servicecontrol_V1_Distribution.protoMessageName + ".ExplicitBuckets"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bounds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedDoubleField(value: &self.bounds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bounds.isEmpty {
      try visitor.visitPackedDoubleField(value: self.bounds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Api_Servicecontrol_V1_Distribution.ExplicitBuckets, rhs: Google_Api_Servicecontrol_V1_Distribution.ExplicitBuckets) -> Bool {
    if lhs.bounds != rhs.bounds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/api/servicecontrol/v1/quota_controller.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Request message for the AllocateQuota method.
public struct Google_Api_Servicecontrol_V1_AllocateQuotaRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the service as specified in the service configuration. For example,
  /// `"pubsub.googleapis.com"`.
  ///
  /// See [google.api.Service][google.api.Service] for the definition of a service name.
  public var serviceName: String = String()

  /// Operation that describes the quota allocation.
  public var allocateOperation: Google_Api_Servicecontrol_V1_QuotaOperation {
    get {return _allocateOperation ?? Google_Api_Servicecontrol_V1_QuotaOperation()}
    set {_allocateOperation = newValue}
  }
  /// Returns true if `allocateOperation` has been explicitly set.
  public var hasAllocateOperation: Bool {return self._allocateOperation != nil}
  /// Clears the value of `allocateOperation`. Subsequent reads from it will return its default value.
  public mutating func clearAllocateOperation() {self._allocateOperation = nil}

  /// Specifies which version of service configuration should be used to process
  /// the request. If unspecified or no matching version can be found, the latest
  /// one will be used.
  public var serviceConfigID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _allocateOperation: Google_Api_Servicecontrol_V1_QuotaOperation? = nil
}

/// Represents information regarding a quota operation.
public struct Google_Api_Servicecontrol_V1_QuotaOperation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Identity of the operation. This is expected to be unique within the scope
  /// of the service that generated the operation, and guarantees idempotency in
  /// case of retries.
  ///
  /// In order to ensure best performance and latency in the Quota backends,
  /// operation_ids are optimally associated with time, so that related
  /// operations can be accessed fast in storage. For this reason, the
  /// recommended token for services that intend to operate at a high QPS is
  /// Unix time in nanos + UUID
  public var operationID: String = String()

  /// Fully qualified name of the API method for which this quota operation is
  /// requested. This name is used for matching quota rules or metric rules and
  /// billing status rules defined in service configuration.
  ///
  /// This field should not be set if any of the following is true:
  /// (1) the quota operation is performed on non-API resources.
  /// (2) quota_metrics is set because the caller is doing quota override.
  ///
  /// Example of an RPC method name:
  ///     google.example.library.v1.LibraryService.CreateShelf
  public var methodName: String = String()

  /// Identity of the consumer for whom this quota operation is being performed.
  ///
  /// This can be in one of the following formats:
  ///   project:<project_id>,
  ///   project_number:<project_number>,
  ///   api_key:<api_key>.
  public var consumerID: String = String()

  /// Labels describing the operation.
  public var labels: Dictionary<String,String> = [:]

  /// Represents information about this operation. Each MetricValueSet
  /// corresponds to a metric defined in the service configuration.
  /// The data type used in the MetricValueSet must agree with
  /// the data type specified in the metric definition.
  ///
  /// Within a single operation, it is not allowed to have more than one
  /// MetricValue instances that have the same metric names and identical
  /// label value combinations. If a request has such duplicated MetricValue
  /// instances, the entire request is rejected with
  /// an invalid argument error.
  ///
  /// This field is mutually exclusive with method_name.
  public var quotaMetrics: [Google_Api_Servicecontrol_V1_MetricValueSet] = []

  /// Quota mode for this operation.
  public var quotaMode: Google_Api_Servicecontrol_V1_QuotaOperation.QuotaMode = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Supported quota modes.
  public enum QuotaMode: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Guard against implicit default. Must not be used.
    case unspecified // = 0

    /// For AllocateQuota request, allocates quota for the amount specified in
    /// the service configuration or specified using the quota metrics. If the
    /// amount is higher than the available quota, allocation error will be
    /// returned and no quota will be allocated.
    /// If multiple quotas are part of the request, and one fails, none of the
    /// quotas are allocated or released.
    case normal // = 1

    /// The operation allocates quota for the amount specified in the service
    /// configuration or specified using the quota metrics. If the amount is
    /// higher than the available quota, request does not fail but all available
    /// quota will be allocated.
    /// For rate quota, BEST_EFFORT will continue to deduct from other groups
    /// even if one does not have enough quota. For allocation, it will find the
    /// minimum available amount across all groups and deduct that amount from
    /// all the affected groups.
    case bestEffort // = 2

    /// For AllocateQuota request, only checks if there is enough quota
    /// available and does not change the available quota. No lock is placed on
    /// the available quota either.
    case checkOnly // = 3

    /// Unimplemented. When used in AllocateQuotaRequest, this returns the
    /// effective quota limit(s) in the response, and no quota check will be
    /// performed. Not supported for other requests, and even for
    /// AllocateQuotaRequest, this is currently supported only for whitelisted
    /// services.
    case queryOnly // = 4

    /// The operation allocates quota for the amount specified in the service
    /// configuration or specified using the quota metrics. If the requested
    /// amount is higher than the available quota, request does not fail and
    /// remaining quota would become negative (going over the limit)
    /// Not supported for Rate Quota.
    case adjustOnly // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .normal
      case 2: self = .bestEffort
      case 3: self = .checkOnly
      case 4: self = .queryOnly
      case 5: self = .adjustOnly
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .normal: return 1
      case .bestEffort: return 2
      case .checkOnly: return 3
      case .queryOnly: return 4
      case .adjustOnly: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Api_Servicecontrol_V1_QuotaOperation.QuotaMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Api_Servicecontrol_V1_QuotaOperation.QuotaMode] = [
    .unspecified,
    .normal,
    .bestEffort,
    .checkOnly,
    .queryOnly,
    .adjustOnly,
  ]
}

#endif  // swift(>=4.2)

/// Response message for the AllocateQuota method.
public struct Google_Api_Servicecontrol_V1_AllocateQuotaResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The same operation_id value used in the AllocateQuotaRequest. Used for
  /// logging and diagnostics purposes.
  public var operationID: String = String()

  /// Indicates the decision of the allocate.
  public var allocateErrors: [Google_Api_Servicecontrol_V1_QuotaError] = []

  /// Quota metrics to indicate the result of allocation. Depending on the
  /// request, one or more of the following metrics will be included:
  ///
  /// 1. Per quota group or per quota metric incremental usage will be specified
  /// using the following delta metric :
  ///   "serviceruntime.googleapis.com/api/consumer/quota_used_count"
  ///
  /// 2. The quota limit reached condition will be specified using the following
  /// boolean metric :
  ///   "serviceruntime.googleapis.com/quota/exceeded"
  public var quotaMetrics: [Google_Api_Servicecontrol_V1_MetricValueSet] = []

  /// ID of the actual config used to process the request.
  public var serviceConfigID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Represents error information for [QuotaOperation][google.api.servicecontrol.v1.QuotaOperation].
public struct Google_Api_Servicecontrol_V1_QuotaError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Error code.
  public var code: Google_Api_Servicecontrol_V1_QuotaError.Code = .unspecified

  /// Subject to whom this error applies. See the specific enum for more details
  /// on this field. For example, "clientip:<ip address of client>" or
  /// "project:<Google developer project id>".
  public var subject: String = String()

  /// Free-form text that provides details on the cause of the error.
  public var description_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Error codes related to project config validations are deprecated since the
  /// quota controller methods do not perform these validations. Instead services
  /// have to call the Check method, without quota_properties field, to perform
  /// these validations before calling the quota controller methods. These
  /// methods check only for project deletion to be wipe out compliant.
  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// This is never used.
    case unspecified // = 0

    /// Quota allocation failed.
    /// Same as [google.rpc.Code.RESOURCE_EXHAUSTED][google.rpc.Code.RESOURCE_EXHAUSTED].
    case resourceExhausted // = 8

    /// Consumer cannot access the service because the service requires active
    /// billing.
    case billingNotActive // = 107

    /// Consumer's project has been marked as deleted (soft deletion).
    case projectDeleted // = 108

    /// Specified API key is invalid.
    case apiKeyInvalid // = 105

    /// Specified API Key has expired.
    case apiKeyExpired // = 112
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 8: self = .resourceExhausted
      case 105: self = .apiKeyInvalid
      case 107: self = .billingNotActive
      case 108: self = .projectDeleted
      case 112: self = .apiKeyExpired
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .resourceExhausted: return 8
      case .apiKeyInvalid: return 105
      case .billingNotActive: return 107
      case .projectDeleted: return 108
      case .apiKeyExpired: return 112
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Api_Servicecontrol_V1_QuotaError.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Api_Servicecontrol_V1_QuotaError.Code] = [
    .unspecified,
    .resourceExhausted,
    .billingNotActive,
    .projectDeleted,
    .apiKeyInvalid,
    .apiKeyExpired,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.api.servicecontrol.v1"

extension Google_Api_Servicecontrol_V1_AllocateQuotaRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AllocateQuotaRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "service_name"),
    2: .standard(proto: "allocate_operation"),
    4: .standard(proto: "service_config_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.serviceName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._allocateOperation) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.serviceConfigID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serviceName.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceName, fieldNumber: 1)
    }
    if let v = self._allocateOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.serviceConfigID.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceConfigID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Api_Servicecontrol_V1_AllocateQuotaRequest, rhs: Google_Api_Servicecontrol_V1_AllocateQuotaRequest) -> Bool {
    if lhs.serviceName != rhs.serviceName {return false}
    if lhs._allocateOperation != rhs._allocateOperation {return false}
    if lhs.serviceConfigID != rhs.serviceConfigID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Api_Servicecontrol_V1_QuotaOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QuotaOperation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "operation_id"),
    2: .standard(proto: "method_name"),
    3: .standard(proto: "consumer_id"),
    4: .same(proto: "labels"),
    5: .standard(proto: "quota_metrics"),
    6: .standard(proto: "quota_mode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.operationID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.methodName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.consumerID) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.quotaMetrics) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.quotaMode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.operationID.isEmpty {
      try visitor.visitSingularStringField(value: self.operationID, fieldNumber: 1)
    }
    if !self.methodName.isEmpty {
      try visitor.visitSingularStringField(value: self.methodName, fieldNumber: 2)
    }
    if !self.consumerID.isEmpty {
      try visitor.visitSingularStringField(value: self.consumerID, fieldNumber: 3)
    }
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 4)
    }
    if !self.quotaMetrics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.quotaMetrics, fieldNumber: 5)
    }
    if self.quotaMode != .unspecified {
      try visitor.visitSingularEnumField(value: self.quotaMode, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Api_Servicecontrol_V1_QuotaOperation, rhs: Google_Api_Servicecontrol_V1_QuotaOperation) -> Bool {
    if lhs.operationID != rhs.operationID {return false}
    if lhs.methodName != rhs.methodName {return false}
    if lhs.consumerID != rhs.consumerID {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.quotaMetrics != rhs.quotaMetrics {return false}
    if lhs.quotaMode != rhs.quotaMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Api_Servicecontrol_V1_QuotaOperation.QuotaMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED"),
    1: .same(proto: "NORMAL"),
    2: .same(proto: "BEST_EFFORT"),
    3: .same(proto: "CHECK_ONLY"),
    4: .same(proto: "QUERY_ONLY"),
    5: .same(proto: "ADJUST_ONLY"),
  ]
}

extension Google_Api_Servicecontrol_V1_AllocateQuotaResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AllocateQuotaResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "operation_id"),
    2: .standard(proto: "allocate_errors"),
    3: .standard(proto: "quota_metrics"),
    4: .standard(proto: "service_config_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.operationID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.allocateErrors) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.quotaMetrics) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.serviceConfigID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.operationID.isEmpty {
      try visitor.visitSingularStringField(value: self.operationID, fieldNumber: 1)
    }
    if !self.allocateErrors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.allocateErrors, fieldNumber: 2)
    }
    if !self.quotaMetrics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.quotaMetrics, fieldNumber: 3)
    }
    if !self.serviceConfigID.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceConfigID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Api_Servicecontrol_V1_AllocateQuotaResponse, rhs: Google_Api_Servicecontrol_V1_AllocateQuotaResponse) -> Bool {
    if lhs.operationID != rhs.operationID {return false}
    if lhs.allocateErrors != rhs.allocateErrors {return false}
    if lhs.quotaMetrics != rhs.quotaMetrics {return false}
    if lhs.serviceConfigID != rhs.serviceConfigID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Api_Servicecontrol_V1_QuotaError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QuotaError"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "subject"),
    3: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subject) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .unspecified {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.subject.isEmpty {
      try visitor.visitSingularStringField(value: self.subject, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Api_Servicecontrol_V1_QuotaError, rhs: Google_Api_Servicecontrol_V1_QuotaError) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.subject != rhs.subject {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Api_Servicecontrol_V1_QuotaError.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED"),
    8: .same(proto: "RESOURCE_EXHAUSTED"),
    105: .same(proto: "API_KEY_INVALID"),
    107: .same(proto: "BILLING_NOT_ACTIVE"),
    108: .same(proto: "PROJECT_DELETED"),
    112: .same(proto: "API_KEY_EXPIRED"),
  ]
}

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/api/expr/v1alpha1/checked.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A CEL expression which has been successfully type checked.
public struct Google_Api_Expr_V1alpha1_CheckedExpr {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A map from expression ids to resolved references.
  ///
  /// The following entries are in this table:
  ///
  /// - An Ident or Select expression is represented here if it resolves to a
  ///   declaration. For instance, if `a.b.c` is represented by
  ///   `select(select(id(a), b), c)`, and `a.b` resolves to a declaration,
  ///   while `c` is a field selection, then the reference is attached to the
  ///   nested select expression (but not to the id or or the outer select).
  ///   In turn, if `a` resolves to a declaration and `b.c` are field selections,
  ///   the reference is attached to the ident expression.
  /// - Every Call expression has an entry here, identifying the function being
  ///   called.
  /// - Every CreateStruct expression for a message has an entry, identifying
  ///   the message.
  public var referenceMap: Dictionary<Int64,Google_Api_Expr_V1alpha1_Reference> = [:]

  /// A map from expression ids to types.
  ///
  /// Every expression node which has a type different than DYN has a mapping
  /// here. If an expression has type DYN, it is omitted from this map to save
  /// space.
  public var typeMap: Dictionary<Int64,Google_Api_Expr_V1alpha1_Type> = [:]

  /// The source info derived from input that generated the parsed `expr` and
  /// any optimizations made during the type-checking pass.
  public var sourceInfo: Google_Api_Expr_V1alpha1_SourceInfo {
    get {return _sourceInfo ?? Google_Api_Expr_V1alpha1_SourceInfo()}
    set {_sourceInfo = newValue}
  }
  /// Returns true if `sourceInfo` has been explicitly set.
  public var hasSourceInfo: Bool {return self._sourceInfo != nil}
  /// Clears the value of `sourceInfo`. Subsequent reads from it will return its default value.
  public mutating func clearSourceInfo() {self._sourceInfo = nil}

  /// The checked expression. Semantically equivalent to the parsed `expr`, but
  /// may have structural differences.
  public var expr: Google_Api_Expr_V1alpha1_Expr {
    get {return _expr ?? Google_Api_Expr_V1alpha1_Expr()}
    set {_expr = newValue}
  }
  /// Returns true if `expr` has been explicitly set.
  public var hasExpr: Bool {return self._expr != nil}
  /// Clears the value of `expr`. Subsequent reads from it will return its default value.
  public mutating func clearExpr() {self._expr = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sourceInfo: Google_Api_Expr_V1alpha1_SourceInfo? = nil
  fileprivate var _expr: Google_Api_Expr_V1alpha1_Expr? = nil
}

/// Represents a CEL type.
public struct Google_Api_Expr_V1alpha1_Type {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The kind of type.
  public var typeKind: OneOf_TypeKind? {
    get {return _storage._typeKind}
    set {_uniqueStorage()._typeKind = newValue}
  }

  /// Dynamic type.
  public var dyn: SwiftProtobuf.Google_Protobuf_Empty {
    get {
      if case .dyn(let v)? = _storage._typeKind {return v}
      return SwiftProtobuf.Google_Protobuf_Empty()
    }
    set {_uniqueStorage()._typeKind = .dyn(newValue)}
  }

  /// Null value.
  public var null: SwiftProtobuf.Google_Protobuf_NullValue {
    get {
      if case .null(let v)? = _storage._typeKind {return v}
      return .nullValue
    }
    set {_uniqueStorage()._typeKind = .null(newValue)}
  }

  /// Primitive types: `true`, `1u`, `-2.0`, `'string'`, `b'bytes'`.
  public var primitive: Google_Api_Expr_V1alpha1_Type.PrimitiveType {
    get {
      if case .primitive(let v)? = _storage._typeKind {return v}
      return .unspecified
    }
    set {_uniqueStorage()._typeKind = .primitive(newValue)}
  }

  /// Wrapper of a primitive type, e.g. `google.protobuf.Int64Value`.
  public var wrapper: Google_Api_Expr_V1alpha1_Type.PrimitiveType {
    get {
      if case .wrapper(let v)? = _storage._typeKind {return v}
      return .unspecified
    }
    set {_uniqueStorage()._typeKind = .wrapper(newValue)}
  }

  /// Well-known protobuf type such as `google.protobuf.Timestamp`.
  public var wellKnown: Google_Api_Expr_V1alpha1_Type.WellKnownType {
    get {
      if case .wellKnown(let v)? = _storage._typeKind {return v}
      return .unspecified
    }
    set {_uniqueStorage()._typeKind = .wellKnown(newValue)}
  }

  /// Parameterized list with elements of `list_type`, e.g. `list<timestamp>`.
  public var listType: Google_Api_Expr_V1alpha1_Type.ListType {
    get {
      if case .listType(let v)? = _storage._typeKind {return v}
      return Google_Api_Expr_V1alpha1_Type.ListType()
    }
    set {_uniqueStorage()._typeKind = .listType(newValue)}
  }

  /// Parameterized map with typed keys and values.
  public var mapType: Google_Api_Expr_V1alpha1_Type.MapType {
    get {
      if case .mapType(let v)? = _storage._typeKind {return v}
      return Google_Api_Expr_V1alpha1_Type.MapType()
    }
    set {_uniqueStorage()._typeKind = .mapType(newValue)}
  }

  /// Function type.
  public var function: Google_Api_Expr_V1alpha1_Type.FunctionType {
    get {
      if case .function(let v)? = _storage._typeKind {return v}
      return Google_Api_Expr_V1alpha1_Type.FunctionType()
    }
    set {_uniqueStorage()._typeKind = .function(newValue)}
  }

  /// Protocol buffer message type.
  ///
  /// The `message_type` string specifies the qualified message type name. For
  /// example, `google.plus.Profile`.
  public var messageType: String {
    get {
      if case .messageType(let v)? = _storage._typeKind {return v}
      return String()
    }
    set {_uniqueStorage()._typeKind = .messageType(newValue)}
  }

  /// Type param type.
  ///
  /// The `type_param` string specifies the type parameter name, e.g. `list<E>`
  /// would be a `list_type` whose element type was a `type_param` type
  /// named `E`.
  public var typeParam: String {
    get {
      if case .typeParam(let v)? = _storage._typeKind {return v}
      return String()
    }
    set {_uniqueStorage()._typeKind = .typeParam(newValue)}
  }

  /// Type type.
  ///
  /// The `type` value specifies the target type. e.g. int is type with a
  /// target type of `Primitive.INT`.
  public var type: Google_Api_Expr_V1alpha1_Type {
    get {
      if case .type(let v)? = _storage._typeKind {return v}
      return Google_Api_Expr_V1alpha1_Type()
    }
    set {_uniqueStorage()._typeKind = .type(newValue)}
  }

  /// Error type.
  ///
  /// During type-checking if an expression is an error, its type is propagated
  /// as the `ERROR` type. This permits the type-checker to discover other
  /// errors present in the expression.
  public var error: SwiftProtobuf.Google_Protobuf_Empty {
    get {
      if case .error(let v)? = _storage._typeKind {return v}
      return SwiftProtobuf.Google_Protobuf_Empty()
    }
    set {_uniqueStorage()._typeKind = .error(newValue)}
  }

  /// Abstract, application defined type.
  public var abstractType: Google_Api_Expr_V1alpha1_Type.AbstractType {
    get {
      if case .abstractType(let v)? = _storage._typeKind {return v}
      return Google_Api_Expr_V1alpha1_Type.AbstractType()
    }
    set {_uniqueStorage()._typeKind = .abstractType(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The kind of type.
  public enum OneOf_TypeKind: Equatable {
    /// Dynamic type.
    case dyn(SwiftProtobuf.Google_Protobuf_Empty)
    /// Null value.
    case null(SwiftProtobuf.Google_Protobuf_NullValue)
    /// Primitive types: `true`, `1u`, `-2.0`, `'string'`, `b'bytes'`.
    case primitive(Google_Api_Expr_V1alpha1_Type.PrimitiveType)
    /// Wrapper of a primitive type, e.g. `google.protobuf.Int64Value`.
    case wrapper(Google_Api_Expr_V1alpha1_Type.PrimitiveType)
    /// Well-known protobuf type such as `google.protobuf.Timestamp`.
    case wellKnown(Google_Api_Expr_V1alpha1_Type.WellKnownType)
    /// Parameterized list with elements of `list_type`, e.g. `list<timestamp>`.
    case listType(Google_Api_Expr_V1alpha1_Type.ListType)
    /// Parameterized map with typed keys and values.
    case mapType(Google_Api_Expr_V1alpha1_Type.MapType)
    /// Function type.
    case function(Google_Api_Expr_V1alpha1_Type.FunctionType)
    /// Protocol buffer message type.
    ///
    /// The `message_type` string specifies the qualified message type name. For
    /// example, `google.plus.Profile`.
    case messageType(String)
    /// Type param type.
    ///
    /// The `type_param` string specifies the type parameter name, e.g. `list<E>`
    /// would be a `list_type` whose element type was a `type_param` type
    /// named `E`.
    case typeParam(String)
    /// Type type.
    ///
    /// The `type` value specifies the target type. e.g. int is type with a
    /// target type of `Primitive.INT`.
    case type(Google_Api_Expr_V1alpha1_Type)
    /// Error type.
    ///
    /// During type-checking if an expression is an error, its type is propagated
    /// as the `ERROR` type. This permits the type-checker to discover other
    /// errors present in the expression.
    case error(SwiftProtobuf.Google_Protobuf_Empty)
    /// Abstract, application defined type.
    case abstractType(Google_Api_Expr_V1alpha1_Type.AbstractType)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Api_Expr_V1alpha1_Type.OneOf_TypeKind, rhs: Google_Api_Expr_V1alpha1_Type.OneOf_TypeKind) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.dyn, .dyn): return {
        guard case .dyn(let l) = lhs, case .dyn(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.null, .null): return {
        guard case .null(let l) = lhs, case .null(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.primitive, .primitive): return {
        guard case .primitive(let l) = lhs, case .primitive(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.wrapper, .wrapper): return {
        guard case .wrapper(let l) = lhs, case .wrapper(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.wellKnown, .wellKnown): return {
        guard case .wellKnown(let l) = lhs, case .wellKnown(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.listType, .listType): return {
        guard case .listType(let l) = lhs, case .listType(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mapType, .mapType): return {
        guard case .mapType(let l) = lhs, case .mapType(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.function, .function): return {
        guard case .function(let l) = lhs, case .function(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.messageType, .messageType): return {
        guard case .messageType(let l) = lhs, case .messageType(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.typeParam, .typeParam): return {
        guard case .typeParam(let l) = lhs, case .typeParam(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.type, .type): return {
        guard case .type(let l) = lhs, case .type(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.abstractType, .abstractType): return {
        guard case .abstractType(let l) = lhs, case .abstractType(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// CEL primitive types.
  public enum PrimitiveType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unspecified type.
    case unspecified // = 0

    /// Boolean type.
    case bool // = 1

    /// Int64 type.
    ///
    /// Proto-based integer values are widened to int64.
    case int64 // = 2

    /// Uint64 type.
    ///
    /// Proto-based unsigned integer values are widened to uint64.
    case uint64 // = 3

    /// Double type.
    ///
    /// Proto-based float values are widened to double values.
    case double // = 4

    /// String type.
    case string // = 5

    /// Bytes type.
    case bytes // = 6
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .bool
      case 2: self = .int64
      case 3: self = .uint64
      case 4: self = .double
      case 5: self = .string
      case 6: self = .bytes
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .bool: return 1
      case .int64: return 2
      case .uint64: return 3
      case .double: return 4
      case .string: return 5
      case .bytes: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Well-known protobuf types treated with first-class support in CEL.
  public enum WellKnownType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unspecified type.
    case unspecified // = 0

    /// Well-known protobuf.Any type.
    ///
    /// Any types are a polymorphic message type. During type-checking they are
    /// treated like `DYN` types, but at runtime they are resolved to a specific
    /// message type specified at evaluation time.
    case any // = 1

    /// Well-known protobuf.Timestamp type, internally referenced as `timestamp`.
    case timestamp // = 2

    /// Well-known protobuf.Duration type, internally referenced as `duration`.
    case duration // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .any
      case 2: self = .timestamp
      case 3: self = .duration
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .any: return 1
      case .timestamp: return 2
      case .duration: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// List type with typed elements, e.g. `list<example.proto.MyMessage>`.
  public struct ListType {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The element type.
    public var elemType: Google_Api_Expr_V1alpha1_Type {
      get {return _storage._elemType ?? Google_Api_Expr_V1alpha1_Type()}
      set {_uniqueStorage()._elemType = newValue}
    }
    /// Returns true if `elemType` has been explicitly set.
    public var hasElemType: Bool {return _storage._elemType != nil}
    /// Clears the value of `elemType`. Subsequent reads from it will return its default value.
    public mutating func clearElemType() {_uniqueStorage()._elemType = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Map type with parameterized key and value types, e.g. `map<string, int>`.
  public struct MapType {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The type of the key.
    public var keyType: Google_Api_Expr_V1alpha1_Type {
      get {return _storage._keyType ?? Google_Api_Expr_V1alpha1_Type()}
      set {_uniqueStorage()._keyType = newValue}
    }
    /// Returns true if `keyType` has been explicitly set.
    public var hasKeyType: Bool {return _storage._keyType != nil}
    /// Clears the value of `keyType`. Subsequent reads from it will return its default value.
    public mutating func clearKeyType() {_uniqueStorage()._keyType = nil}

    /// The type of the value.
    public var valueType: Google_Api_Expr_V1alpha1_Type {
      get {return _storage._valueType ?? Google_Api_Expr_V1alpha1_Type()}
      set {_uniqueStorage()._valueType = newValue}
    }
    /// Returns true if `valueType` has been explicitly set.
    public var hasValueType: Bool {return _storage._valueType != nil}
    /// Clears the value of `valueType`. Subsequent reads from it will return its default value.
    public mutating func clearValueType() {_uniqueStorage()._valueType = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Function type with result and arg types.
  public struct FunctionType {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Result type of the function.
    public var resultType: Google_Api_Expr_V1alpha1_Type {
      get {return _storage._resultType ?? Google_Api_Expr_V1alpha1_Type()}
      set {_uniqueStorage()._resultType = newValue}
    }
    /// Returns true if `resultType` has been explicitly set.
    public var hasResultType: Bool {return _storage._resultType != nil}
    /// Clears the value of `resultType`. Subsequent reads from it will return its default value.
    public mutating func clearResultType() {_uniqueStorage()._resultType = nil}

    /// Argument types of the function.
    public var argTypes: [Google_Api_Expr_V1alpha1_Type] {
      get {return _storage._argTypes}
      set {_uniqueStorage()._argTypes = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Application defined abstract type.
  public struct AbstractType {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The fully qualified name of this abstract type.
    public var name: String = String()

    /// Parameter types for this abstract type.
    public var parameterTypes: [Google_Api_Expr_V1alpha1_Type] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Google_Api_Expr_V1alpha1_Type.PrimitiveType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Api_Expr_V1alpha1_Type.PrimitiveType] = [
    .unspecified,
    .bool,
    .int64,
    .uint64,
    .double,
    .string,
    .bytes,
  ]
}

extension Google_Api_Expr_V1alpha1_Type.WellKnownType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Api_Expr_V1alpha1_Type.WellKnownType] = [
    .unspecified,
    .any,
    .timestamp,
    .duration,
  ]
}

#endif  // swift(>=4.2)

/// Represents a declaration of a named value or function.
///
/// A declaration is part of the contract between the expression, the agent
/// evaluating that expression, and the caller requesting evaluation.
public struct Google_Api_Expr_V1alpha1_Decl {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The fully qualified name of the declaration.
  ///
  /// Declarations are organized in containers and this represents the full path
  /// to the declaration in its container, as in `google.api.expr.Decl`.
  ///
  /// Declarations used as [FunctionDecl.Overload][google.api.expr.v1alpha1.Decl.FunctionDecl.Overload] parameters may or may not
  /// have a name depending on whether the overload is function declaration or a
  /// function definition containing a result [Expr][google.api.expr.v1alpha1.Expr].
  public var name: String = String()

  /// Required. The declaration kind.
  public var declKind: Google_Api_Expr_V1alpha1_Decl.OneOf_DeclKind? = nil

  /// Identifier declaration.
  public var ident: Google_Api_Expr_V1alpha1_Decl.IdentDecl {
    get {
      if case .ident(let v)? = declKind {return v}
      return Google_Api_Expr_V1alpha1_Decl.IdentDecl()
    }
    set {declKind = .ident(newValue)}
  }

  /// Function declaration.
  public var function: Google_Api_Expr_V1alpha1_Decl.FunctionDecl {
    get {
      if case .function(let v)? = declKind {return v}
      return Google_Api_Expr_V1alpha1_Decl.FunctionDecl()
    }
    set {declKind = .function(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required. The declaration kind.
  public enum OneOf_DeclKind: Equatable {
    /// Identifier declaration.
    case ident(Google_Api_Expr_V1alpha1_Decl.IdentDecl)
    /// Function declaration.
    case function(Google_Api_Expr_V1alpha1_Decl.FunctionDecl)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Api_Expr_V1alpha1_Decl.OneOf_DeclKind, rhs: Google_Api_Expr_V1alpha1_Decl.OneOf_DeclKind) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.ident, .ident): return {
        guard case .ident(let l) = lhs, case .ident(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.function, .function): return {
        guard case .function(let l) = lhs, case .function(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Identifier declaration which specifies its type and optional `Expr` value.
  ///
  /// An identifier without a value is a declaration that must be provided at
  /// evaluation time. An identifier with a value should resolve to a constant,
  /// but may be used in conjunction with other identifiers bound at evaluation
  /// time.
  public struct IdentDecl {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. The type of the identifier.
    public var type: Google_Api_Expr_V1alpha1_Type {
      get {return _type ?? Google_Api_Expr_V1alpha1_Type()}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    public var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    public mutating func clearType() {self._type = nil}

    /// The constant value of the identifier. If not specified, the identifier
    /// must be supplied at evaluation time.
    public var value: Google_Api_Expr_V1alpha1_Constant {
      get {return _value ?? Google_Api_Expr_V1alpha1_Constant()}
      set {_value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    public var hasValue: Bool {return self._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    public mutating func clearValue() {self._value = nil}

    /// Documentation string for the identifier.
    public var doc: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _type: Google_Api_Expr_V1alpha1_Type? = nil
    fileprivate var _value: Google_Api_Expr_V1alpha1_Constant? = nil
  }

  /// Function declaration specifies one or more overloads which indicate the
  /// function's parameter types and return type, and may optionally specify a
  /// function definition in terms of CEL expressions.
  ///
  /// Functions have no observable side-effects (there may be side-effects like
  /// logging which are not observable from CEL).
  public struct FunctionDecl {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. List of function overloads, must contain at least one overload.
    public var overloads: [Google_Api_Expr_V1alpha1_Decl.FunctionDecl.Overload] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// An overload indicates a function's parameter types and return type, and
    /// may optionally include a function body described in terms of [Expr][google.api.expr.v1alpha1.Expr]
    /// values.
    ///
    /// Functions overloads are declared in either a function or method
    /// call-style. For methods, the `params[0]` is the expected type of the
    /// target receiver.
    ///
    /// Overloads must have non-overlapping argument types after erasure of all
    /// parameterized type variables (similar as type erasure in Java).
    public struct Overload {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Required. Globally unique overload name of the function which reflects
      /// the function name and argument types.
      ///
      /// This will be used by a [Reference][google.api.expr.v1alpha1.Reference] to indicate the `overload_id` that
      /// was resolved for the function `name`.
      public var overloadID: String = String()

      /// List of function parameter [Type][google.api.expr.v1alpha1.Type] values.
      ///
      /// Param types are disjoint after generic type parameters have been
      /// replaced with the type `DYN`. Since the `DYN` type is compatible with
      /// any other type, this means that if `A` is a type parameter, the
      /// function types `int<A>` and `int<int>` are not disjoint. Likewise,
      /// `map<string, string>` is not disjoint from `map<K, V>`.
      ///
      /// When the `result_type` of a function is a generic type param, the
      /// type param name also appears as the `type` of on at least one params.
      public var params: [Google_Api_Expr_V1alpha1_Type] = []

      /// The type param names associated with the function declaration.
      ///
      /// For example, `function ex<K,V>(K key, map<K, V> map) : V` would yield
      /// the type params of `K, V`.
      public var typeParams: [String] = []

      /// Required. The result type of the function. For example, the operator
      /// `string.isEmpty()` would have `result_type` of `kind: BOOL`.
      public var resultType: Google_Api_Expr_V1alpha1_Type {
        get {return _resultType ?? Google_Api_Expr_V1alpha1_Type()}
        set {_resultType = newValue}
      }
      /// Returns true if `resultType` has been explicitly set.
      public var hasResultType: Bool {return self._resultType != nil}
      /// Clears the value of `resultType`. Subsequent reads from it will return its default value.
      public mutating func clearResultType() {self._resultType = nil}

      /// Whether the function is to be used in a method call-style `x.f(...)`
      /// of a function call-style `f(x, ...)`.
      ///
      /// For methods, the first parameter declaration, `params[0]` is the
      /// expected type of the target receiver.
      public var isInstanceFunction: Bool = false

      /// Documentation string for the overload.
      public var doc: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _resultType: Google_Api_Expr_V1alpha1_Type? = nil
    }

    public init() {}
  }

  public init() {}
}

/// Describes a resolved reference to a declaration.
public struct Google_Api_Expr_V1alpha1_Reference {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The fully qualified name of the declaration.
  public var name: String = String()

  /// For references to functions, this is a list of `Overload.overload_id`
  /// values which match according to typing rules.
  ///
  /// If the list has more than one element, overload resolution among the
  /// presented candidates must happen at runtime because of dynamic types. The
  /// type checker attempts to narrow down this list as much as possible.
  ///
  /// Empty if this is not a reference to a [Decl.FunctionDecl][google.api.expr.v1alpha1.Decl.FunctionDecl].
  public var overloadID: [String] = []

  /// For references to constants, this may contain the value of the
  /// constant if known at compile time.
  public var value: Google_Api_Expr_V1alpha1_Constant {
    get {return _value ?? Google_Api_Expr_V1alpha1_Constant()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _value: Google_Api_Expr_V1alpha1_Constant? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.api.expr.v1alpha1"

extension Google_Api_Expr_V1alpha1_CheckedExpr: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CheckedExpr"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "reference_map"),
    3: .standard(proto: "type_map"),
    5: .standard(proto: "source_info"),
    4: .same(proto: "expr"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt64,Google_Api_Expr_V1alpha1_Reference>.self, value: &self.referenceMap) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt64,Google_Api_Expr_V1alpha1_Type>.self, value: &self.typeMap) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._expr) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._sourceInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.referenceMap.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt64,Google_Api_Expr_V1alpha1_Reference>.self, value: self.referenceMap, fieldNumber: 2)
    }
    if !self.typeMap.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt64,Google_Api_Expr_V1alpha1_Type>.self, value: self.typeMap, fieldNumber: 3)
    }
    if let v = self._expr {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._sourceInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Api_Expr_V1alpha1_CheckedExpr, rhs: Google_Api_Expr_V1alpha1_CheckedExpr) -> Bool {
    if lhs.referenceMap != rhs.referenceMap {return false}
    if lhs.typeMap != rhs.typeMap {return false}
    if lhs._sourceInfo != rhs._sourceInfo {return false}
    if lhs._expr != rhs._expr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Api_Expr_V1alpha1_Type: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Type"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dyn"),
    2: .same(proto: "null"),
    3: .same(proto: "primitive"),
    4: .same(proto: "wrapper"),
    5: .standard(proto: "well_known"),
    6: .standard(proto: "list_type"),
    7: .standard(proto: "map_type"),
    8: .same(proto: "function"),
    9: .standard(proto: "message_type"),
    10: .standard(proto: "type_param"),
    11: .same(proto: "type"),
    12: .same(proto: "error"),
    14: .standard(proto: "abstract_type"),
  ]

  fileprivate class _StorageClass {
    var _typeKind: Google_Api_Expr_V1alpha1_Type.OneOf_TypeKind?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _typeKind = source._typeKind
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try {
          var v: SwiftProtobuf.Google_Protobuf_Empty?
          if let current = _storage._typeKind {
            try decoder.handleConflictingOneOf()
            if case .dyn(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._typeKind = .dyn(v)}
        }()
        case 2: try {
          if _storage._typeKind != nil {try decoder.handleConflictingOneOf()}
          var v: SwiftProtobuf.Google_Protobuf_NullValue?
          try decoder.decodeSingularEnumField(value: &v)
          if let v = v {_storage._typeKind = .null(v)}
        }()
        case 3: try {
          if _storage._typeKind != nil {try decoder.handleConflictingOneOf()}
          var v: Google_Api_Expr_V1alpha1_Type.PrimitiveType?
          try decoder.decodeSingularEnumField(value: &v)
          if let v = v {_storage._typeKind = .primitive(v)}
        }()
        case 4: try {
          if _storage._typeKind != nil {try decoder.handleConflictingOneOf()}
          var v: Google_Api_Expr_V1alpha1_Type.PrimitiveType?
          try decoder.decodeSingularEnumField(value: &v)
          if let v = v {_storage._typeKind = .wrapper(v)}
        }()
        case 5: try {
          if _storage._typeKind != nil {try decoder.handleConflictingOneOf()}
          var v: Google_Api_Expr_V1alpha1_Type.WellKnownType?
          try decoder.decodeSingularEnumField(value: &v)
          if let v = v {_storage._typeKind = .wellKnown(v)}
        }()
        case 6: try {
          var v: Google_Api_Expr_V1alpha1_Type.ListType?
          if let current = _storage._typeKind {
            try decoder.handleConflictingOneOf()
            if case .listType(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._typeKind = .listType(v)}
        }()
        case 7: try {
          var v: Google_Api_Expr_V1alpha1_Type.MapType?
          if let current = _storage._typeKind {
            try decoder.handleConflictingOneOf()
            if case .mapType(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._typeKind = .mapType(v)}
        }()
        case 8: try {
          var v: Google_Api_Expr_V1alpha1_Type.FunctionType?
          if let current = _storage._typeKind {
            try decoder.handleConflictingOneOf()
            if case .function(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._typeKind = .function(v)}
        }()
        case 9: try {
          if _storage._typeKind != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._typeKind = .messageType(v)}
        }()
        case 10: try {
          if _storage._typeKind != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._typeKind = .typeParam(v)}
        }()
        case 11: try {
          var v: Google_Api_Expr_V1alpha1_Type?
          if let current = _storage._typeKind {
            try decoder.handleConflictingOneOf()
            if case .type(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._typeKind = .type(v)}
        }()
        case 12: try {
          var v: SwiftProtobuf.Google_Protobuf_Empty?
          if let current = _storage._typeKind {
            try decoder.handleConflictingOneOf()
            if case .error(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._typeKind = .error(v)}
        }()
        case 14: try {
          var v: Google_Api_Expr_V1alpha1_Type.AbstractType?
          if let current = _storage._typeKind {
            try decoder.handleConflictingOneOf()
            if case .abstractType(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._typeKind = .abstractType(v)}
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._typeKind {
      case .dyn?: try {
        guard case .dyn(let v)? = _storage._typeKind else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }()
      case .null?: try {
        guard case .null(let v)? = _storage._typeKind else { preconditionFailure() }
        try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
      }()
      case .primitive?: try {
        guard case .primitive(let v)? = _storage._typeKind else { preconditionFailure() }
        try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
      }()
      case .wrapper?: try {
        guard case .wrapper(let v)? = _storage._typeKind else { preconditionFailure() }
        try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
      }()
      case .wellKnown?: try {
        guard case .wellKnown(let v)? = _storage._typeKind else { preconditionFailure() }
        try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
      }()
      case .listType?: try {
        guard case .listType(let v)? = _storage._typeKind else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .mapType?: try {
        guard case .mapType(let v)? = _storage._typeKind else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .function?: try {
        guard case .function(let v)? = _storage._typeKind else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .messageType?: try {
        guard case .messageType(let v)? = _storage._typeKind else { preconditionFailure() }
        try visitor.visitSingularStringField(value: v, fieldNumber: 9)
      }()
      case .typeParam?: try {
        guard case .typeParam(let v)? = _storage._typeKind else { preconditionFailure() }
        try visitor.visitSingularStringField(value: v, fieldNumber: 10)
      }()
      case .type?: try {
        guard case .type(let v)? = _storage._typeKind else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      case .error?: try {
        guard case .error(let v)? = _storage._typeKind else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }()
      case .abstractType?: try {
        guard case .abstractType(let v)? = _storage._typeKind else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Api_Expr_V1alpha1_Type, rhs: Google_Api_Expr_V1alpha1_Type) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._typeKind != rhs_storage._typeKind {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Api_Expr_V1alpha1_Type.PrimitiveType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PRIMITIVE_TYPE_UNSPECIFIED"),
    1: .same(proto: "BOOL"),
    2: .same(proto: "INT64"),
    3: .same(proto: "UINT64"),
    4: .same(proto: "DOUBLE"),
    5: .same(proto: "STRING"),
    6: .same(proto: "BYTES"),
  ]
}

extension Google_Api_Expr_V1alpha1_Type.WellKnownType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WELL_KNOWN_TYPE_UNSPECIFIED"),
    1: .same(proto: "ANY"),
    2: .same(proto: "TIMESTAMP"),
    3: .same(proto: "DURATION"),
  ]
}

extension Google_Api_Expr_V1alpha1_Type.ListType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Api_Expr_V1alpha1_Type.protoMessageName + ".ListType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "elem_type"),
  ]

  fileprivate class _StorageClass {
    var _elemType: Google_Api_Expr_V1alpha1_Type? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _elemType = source._elemType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._elemType) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._elemType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Api_Expr_V1alpha1_Type.ListType, rhs: Google_Api_Expr_V1alpha1_Type.ListType) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._elemType != rhs_storage._elemType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Api_Expr_V1alpha1_Type.MapType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Api_Expr_V1alpha1_Type.protoMessageName + ".MapType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_type"),
    2: .standard(proto: "value_type"),
  ]

  fileprivate class _StorageClass {
    var _keyType: Google_Api_Expr_V1alpha1_Type? = nil
    var _valueType: Google_Api_Expr_V1alpha1_Type? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _keyType = source._keyType
      _valueType = source._valueType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._keyType) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._valueType) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._keyType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._valueType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Api_Expr_V1alpha1_Type.MapType, rhs: Google_Api_Expr_V1alpha1_Type.MapType) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._keyType != rhs_storage._keyType {return false}
        if _storage._valueType != rhs_storage._valueType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Api_Expr_V1alpha1_Type.FunctionType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Api_Expr_V1alpha1_Type.protoMessageName + ".FunctionType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "result_type"),
    2: .standard(proto: "arg_types"),
  ]

  fileprivate class _StorageClass {
    var _resultType: Google_Api_Expr_V1alpha1_Type? = nil
    var _argTypes: [Google_Api_Expr_V1alpha1_Type] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _resultType = source._resultType
      _argTypes = source._argTypes
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._resultType) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._argTypes) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._resultType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._argTypes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._argTypes, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Api_Expr_V1alpha1_Type.FunctionType, rhs: Google_Api_Expr_V1alpha1_Type.FunctionType) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._resultType != rhs_storage._resultType {return false}
        if _storage._argTypes != rhs_storage._argTypes {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Api_Expr_V1alpha1_Type.AbstractType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Api_Expr_V1alpha1_Type.protoMessageName + ".AbstractType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "parameter_types"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.parameterTypes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.parameterTypes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.parameterTypes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Api_Expr_V1alpha1_Type.AbstractType, rhs: Google_Api_Expr_V1alpha1_Type.AbstractType) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.parameterTypes != rhs.parameterTypes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Api_Expr_V1alpha1_Decl: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Decl"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "ident"),
    3: .same(proto: "function"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try {
        var v: Google_Api_Expr_V1alpha1_Decl.IdentDecl?
        if let current = self.declKind {
          try decoder.handleConflictingOneOf()
          if case .ident(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.declKind = .ident(v)}
      }()
      case 3: try {
        var v: Google_Api_Expr_V1alpha1_Decl.FunctionDecl?
        if let current = self.declKind {
          try decoder.handleConflictingOneOf()
          if case .function(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.declKind = .function(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.declKind {
    case .ident?: try {
      guard case .ident(let v)? = self.declKind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .function?: try {
      guard case .function(let v)? = self.declKind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Api_Expr_V1alpha1_Decl, rhs: Google_Api_Expr_V1alpha1_Decl) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.declKind != rhs.declKind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Api_Expr_V1alpha1_Decl.IdentDecl: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Api_Expr_V1alpha1_Decl.protoMessageName + ".IdentDecl"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "value"),
    3: .same(proto: "doc"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.doc) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._type {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.doc.isEmpty {
      try visitor.visitSingularStringField(value: self.doc, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Api_Expr_V1alpha1_Decl.IdentDecl, rhs: Google_Api_Expr_V1alpha1_Decl.IdentDecl) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._value != rhs._value {return false}
    if lhs.doc != rhs.doc {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Api_Expr_V1alpha1_Decl.FunctionDecl: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Api_Expr_V1alpha1_Decl.protoMessageName + ".FunctionDecl"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "overloads"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.overloads) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.overloads.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.overloads, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Api_Expr_V1alpha1_Decl.FunctionDecl, rhs: Google_Api_Expr_V1alpha1_Decl.FunctionDecl) -> Bool {
    if lhs.overloads != rhs.overloads {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Api_Expr_V1alpha1_Decl.FunctionDecl.Overload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Api_Expr_V1alpha1_Decl.FunctionDecl.protoMessageName + ".Overload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "overload_id"),
    2: .same(proto: "params"),
    3: .standard(proto: "type_params"),
    4: .standard(proto: "result_type"),
    5: .standard(proto: "is_instance_function"),
    6: .same(proto: "doc"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.overloadID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.params) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.typeParams) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._resultType) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isInstanceFunction) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.doc) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.overloadID.isEmpty {
      try visitor.visitSingularStringField(value: self.overloadID, fieldNumber: 1)
    }
    if !self.params.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.params, fieldNumber: 2)
    }
    if !self.typeParams.isEmpty {
      try visitor.visitRepeatedStringField(value: self.typeParams, fieldNumber: 3)
    }
    if let v = self._resultType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if self.isInstanceFunction != false {
      try visitor.visitSingularBoolField(value: self.isInstanceFunction, fieldNumber: 5)
    }
    if !self.doc.isEmpty {
      try visitor.visitSingularStringField(value: self.doc, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Api_Expr_V1alpha1_Decl.FunctionDecl.Overload, rhs: Google_Api_Expr_V1alpha1_Decl.FunctionDecl.Overload) -> Bool {
    if lhs.overloadID != rhs.overloadID {return false}
    if lhs.params != rhs.params {return false}
    if lhs.typeParams != rhs.typeParams {return false}
    if lhs._resultType != rhs._resultType {return false}
    if lhs.isInstanceFunction != rhs.isInstanceFunction {return false}
    if lhs.doc != rhs.doc {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Api_Expr_V1alpha1_Reference: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Reference"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    3: .standard(proto: "overload_id"),
    4: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.overloadID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.overloadID.isEmpty {
      try visitor.visitRepeatedStringField(value: self.overloadID, fieldNumber: 3)
    }
    if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Api_Expr_V1alpha1_Reference, rhs: Google_Api_Expr_V1alpha1_Reference) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.overloadID != rhs.overloadID {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

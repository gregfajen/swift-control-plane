// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/api/expr/v1beta1/expr.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// An expression together with source information as returned by the parser.
public struct Google_Api_Expr_V1beta1_ParsedExpr {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The parsed expression.
  public var expr: Google_Api_Expr_V1beta1_Expr {
    get {return _expr ?? Google_Api_Expr_V1beta1_Expr()}
    set {_expr = newValue}
  }
  /// Returns true if `expr` has been explicitly set.
  public var hasExpr: Bool {return self._expr != nil}
  /// Clears the value of `expr`. Subsequent reads from it will return its default value.
  public mutating func clearExpr() {self._expr = nil}

  /// The source info derived from input that generated the parsed `expr`.
  public var sourceInfo: Google_Api_Expr_V1beta1_SourceInfo {
    get {return _sourceInfo ?? Google_Api_Expr_V1beta1_SourceInfo()}
    set {_sourceInfo = newValue}
  }
  /// Returns true if `sourceInfo` has been explicitly set.
  public var hasSourceInfo: Bool {return self._sourceInfo != nil}
  /// Clears the value of `sourceInfo`. Subsequent reads from it will return its default value.
  public mutating func clearSourceInfo() {self._sourceInfo = nil}

  /// The syntax version of the source, e.g. `cel1`.
  public var syntaxVersion: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _expr: Google_Api_Expr_V1beta1_Expr? = nil
  fileprivate var _sourceInfo: Google_Api_Expr_V1beta1_SourceInfo? = nil
}

/// An abstract representation of a common expression.
///
/// Expressions are abstractly represented as a collection of identifiers,
/// select statements, function calls, literals, and comprehensions. All
/// operators with the exception of the '.' operator are modelled as function
/// calls. This makes it easy to represent new operators into the existing AST.
///
/// All references within expressions must resolve to a [Decl][google.api.expr.v1beta1.Decl] provided at
/// type-check for an expression to be valid. A reference may either be a bare
/// identifier `name` or a qualified identifier `google.api.name`. References
/// may either refer to a value or a function declaration.
///
/// For example, the expression `google.api.name.startsWith('expr')` references
/// the declaration `google.api.name` within a [Expr.Select][google.api.expr.v1beta1.Expr.Select] expression, and
/// the function declaration `startsWith`.
public struct Google_Api_Expr_V1beta1_Expr {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. An id assigned to this node by the parser which is unique in a
  /// given expression tree. This is used to associate type information and other
  /// attributes to a node in the parse tree.
  public var id: Int32 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// Required. Variants of expressions.
  public var exprKind: OneOf_ExprKind? {
    get {return _storage._exprKind}
    set {_uniqueStorage()._exprKind = newValue}
  }

  /// A literal expression.
  public var literalExpr: Google_Api_Expr_V1beta1_Literal {
    get {
      if case .literalExpr(let v)? = _storage._exprKind {return v}
      return Google_Api_Expr_V1beta1_Literal()
    }
    set {_uniqueStorage()._exprKind = .literalExpr(newValue)}
  }

  /// An identifier expression.
  public var identExpr: Google_Api_Expr_V1beta1_Expr.Ident {
    get {
      if case .identExpr(let v)? = _storage._exprKind {return v}
      return Google_Api_Expr_V1beta1_Expr.Ident()
    }
    set {_uniqueStorage()._exprKind = .identExpr(newValue)}
  }

  /// A field selection expression, e.g. `request.auth`.
  public var selectExpr: Google_Api_Expr_V1beta1_Expr.Select {
    get {
      if case .selectExpr(let v)? = _storage._exprKind {return v}
      return Google_Api_Expr_V1beta1_Expr.Select()
    }
    set {_uniqueStorage()._exprKind = .selectExpr(newValue)}
  }

  /// A call expression, including calls to predefined functions and operators.
  public var callExpr: Google_Api_Expr_V1beta1_Expr.Call {
    get {
      if case .callExpr(let v)? = _storage._exprKind {return v}
      return Google_Api_Expr_V1beta1_Expr.Call()
    }
    set {_uniqueStorage()._exprKind = .callExpr(newValue)}
  }

  /// A list creation expression.
  public var listExpr: Google_Api_Expr_V1beta1_Expr.CreateList {
    get {
      if case .listExpr(let v)? = _storage._exprKind {return v}
      return Google_Api_Expr_V1beta1_Expr.CreateList()
    }
    set {_uniqueStorage()._exprKind = .listExpr(newValue)}
  }

  /// A map or object creation expression.
  public var structExpr: Google_Api_Expr_V1beta1_Expr.CreateStruct {
    get {
      if case .structExpr(let v)? = _storage._exprKind {return v}
      return Google_Api_Expr_V1beta1_Expr.CreateStruct()
    }
    set {_uniqueStorage()._exprKind = .structExpr(newValue)}
  }

  /// A comprehension expression.
  public var comprehensionExpr: Google_Api_Expr_V1beta1_Expr.Comprehension {
    get {
      if case .comprehensionExpr(let v)? = _storage._exprKind {return v}
      return Google_Api_Expr_V1beta1_Expr.Comprehension()
    }
    set {_uniqueStorage()._exprKind = .comprehensionExpr(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required. Variants of expressions.
  public enum OneOf_ExprKind: Equatable {
    /// A literal expression.
    case literalExpr(Google_Api_Expr_V1beta1_Literal)
    /// An identifier expression.
    case identExpr(Google_Api_Expr_V1beta1_Expr.Ident)
    /// A field selection expression, e.g. `request.auth`.
    case selectExpr(Google_Api_Expr_V1beta1_Expr.Select)
    /// A call expression, including calls to predefined functions and operators.
    case callExpr(Google_Api_Expr_V1beta1_Expr.Call)
    /// A list creation expression.
    case listExpr(Google_Api_Expr_V1beta1_Expr.CreateList)
    /// A map or object creation expression.
    case structExpr(Google_Api_Expr_V1beta1_Expr.CreateStruct)
    /// A comprehension expression.
    case comprehensionExpr(Google_Api_Expr_V1beta1_Expr.Comprehension)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Api_Expr_V1beta1_Expr.OneOf_ExprKind, rhs: Google_Api_Expr_V1beta1_Expr.OneOf_ExprKind) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.literalExpr, .literalExpr): return {
        guard case .literalExpr(let l) = lhs, case .literalExpr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.identExpr, .identExpr): return {
        guard case .identExpr(let l) = lhs, case .identExpr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.selectExpr, .selectExpr): return {
        guard case .selectExpr(let l) = lhs, case .selectExpr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.callExpr, .callExpr): return {
        guard case .callExpr(let l) = lhs, case .callExpr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.listExpr, .listExpr): return {
        guard case .listExpr(let l) = lhs, case .listExpr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.structExpr, .structExpr): return {
        guard case .structExpr(let l) = lhs, case .structExpr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.comprehensionExpr, .comprehensionExpr): return {
        guard case .comprehensionExpr(let l) = lhs, case .comprehensionExpr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// An identifier expression. e.g. `request`.
  public struct Ident {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. Holds a single, unqualified identifier, possibly preceded by a
    /// '.'.
    ///
    /// Qualified names are represented by the [Expr.Select][google.api.expr.v1beta1.Expr.Select] expression.
    public var name: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// A field selection expression. e.g. `request.auth`.
  public struct Select {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. The target of the selection expression.
    ///
    /// For example, in the select expression `request.auth`, the `request`
    /// portion of the expression is the `operand`.
    public var operand: Google_Api_Expr_V1beta1_Expr {
      get {return _storage._operand ?? Google_Api_Expr_V1beta1_Expr()}
      set {_uniqueStorage()._operand = newValue}
    }
    /// Returns true if `operand` has been explicitly set.
    public var hasOperand: Bool {return _storage._operand != nil}
    /// Clears the value of `operand`. Subsequent reads from it will return its default value.
    public mutating func clearOperand() {_uniqueStorage()._operand = nil}

    /// Required. The name of the field to select.
    ///
    /// For example, in the select expression `request.auth`, the `auth` portion
    /// of the expression would be the `field`.
    public var field: String {
      get {return _storage._field}
      set {_uniqueStorage()._field = newValue}
    }

    /// Whether the select is to be interpreted as a field presence test.
    ///
    /// This results from the macro `has(request.auth)`.
    public var testOnly: Bool {
      get {return _storage._testOnly}
      set {_uniqueStorage()._testOnly = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// A call expression, including calls to predefined functions and operators.
  ///
  /// For example, `value == 10`, `size(map_value)`.
  public struct Call {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The target of an method call-style expression. For example, `x` in
    /// `x.f()`.
    public var target: Google_Api_Expr_V1beta1_Expr {
      get {return _storage._target ?? Google_Api_Expr_V1beta1_Expr()}
      set {_uniqueStorage()._target = newValue}
    }
    /// Returns true if `target` has been explicitly set.
    public var hasTarget: Bool {return _storage._target != nil}
    /// Clears the value of `target`. Subsequent reads from it will return its default value.
    public mutating func clearTarget() {_uniqueStorage()._target = nil}

    /// Required. The name of the function or method being called.
    public var function: String {
      get {return _storage._function}
      set {_uniqueStorage()._function = newValue}
    }

    /// The arguments.
    public var args: [Google_Api_Expr_V1beta1_Expr] {
      get {return _storage._args}
      set {_uniqueStorage()._args = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// A list creation expression.
  ///
  /// Lists may either be homogenous, e.g. `[1, 2, 3]`, or heterogenous, e.g.
  /// `dyn([1, 'hello', 2.0])`
  public struct CreateList {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The elements part of the list.
    public var elements: [Google_Api_Expr_V1beta1_Expr] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// A map or message creation expression.
  ///
  /// Maps are constructed as `{'key_name': 'value'}`. Message construction is
  /// similar, but prefixed with a type name and composed of field ids:
  /// `types.MyType{field_id: 'value'}`.
  public struct CreateStruct {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The type name of the message to be created, empty when creating map
    /// literals.
    public var type: String = String()

    /// The entries in the creation expression.
    public var entries: [Google_Api_Expr_V1beta1_Expr.CreateStruct.Entry] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Represents an entry.
    public struct Entry {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Required. An id assigned to this node by the parser which is unique
      /// in a given expression tree. This is used to associate type
      /// information and other attributes to the node.
      public var id: Int32 = 0

      /// The `Entry` key kinds.
      public var keyKind: Google_Api_Expr_V1beta1_Expr.CreateStruct.Entry.OneOf_KeyKind? = nil

      /// The field key for a message creator statement.
      public var fieldKey: String {
        get {
          if case .fieldKey(let v)? = keyKind {return v}
          return String()
        }
        set {keyKind = .fieldKey(newValue)}
      }

      /// The key expression for a map creation statement.
      public var mapKey: Google_Api_Expr_V1beta1_Expr {
        get {
          if case .mapKey(let v)? = keyKind {return v}
          return Google_Api_Expr_V1beta1_Expr()
        }
        set {keyKind = .mapKey(newValue)}
      }

      /// Required. The value assigned to the key.
      public var value: Google_Api_Expr_V1beta1_Expr {
        get {return _value ?? Google_Api_Expr_V1beta1_Expr()}
        set {_value = newValue}
      }
      /// Returns true if `value` has been explicitly set.
      public var hasValue: Bool {return self._value != nil}
      /// Clears the value of `value`. Subsequent reads from it will return its default value.
      public mutating func clearValue() {self._value = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      /// The `Entry` key kinds.
      public enum OneOf_KeyKind: Equatable {
        /// The field key for a message creator statement.
        case fieldKey(String)
        /// The key expression for a map creation statement.
        case mapKey(Google_Api_Expr_V1beta1_Expr)

      #if !swift(>=4.1)
        public static func ==(lhs: Google_Api_Expr_V1beta1_Expr.CreateStruct.Entry.OneOf_KeyKind, rhs: Google_Api_Expr_V1beta1_Expr.CreateStruct.Entry.OneOf_KeyKind) -> Bool {
          // The use of inline closures is to circumvent an issue where the compiler
          // allocates stack space for every case branch when no optimizations are
          // enabled. https://github.com/apple/swift-protobuf/issues/1034
          switch (lhs, rhs) {
          case (.fieldKey, .fieldKey): return {
            guard case .fieldKey(let l) = lhs, case .fieldKey(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.mapKey, .mapKey): return {
            guard case .mapKey(let l) = lhs, case .mapKey(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          default: return false
          }
        }
      #endif
      }

      public init() {}

      fileprivate var _value: Google_Api_Expr_V1beta1_Expr? = nil
    }

    public init() {}
  }

  /// A comprehension expression applied to a list or map.
  ///
  /// Comprehensions are not part of the core syntax, but enabled with macros.
  /// A macro matches a specific call signature within a parsed AST and replaces
  /// the call with an alternate AST block. Macro expansion happens at parse
  /// time.
  ///
  /// The following macros are supported within CEL:
  ///
  /// Aggregate type macros may be applied to all elements in a list or all keys
  /// in a map:
  ///
  /// *  `all`, `exists`, `exists_one` -  test a predicate expression against
  ///    the inputs and return `true` if the predicate is satisfied for all,
  ///    any, or only one value `list.all(x, x < 10)`.
  /// *  `filter` - test a predicate expression against the inputs and return
  ///    the subset of elements which satisfy the predicate:
  ///    `payments.filter(p, p > 1000)`.
  /// *  `map` - apply an expression to all elements in the input and return the
  ///    output aggregate type: `[1, 2, 3].map(i, i * i)`.
  ///
  /// The `has(m.x)` macro tests whether the property `x` is present in struct
  /// `m`. The semantics of this macro depend on the type of `m`. For proto2
  /// messages `has(m.x)` is defined as 'defined, but not set`. For proto3, the
  /// macro tests whether the property is set to its default. For map and struct
  /// types, the macro tests whether the property `x` is defined on `m`.
  public struct Comprehension {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The name of the iteration variable.
    public var iterVar: String {
      get {return _storage._iterVar}
      set {_uniqueStorage()._iterVar = newValue}
    }

    /// The range over which var iterates.
    public var iterRange: Google_Api_Expr_V1beta1_Expr {
      get {return _storage._iterRange ?? Google_Api_Expr_V1beta1_Expr()}
      set {_uniqueStorage()._iterRange = newValue}
    }
    /// Returns true if `iterRange` has been explicitly set.
    public var hasIterRange: Bool {return _storage._iterRange != nil}
    /// Clears the value of `iterRange`. Subsequent reads from it will return its default value.
    public mutating func clearIterRange() {_uniqueStorage()._iterRange = nil}

    /// The name of the variable used for accumulation of the result.
    public var accuVar: String {
      get {return _storage._accuVar}
      set {_uniqueStorage()._accuVar = newValue}
    }

    /// The initial value of the accumulator.
    public var accuInit: Google_Api_Expr_V1beta1_Expr {
      get {return _storage._accuInit ?? Google_Api_Expr_V1beta1_Expr()}
      set {_uniqueStorage()._accuInit = newValue}
    }
    /// Returns true if `accuInit` has been explicitly set.
    public var hasAccuInit: Bool {return _storage._accuInit != nil}
    /// Clears the value of `accuInit`. Subsequent reads from it will return its default value.
    public mutating func clearAccuInit() {_uniqueStorage()._accuInit = nil}

    /// An expression which can contain iter_var and accu_var.
    ///
    /// Returns false when the result has been computed and may be used as
    /// a hint to short-circuit the remainder of the comprehension.
    public var loopCondition: Google_Api_Expr_V1beta1_Expr {
      get {return _storage._loopCondition ?? Google_Api_Expr_V1beta1_Expr()}
      set {_uniqueStorage()._loopCondition = newValue}
    }
    /// Returns true if `loopCondition` has been explicitly set.
    public var hasLoopCondition: Bool {return _storage._loopCondition != nil}
    /// Clears the value of `loopCondition`. Subsequent reads from it will return its default value.
    public mutating func clearLoopCondition() {_uniqueStorage()._loopCondition = nil}

    /// An expression which can contain iter_var and accu_var.
    ///
    /// Computes the next value of accu_var.
    public var loopStep: Google_Api_Expr_V1beta1_Expr {
      get {return _storage._loopStep ?? Google_Api_Expr_V1beta1_Expr()}
      set {_uniqueStorage()._loopStep = newValue}
    }
    /// Returns true if `loopStep` has been explicitly set.
    public var hasLoopStep: Bool {return _storage._loopStep != nil}
    /// Clears the value of `loopStep`. Subsequent reads from it will return its default value.
    public mutating func clearLoopStep() {_uniqueStorage()._loopStep = nil}

    /// An expression which can contain accu_var.
    ///
    /// Computes the result.
    public var result: Google_Api_Expr_V1beta1_Expr {
      get {return _storage._result ?? Google_Api_Expr_V1beta1_Expr()}
      set {_uniqueStorage()._result = newValue}
    }
    /// Returns true if `result` has been explicitly set.
    public var hasResult: Bool {return _storage._result != nil}
    /// Clears the value of `result`. Subsequent reads from it will return its default value.
    public mutating func clearResult() {_uniqueStorage()._result = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Represents a primitive literal.
///
/// This is similar to the primitives supported in the well-known type
/// `google.protobuf.Value`, but richer so it can represent CEL's full range of
/// primitives.
///
/// Lists and structs are not included as constants as these aggregate types may
/// contain [Expr][google.api.expr.v1beta1.Expr] elements which require evaluation and are thus not constant.
///
/// Examples of literals include: `"hello"`, `b'bytes'`, `1u`, `4.2`, `-2`,
/// `true`, `null`.
public struct Google_Api_Expr_V1beta1_Literal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The valid constant kinds.
  public var constantKind: Google_Api_Expr_V1beta1_Literal.OneOf_ConstantKind? = nil

  /// null value.
  public var nullValue: SwiftProtobuf.Google_Protobuf_NullValue {
    get {
      if case .nullValue(let v)? = constantKind {return v}
      return .nullValue
    }
    set {constantKind = .nullValue(newValue)}
  }

  /// boolean value.
  public var boolValue: Bool {
    get {
      if case .boolValue(let v)? = constantKind {return v}
      return false
    }
    set {constantKind = .boolValue(newValue)}
  }

  /// int64 value.
  public var int64Value: Int64 {
    get {
      if case .int64Value(let v)? = constantKind {return v}
      return 0
    }
    set {constantKind = .int64Value(newValue)}
  }

  /// uint64 value.
  public var uint64Value: UInt64 {
    get {
      if case .uint64Value(let v)? = constantKind {return v}
      return 0
    }
    set {constantKind = .uint64Value(newValue)}
  }

  /// double value.
  public var doubleValue: Double {
    get {
      if case .doubleValue(let v)? = constantKind {return v}
      return 0
    }
    set {constantKind = .doubleValue(newValue)}
  }

  /// string value.
  public var stringValue: String {
    get {
      if case .stringValue(let v)? = constantKind {return v}
      return String()
    }
    set {constantKind = .stringValue(newValue)}
  }

  /// bytes value.
  public var bytesValue: Data {
    get {
      if case .bytesValue(let v)? = constantKind {return v}
      return Data()
    }
    set {constantKind = .bytesValue(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required. The valid constant kinds.
  public enum OneOf_ConstantKind: Equatable {
    /// null value.
    case nullValue(SwiftProtobuf.Google_Protobuf_NullValue)
    /// boolean value.
    case boolValue(Bool)
    /// int64 value.
    case int64Value(Int64)
    /// uint64 value.
    case uint64Value(UInt64)
    /// double value.
    case doubleValue(Double)
    /// string value.
    case stringValue(String)
    /// bytes value.
    case bytesValue(Data)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Api_Expr_V1beta1_Literal.OneOf_ConstantKind, rhs: Google_Api_Expr_V1beta1_Literal.OneOf_ConstantKind) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.nullValue, .nullValue): return {
        guard case .nullValue(let l) = lhs, case .nullValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.boolValue, .boolValue): return {
        guard case .boolValue(let l) = lhs, case .boolValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.int64Value, .int64Value): return {
        guard case .int64Value(let l) = lhs, case .int64Value(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uint64Value, .uint64Value): return {
        guard case .uint64Value(let l) = lhs, case .uint64Value(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.doubleValue, .doubleValue): return {
        guard case .doubleValue(let l) = lhs, case .doubleValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stringValue, .stringValue): return {
        guard case .stringValue(let l) = lhs, case .stringValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bytesValue, .bytesValue): return {
        guard case .bytesValue(let l) = lhs, case .bytesValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.api.expr.v1beta1"

extension Google_Api_Expr_V1beta1_ParsedExpr: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ParsedExpr"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "expr"),
    3: .standard(proto: "source_info"),
    4: .standard(proto: "syntax_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._expr) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._sourceInfo) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.syntaxVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._expr {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._sourceInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.syntaxVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.syntaxVersion, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Api_Expr_V1beta1_ParsedExpr, rhs: Google_Api_Expr_V1beta1_ParsedExpr) -> Bool {
    if lhs._expr != rhs._expr {return false}
    if lhs._sourceInfo != rhs._sourceInfo {return false}
    if lhs.syntaxVersion != rhs.syntaxVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Api_Expr_V1beta1_Expr: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Expr"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "id"),
    3: .standard(proto: "literal_expr"),
    4: .standard(proto: "ident_expr"),
    5: .standard(proto: "select_expr"),
    6: .standard(proto: "call_expr"),
    7: .standard(proto: "list_expr"),
    8: .standard(proto: "struct_expr"),
    9: .standard(proto: "comprehension_expr"),
  ]

  fileprivate class _StorageClass {
    var _id: Int32 = 0
    var _exprKind: Google_Api_Expr_V1beta1_Expr.OneOf_ExprKind?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _exprKind = source._exprKind
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._id) }()
        case 3: try {
          var v: Google_Api_Expr_V1beta1_Literal?
          if let current = _storage._exprKind {
            try decoder.handleConflictingOneOf()
            if case .literalExpr(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._exprKind = .literalExpr(v)}
        }()
        case 4: try {
          var v: Google_Api_Expr_V1beta1_Expr.Ident?
          if let current = _storage._exprKind {
            try decoder.handleConflictingOneOf()
            if case .identExpr(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._exprKind = .identExpr(v)}
        }()
        case 5: try {
          var v: Google_Api_Expr_V1beta1_Expr.Select?
          if let current = _storage._exprKind {
            try decoder.handleConflictingOneOf()
            if case .selectExpr(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._exprKind = .selectExpr(v)}
        }()
        case 6: try {
          var v: Google_Api_Expr_V1beta1_Expr.Call?
          if let current = _storage._exprKind {
            try decoder.handleConflictingOneOf()
            if case .callExpr(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._exprKind = .callExpr(v)}
        }()
        case 7: try {
          var v: Google_Api_Expr_V1beta1_Expr.CreateList?
          if let current = _storage._exprKind {
            try decoder.handleConflictingOneOf()
            if case .listExpr(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._exprKind = .listExpr(v)}
        }()
        case 8: try {
          var v: Google_Api_Expr_V1beta1_Expr.CreateStruct?
          if let current = _storage._exprKind {
            try decoder.handleConflictingOneOf()
            if case .structExpr(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._exprKind = .structExpr(v)}
        }()
        case 9: try {
          var v: Google_Api_Expr_V1beta1_Expr.Comprehension?
          if let current = _storage._exprKind {
            try decoder.handleConflictingOneOf()
            if case .comprehensionExpr(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._exprKind = .comprehensionExpr(v)}
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._id != 0 {
        try visitor.visitSingularInt32Field(value: _storage._id, fieldNumber: 2)
      }
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._exprKind {
      case .literalExpr?: try {
        guard case .literalExpr(let v)? = _storage._exprKind else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case .identExpr?: try {
        guard case .identExpr(let v)? = _storage._exprKind else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .selectExpr?: try {
        guard case .selectExpr(let v)? = _storage._exprKind else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .callExpr?: try {
        guard case .callExpr(let v)? = _storage._exprKind else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .listExpr?: try {
        guard case .listExpr(let v)? = _storage._exprKind else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .structExpr?: try {
        guard case .structExpr(let v)? = _storage._exprKind else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .comprehensionExpr?: try {
        guard case .comprehensionExpr(let v)? = _storage._exprKind else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Api_Expr_V1beta1_Expr, rhs: Google_Api_Expr_V1beta1_Expr) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._exprKind != rhs_storage._exprKind {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Api_Expr_V1beta1_Expr.Ident: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Api_Expr_V1beta1_Expr.protoMessageName + ".Ident"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Api_Expr_V1beta1_Expr.Ident, rhs: Google_Api_Expr_V1beta1_Expr.Ident) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Api_Expr_V1beta1_Expr.Select: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Api_Expr_V1beta1_Expr.protoMessageName + ".Select"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operand"),
    2: .same(proto: "field"),
    3: .standard(proto: "test_only"),
  ]

  fileprivate class _StorageClass {
    var _operand: Google_Api_Expr_V1beta1_Expr? = nil
    var _field: String = String()
    var _testOnly: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _operand = source._operand
      _field = source._field
      _testOnly = source._testOnly
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._operand) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._field) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._testOnly) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._operand {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._field.isEmpty {
        try visitor.visitSingularStringField(value: _storage._field, fieldNumber: 2)
      }
      if _storage._testOnly != false {
        try visitor.visitSingularBoolField(value: _storage._testOnly, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Api_Expr_V1beta1_Expr.Select, rhs: Google_Api_Expr_V1beta1_Expr.Select) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._operand != rhs_storage._operand {return false}
        if _storage._field != rhs_storage._field {return false}
        if _storage._testOnly != rhs_storage._testOnly {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Api_Expr_V1beta1_Expr.Call: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Api_Expr_V1beta1_Expr.protoMessageName + ".Call"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "target"),
    2: .same(proto: "function"),
    3: .same(proto: "args"),
  ]

  fileprivate class _StorageClass {
    var _target: Google_Api_Expr_V1beta1_Expr? = nil
    var _function: String = String()
    var _args: [Google_Api_Expr_V1beta1_Expr] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _target = source._target
      _function = source._function
      _args = source._args
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._target) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._function) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._args) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._target {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._function.isEmpty {
        try visitor.visitSingularStringField(value: _storage._function, fieldNumber: 2)
      }
      if !_storage._args.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._args, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Api_Expr_V1beta1_Expr.Call, rhs: Google_Api_Expr_V1beta1_Expr.Call) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._target != rhs_storage._target {return false}
        if _storage._function != rhs_storage._function {return false}
        if _storage._args != rhs_storage._args {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Api_Expr_V1beta1_Expr.CreateList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Api_Expr_V1beta1_Expr.protoMessageName + ".CreateList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "elements"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.elements) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.elements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.elements, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Api_Expr_V1beta1_Expr.CreateList, rhs: Google_Api_Expr_V1beta1_Expr.CreateList) -> Bool {
    if lhs.elements != rhs.elements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Api_Expr_V1beta1_Expr.CreateStruct: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Api_Expr_V1beta1_Expr.protoMessageName + ".CreateStruct"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "entries"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Api_Expr_V1beta1_Expr.CreateStruct, rhs: Google_Api_Expr_V1beta1_Expr.CreateStruct) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Api_Expr_V1beta1_Expr.CreateStruct.Entry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Api_Expr_V1beta1_Expr.CreateStruct.protoMessageName + ".Entry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "field_key"),
    3: .standard(proto: "map_key"),
    4: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try {
        if self.keyKind != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.keyKind = .fieldKey(v)}
      }()
      case 3: try {
        var v: Google_Api_Expr_V1beta1_Expr?
        if let current = self.keyKind {
          try decoder.handleConflictingOneOf()
          if case .mapKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.keyKind = .mapKey(v)}
      }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.keyKind {
    case .fieldKey?: try {
      guard case .fieldKey(let v)? = self.keyKind else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .mapKey?: try {
      guard case .mapKey(let v)? = self.keyKind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Api_Expr_V1beta1_Expr.CreateStruct.Entry, rhs: Google_Api_Expr_V1beta1_Expr.CreateStruct.Entry) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.keyKind != rhs.keyKind {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Api_Expr_V1beta1_Expr.Comprehension: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Api_Expr_V1beta1_Expr.protoMessageName + ".Comprehension"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "iter_var"),
    2: .standard(proto: "iter_range"),
    3: .standard(proto: "accu_var"),
    4: .standard(proto: "accu_init"),
    5: .standard(proto: "loop_condition"),
    6: .standard(proto: "loop_step"),
    7: .same(proto: "result"),
  ]

  fileprivate class _StorageClass {
    var _iterVar: String = String()
    var _iterRange: Google_Api_Expr_V1beta1_Expr? = nil
    var _accuVar: String = String()
    var _accuInit: Google_Api_Expr_V1beta1_Expr? = nil
    var _loopCondition: Google_Api_Expr_V1beta1_Expr? = nil
    var _loopStep: Google_Api_Expr_V1beta1_Expr? = nil
    var _result: Google_Api_Expr_V1beta1_Expr? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _iterVar = source._iterVar
      _iterRange = source._iterRange
      _accuVar = source._accuVar
      _accuInit = source._accuInit
      _loopCondition = source._loopCondition
      _loopStep = source._loopStep
      _result = source._result
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._iterVar) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._iterRange) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._accuVar) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._accuInit) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._loopCondition) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._loopStep) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._result) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._iterVar.isEmpty {
        try visitor.visitSingularStringField(value: _storage._iterVar, fieldNumber: 1)
      }
      if let v = _storage._iterRange {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._accuVar.isEmpty {
        try visitor.visitSingularStringField(value: _storage._accuVar, fieldNumber: 3)
      }
      if let v = _storage._accuInit {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._loopCondition {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._loopStep {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._result {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Api_Expr_V1beta1_Expr.Comprehension, rhs: Google_Api_Expr_V1beta1_Expr.Comprehension) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._iterVar != rhs_storage._iterVar {return false}
        if _storage._iterRange != rhs_storage._iterRange {return false}
        if _storage._accuVar != rhs_storage._accuVar {return false}
        if _storage._accuInit != rhs_storage._accuInit {return false}
        if _storage._loopCondition != rhs_storage._loopCondition {return false}
        if _storage._loopStep != rhs_storage._loopStep {return false}
        if _storage._result != rhs_storage._result {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Api_Expr_V1beta1_Literal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Literal"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "null_value"),
    2: .standard(proto: "bool_value"),
    3: .standard(proto: "int64_value"),
    4: .standard(proto: "uint64_value"),
    5: .standard(proto: "double_value"),
    6: .standard(proto: "string_value"),
    7: .standard(proto: "bytes_value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.constantKind != nil {try decoder.handleConflictingOneOf()}
        var v: SwiftProtobuf.Google_Protobuf_NullValue?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {self.constantKind = .nullValue(v)}
      }()
      case 2: try {
        if self.constantKind != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.constantKind = .boolValue(v)}
      }()
      case 3: try {
        if self.constantKind != nil {try decoder.handleConflictingOneOf()}
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {self.constantKind = .int64Value(v)}
      }()
      case 4: try {
        if self.constantKind != nil {try decoder.handleConflictingOneOf()}
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {self.constantKind = .uint64Value(v)}
      }()
      case 5: try {
        if self.constantKind != nil {try decoder.handleConflictingOneOf()}
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {self.constantKind = .doubleValue(v)}
      }()
      case 6: try {
        if self.constantKind != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.constantKind = .stringValue(v)}
      }()
      case 7: try {
        if self.constantKind != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.constantKind = .bytesValue(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.constantKind {
    case .nullValue?: try {
      guard case .nullValue(let v)? = self.constantKind else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .boolValue?: try {
      guard case .boolValue(let v)? = self.constantKind else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }()
    case .int64Value?: try {
      guard case .int64Value(let v)? = self.constantKind else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    }()
    case .uint64Value?: try {
      guard case .uint64Value(let v)? = self.constantKind else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    }()
    case .doubleValue?: try {
      guard case .doubleValue(let v)? = self.constantKind else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 5)
    }()
    case .stringValue?: try {
      guard case .stringValue(let v)? = self.constantKind else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }()
    case .bytesValue?: try {
      guard case .bytesValue(let v)? = self.constantKind else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Api_Expr_V1beta1_Literal, rhs: Google_Api_Expr_V1beta1_Literal) -> Bool {
    if lhs.constantKind != rhs.constantKind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

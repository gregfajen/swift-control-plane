// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/privacy/dlp/v2/dlp.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Operators available for comparing the value of fields.
public enum Google_Privacy_Dlp_V2_RelationalOperator: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Unused
  case unspecified // = 0

  /// Equal. Attempts to match even with incompatible types.
  case equalTo // = 1

  /// Not equal to. Attempts to match even with incompatible types.
  case notEqualTo // = 2

  /// Greater than.
  case greaterThan // = 3

  /// Less than.
  case lessThan // = 4

  /// Greater than or equals.
  case greaterThanOrEquals // = 5

  /// Less than or equals.
  case lessThanOrEquals // = 6

  /// Exists
  case exists // = 7
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .equalTo
    case 2: self = .notEqualTo
    case 3: self = .greaterThan
    case 4: self = .lessThan
    case 5: self = .greaterThanOrEquals
    case 6: self = .lessThanOrEquals
    case 7: self = .exists
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .equalTo: return 1
    case .notEqualTo: return 2
    case .greaterThan: return 3
    case .lessThan: return 4
    case .greaterThanOrEquals: return 5
    case .lessThanOrEquals: return 6
    case .exists: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Privacy_Dlp_V2_RelationalOperator: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Privacy_Dlp_V2_RelationalOperator] = [
    .unspecified,
    .equalTo,
    .notEqualTo,
    .greaterThan,
    .lessThan,
    .greaterThanOrEquals,
    .lessThanOrEquals,
    .exists,
  ]
}

#endif  // swift(>=4.2)

/// Type of the match which can be applied to different ways of matching, like
/// Dictionary, regular expression and intersecting with findings of another
/// info type.
public enum Google_Privacy_Dlp_V2_MatchingType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Invalid.
  case unspecified // = 0

  /// Full match.
  ///
  /// - Dictionary: join of Dictionary results matched complete finding quote
  /// - Regex: all regex matches fill a finding quote start to end
  /// - Exclude info type: completely inside affecting info types findings
  case fullMatch // = 1

  /// Partial match.
  ///
  /// - Dictionary: at least one of the tokens in the finding matches
  /// - Regex: substring of the finding matches
  /// - Exclude info type: intersects with affecting info types findings
  case partialMatch // = 2

  /// Inverse match.
  ///
  /// - Dictionary: no tokens in the finding match the dictionary
  /// - Regex: finding doesn't match the regex
  /// - Exclude info type: no intersection with affecting info types findings
  case inverseMatch // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .fullMatch
    case 2: self = .partialMatch
    case 3: self = .inverseMatch
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .fullMatch: return 1
    case .partialMatch: return 2
    case .inverseMatch: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Privacy_Dlp_V2_MatchingType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Privacy_Dlp_V2_MatchingType] = [
    .unspecified,
    .fullMatch,
    .partialMatch,
    .inverseMatch,
  ]
}

#endif  // swift(>=4.2)

/// Options describing which parts of the provided content should be scanned.
public enum Google_Privacy_Dlp_V2_ContentOption: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Includes entire content of a file or a data stream.
  case contentUnspecified // = 0

  /// Text content within the data, excluding any metadata.
  case contentText // = 1

  /// Images found in the data.
  case contentImage // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .contentUnspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .contentUnspecified
    case 1: self = .contentText
    case 2: self = .contentImage
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .contentUnspecified: return 0
    case .contentText: return 1
    case .contentImage: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Privacy_Dlp_V2_ContentOption: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Privacy_Dlp_V2_ContentOption] = [
    .contentUnspecified,
    .contentText,
    .contentImage,
  ]
}

#endif  // swift(>=4.2)

/// Type of metadata containing the finding.
public enum Google_Privacy_Dlp_V2_MetadataType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Unused
  case unspecified // = 0

  /// General file metadata provided by Cloud Storage.
  case storageMetadata // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 2: self = .storageMetadata
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .storageMetadata: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Privacy_Dlp_V2_MetadataType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Privacy_Dlp_V2_MetadataType] = [
    .unspecified,
    .storageMetadata,
  ]
}

#endif  // swift(>=4.2)

/// Parts of the APIs which use certain infoTypes.
public enum Google_Privacy_Dlp_V2_InfoTypeSupportedBy: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Unused.
  case enumTypeUnspecified // = 0

  /// Supported by the inspect operations.
  case inspect // = 1

  /// Supported by the risk analysis operations.
  case riskAnalysis // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .enumTypeUnspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .enumTypeUnspecified
    case 1: self = .inspect
    case 2: self = .riskAnalysis
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .enumTypeUnspecified: return 0
    case .inspect: return 1
    case .riskAnalysis: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Privacy_Dlp_V2_InfoTypeSupportedBy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Privacy_Dlp_V2_InfoTypeSupportedBy] = [
    .enumTypeUnspecified,
    .inspect,
    .riskAnalysis,
  ]
}

#endif  // swift(>=4.2)

/// An enum to represent the various types of DLP jobs.
public enum Google_Privacy_Dlp_V2_DlpJobType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Unused
  case unspecified // = 0

  /// The job inspected Google Cloud for sensitive data.
  case inspectJob // = 1

  /// The job executed a Risk Analysis computation.
  case riskAnalysisJob // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .inspectJob
    case 2: self = .riskAnalysisJob
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .inspectJob: return 1
    case .riskAnalysisJob: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Privacy_Dlp_V2_DlpJobType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Privacy_Dlp_V2_DlpJobType] = [
    .unspecified,
    .inspectJob,
    .riskAnalysisJob,
  ]
}

#endif  // swift(>=4.2)

/// State of a StoredInfoType version.
public enum Google_Privacy_Dlp_V2_StoredInfoTypeState: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Unused
  case unspecified // = 0

  /// StoredInfoType version is being created.
  case pending // = 1

  /// StoredInfoType version is ready for use.
  case ready // = 2

  /// StoredInfoType creation failed. All relevant error messages are returned in
  /// the `StoredInfoTypeVersion` message.
  case failed // = 3

  /// StoredInfoType is no longer valid because artifacts stored in
  /// user-controlled storage were modified. To fix an invalid StoredInfoType,
  /// use the `UpdateStoredInfoType` method to create a new version.
  case invalid // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .pending
    case 2: self = .ready
    case 3: self = .failed
    case 4: self = .invalid
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .pending: return 1
    case .ready: return 2
    case .failed: return 3
    case .invalid: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Privacy_Dlp_V2_StoredInfoTypeState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Privacy_Dlp_V2_StoredInfoTypeState] = [
    .unspecified,
    .pending,
    .ready,
    .failed,
    .invalid,
  ]
}

#endif  // swift(>=4.2)

/// List of exclude infoTypes.
public struct Google_Privacy_Dlp_V2_ExcludeInfoTypes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// InfoType list in ExclusionRule rule drops a finding when it overlaps or
  /// contained within with a finding of an infoType from this list. For
  /// example, for `InspectionRuleSet.info_types` containing "PHONE_NUMBER"` and
  /// `exclusion_rule` containing `exclude_info_types.info_types` with
  /// "EMAIL_ADDRESS" the phone number findings are dropped if they overlap
  /// with EMAIL_ADDRESS finding.
  /// That leads to "555-222-2222@example.org" to generate only a single
  /// finding, namely email address.
  public var infoTypes: [Google_Privacy_Dlp_V2_InfoType] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The rule that specifies conditions when findings of infoTypes specified in
/// `InspectionRuleSet` are removed from results.
public struct Google_Privacy_Dlp_V2_ExclusionRule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Exclusion rule types.
  public var type: Google_Privacy_Dlp_V2_ExclusionRule.OneOf_Type? = nil

  /// Dictionary which defines the rule.
  public var dictionary: Google_Privacy_Dlp_V2_CustomInfoType.Dictionary {
    get {
      if case .dictionary(let v)? = type {return v}
      return Google_Privacy_Dlp_V2_CustomInfoType.Dictionary()
    }
    set {type = .dictionary(newValue)}
  }

  /// Regular expression which defines the rule.
  public var regex: Google_Privacy_Dlp_V2_CustomInfoType.Regex {
    get {
      if case .regex(let v)? = type {return v}
      return Google_Privacy_Dlp_V2_CustomInfoType.Regex()
    }
    set {type = .regex(newValue)}
  }

  /// Set of infoTypes for which findings would affect this rule.
  public var excludeInfoTypes: Google_Privacy_Dlp_V2_ExcludeInfoTypes {
    get {
      if case .excludeInfoTypes(let v)? = type {return v}
      return Google_Privacy_Dlp_V2_ExcludeInfoTypes()
    }
    set {type = .excludeInfoTypes(newValue)}
  }

  /// How the rule is applied, see MatchingType documentation for details.
  public var matchingType: Google_Privacy_Dlp_V2_MatchingType = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Exclusion rule types.
  public enum OneOf_Type: Equatable {
    /// Dictionary which defines the rule.
    case dictionary(Google_Privacy_Dlp_V2_CustomInfoType.Dictionary)
    /// Regular expression which defines the rule.
    case regex(Google_Privacy_Dlp_V2_CustomInfoType.Regex)
    /// Set of infoTypes for which findings would affect this rule.
    case excludeInfoTypes(Google_Privacy_Dlp_V2_ExcludeInfoTypes)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Privacy_Dlp_V2_ExclusionRule.OneOf_Type, rhs: Google_Privacy_Dlp_V2_ExclusionRule.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.dictionary, .dictionary): return {
        guard case .dictionary(let l) = lhs, case .dictionary(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.regex, .regex): return {
        guard case .regex(let l) = lhs, case .regex(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.excludeInfoTypes, .excludeInfoTypes): return {
        guard case .excludeInfoTypes(let l) = lhs, case .excludeInfoTypes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// A single inspection rule to be applied to infoTypes, specified in
/// `InspectionRuleSet`.
public struct Google_Privacy_Dlp_V2_InspectionRule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Inspection rule types.
  public var type: Google_Privacy_Dlp_V2_InspectionRule.OneOf_Type? = nil

  /// Hotword-based detection rule.
  public var hotwordRule: Google_Privacy_Dlp_V2_CustomInfoType.DetectionRule.HotwordRule {
    get {
      if case .hotwordRule(let v)? = type {return v}
      return Google_Privacy_Dlp_V2_CustomInfoType.DetectionRule.HotwordRule()
    }
    set {type = .hotwordRule(newValue)}
  }

  /// Exclusion rule.
  public var exclusionRule: Google_Privacy_Dlp_V2_ExclusionRule {
    get {
      if case .exclusionRule(let v)? = type {return v}
      return Google_Privacy_Dlp_V2_ExclusionRule()
    }
    set {type = .exclusionRule(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Inspection rule types.
  public enum OneOf_Type: Equatable {
    /// Hotword-based detection rule.
    case hotwordRule(Google_Privacy_Dlp_V2_CustomInfoType.DetectionRule.HotwordRule)
    /// Exclusion rule.
    case exclusionRule(Google_Privacy_Dlp_V2_ExclusionRule)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Privacy_Dlp_V2_InspectionRule.OneOf_Type, rhs: Google_Privacy_Dlp_V2_InspectionRule.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.hotwordRule, .hotwordRule): return {
        guard case .hotwordRule(let l) = lhs, case .hotwordRule(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.exclusionRule, .exclusionRule): return {
        guard case .exclusionRule(let l) = lhs, case .exclusionRule(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Rule set for modifying a set of infoTypes to alter behavior under certain
/// circumstances, depending on the specific details of the rules within the set.
public struct Google_Privacy_Dlp_V2_InspectionRuleSet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of infoTypes this rule set is applied to.
  public var infoTypes: [Google_Privacy_Dlp_V2_InfoType] = []

  /// Set of rules to be applied to infoTypes. The rules are applied in order.
  public var rules: [Google_Privacy_Dlp_V2_InspectionRule] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Configuration description of the scanning process.
/// When used with redactContent only info_types and min_likelihood are currently
/// used.
public struct Google_Privacy_Dlp_V2_InspectConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Restricts what info_types to look for. The values must correspond to
  /// InfoType values returned by ListInfoTypes or listed at
  /// https://cloud.google.com/dlp/docs/infotypes-reference.
  ///
  /// When no InfoTypes or CustomInfoTypes are specified in a request, the
  /// system may automatically choose what detectors to run. By default this may
  /// be all types, but may change over time as detectors are updated.
  ///
  /// If you need precise control and predictability as to what detectors are
  /// run you should specify specific InfoTypes listed in the reference,
  /// otherwise a default list will be used, which may change over time.
  public var infoTypes: [Google_Privacy_Dlp_V2_InfoType] = []

  /// Only returns findings equal or above this threshold. The default is
  /// POSSIBLE.
  /// See https://cloud.google.com/dlp/docs/likelihood to learn more.
  public var minLikelihood: Google_Privacy_Dlp_V2_Likelihood = .unspecified

  /// Configuration to control the number of findings returned.
  public var limits: Google_Privacy_Dlp_V2_InspectConfig.FindingLimits {
    get {return _limits ?? Google_Privacy_Dlp_V2_InspectConfig.FindingLimits()}
    set {_limits = newValue}
  }
  /// Returns true if `limits` has been explicitly set.
  public var hasLimits: Bool {return self._limits != nil}
  /// Clears the value of `limits`. Subsequent reads from it will return its default value.
  public mutating func clearLimits() {self._limits = nil}

  /// When true, a contextual quote from the data that triggered a finding is
  /// included in the response; see Finding.quote.
  public var includeQuote: Bool = false

  /// When true, excludes type information of the findings.
  public var excludeInfoTypes: Bool = false

  /// CustomInfoTypes provided by the user. See
  /// https://cloud.google.com/dlp/docs/creating-custom-infotypes to learn more.
  public var customInfoTypes: [Google_Privacy_Dlp_V2_CustomInfoType] = []

  /// List of options defining data content to scan.
  /// If empty, text, images, and other content will be included.
  public var contentOptions: [Google_Privacy_Dlp_V2_ContentOption] = []

  /// Set of rules to apply to the findings for this InspectConfig.
  /// Exclusion rules, contained in the set are executed in the end, other
  /// rules are executed in the order they are specified for each info type.
  public var ruleSet: [Google_Privacy_Dlp_V2_InspectionRuleSet] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Configuration to control the number of findings returned.
  public struct FindingLimits {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Max number of findings that will be returned for each item scanned.
    /// When set within `InspectJobConfig`,
    /// the maximum returned is 2000 regardless if this is set higher.
    /// When set within `InspectContentRequest`, this field is ignored.
    public var maxFindingsPerItem: Int32 = 0

    /// Max number of findings that will be returned per request/job.
    /// When set within `InspectContentRequest`, the maximum returned is 2000
    /// regardless if this is set higher.
    public var maxFindingsPerRequest: Int32 = 0

    /// Configuration of findings limit given for specified infoTypes.
    public var maxFindingsPerInfoType: [Google_Privacy_Dlp_V2_InspectConfig.FindingLimits.InfoTypeLimit] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Max findings configuration per infoType, per content item or long
    /// running DlpJob.
    public struct InfoTypeLimit {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Type of information the findings limit applies to. Only one limit per
      /// info_type should be provided. If InfoTypeLimit does not have an
      /// info_type, the DLP API applies the limit against all info_types that
      /// are found but not specified in another InfoTypeLimit.
      public var infoType: Google_Privacy_Dlp_V2_InfoType {
        get {return _infoType ?? Google_Privacy_Dlp_V2_InfoType()}
        set {_infoType = newValue}
      }
      /// Returns true if `infoType` has been explicitly set.
      public var hasInfoType: Bool {return self._infoType != nil}
      /// Clears the value of `infoType`. Subsequent reads from it will return its default value.
      public mutating func clearInfoType() {self._infoType = nil}

      /// Max findings limit for the given infoType.
      public var maxFindings: Int32 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _infoType: Google_Privacy_Dlp_V2_InfoType? = nil
    }

    public init() {}
  }

  public init() {}

  fileprivate var _limits: Google_Privacy_Dlp_V2_InspectConfig.FindingLimits? = nil
}

/// Container for bytes to inspect or redact.
public struct Google_Privacy_Dlp_V2_ByteContentItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of data stored in the bytes string. Default will be TEXT_UTF8.
  public var type: Google_Privacy_Dlp_V2_ByteContentItem.BytesType = .unspecified

  /// Content data to inspect or redact.
  public var data: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The type of data being sent for inspection.
  public enum BytesType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unused
    case unspecified // = 0

    /// Any image type.
    case image // = 6

    /// jpeg
    case imageJpeg // = 1

    /// bmp
    case imageBmp // = 2

    /// png
    case imagePng // = 3

    /// svg
    case imageSvg // = 4

    /// plain text
    case textUtf8 // = 5

    /// docx, docm, dotx, dotm
    case wordDocument // = 7

    /// pdf
    case pdf // = 8

    /// avro
    case avro // = 11

    /// csv
    case csv // = 12

    /// tsv
    case tsv // = 13
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .imageJpeg
      case 2: self = .imageBmp
      case 3: self = .imagePng
      case 4: self = .imageSvg
      case 5: self = .textUtf8
      case 6: self = .image
      case 7: self = .wordDocument
      case 8: self = .pdf
      case 11: self = .avro
      case 12: self = .csv
      case 13: self = .tsv
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .imageJpeg: return 1
      case .imageBmp: return 2
      case .imagePng: return 3
      case .imageSvg: return 4
      case .textUtf8: return 5
      case .image: return 6
      case .wordDocument: return 7
      case .pdf: return 8
      case .avro: return 11
      case .csv: return 12
      case .tsv: return 13
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Privacy_Dlp_V2_ByteContentItem.BytesType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Privacy_Dlp_V2_ByteContentItem.BytesType] = [
    .unspecified,
    .image,
    .imageJpeg,
    .imageBmp,
    .imagePng,
    .imageSvg,
    .textUtf8,
    .wordDocument,
    .pdf,
    .avro,
    .csv,
    .tsv,
  ]
}

#endif  // swift(>=4.2)

/// Container structure for the content to inspect.
public struct Google_Privacy_Dlp_V2_ContentItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Data of the item either in the byte array or UTF-8 string form, or table.
  public var dataItem: Google_Privacy_Dlp_V2_ContentItem.OneOf_DataItem? = nil

  /// String data to inspect or redact.
  public var value: String {
    get {
      if case .value(let v)? = dataItem {return v}
      return String()
    }
    set {dataItem = .value(newValue)}
  }

  /// Structured content for inspection. See
  /// https://cloud.google.com/dlp/docs/inspecting-text#inspecting_a_table to
  /// learn more.
  public var table: Google_Privacy_Dlp_V2_Table {
    get {
      if case .table(let v)? = dataItem {return v}
      return Google_Privacy_Dlp_V2_Table()
    }
    set {dataItem = .table(newValue)}
  }

  /// Content data to inspect or redact. Replaces `type` and `data`.
  public var byteItem: Google_Privacy_Dlp_V2_ByteContentItem {
    get {
      if case .byteItem(let v)? = dataItem {return v}
      return Google_Privacy_Dlp_V2_ByteContentItem()
    }
    set {dataItem = .byteItem(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Data of the item either in the byte array or UTF-8 string form, or table.
  public enum OneOf_DataItem: Equatable {
    /// String data to inspect or redact.
    case value(String)
    /// Structured content for inspection. See
    /// https://cloud.google.com/dlp/docs/inspecting-text#inspecting_a_table to
    /// learn more.
    case table(Google_Privacy_Dlp_V2_Table)
    /// Content data to inspect or redact. Replaces `type` and `data`.
    case byteItem(Google_Privacy_Dlp_V2_ByteContentItem)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Privacy_Dlp_V2_ContentItem.OneOf_DataItem, rhs: Google_Privacy_Dlp_V2_ContentItem.OneOf_DataItem) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.value, .value): return {
        guard case .value(let l) = lhs, case .value(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.table, .table): return {
        guard case .table(let l) = lhs, case .table(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.byteItem, .byteItem): return {
        guard case .byteItem(let l) = lhs, case .byteItem(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Structured content to inspect. Up to 50,000 `Value`s per request allowed.
/// See https://cloud.google.com/dlp/docs/inspecting-text#inspecting_a_table to
/// learn more.
public struct Google_Privacy_Dlp_V2_Table {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Headers of the table.
  public var headers: [Google_Privacy_Dlp_V2_FieldId] = []

  /// Rows of the table.
  public var rows: [Google_Privacy_Dlp_V2_Table.Row] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Values of the row.
  public struct Row {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Individual cells.
    public var values: [Google_Privacy_Dlp_V2_Value] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// All the findings for a single scanned item.
public struct Google_Privacy_Dlp_V2_InspectResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of findings for an item.
  public var findings: [Google_Privacy_Dlp_V2_Finding] = []

  /// If true, then this item might have more findings than were returned,
  /// and the findings returned are an arbitrary subset of all findings.
  /// The findings list might be truncated because the input items were too
  /// large, or because the server reached the maximum amount of resources
  /// allowed for a single API call. For best results, divide the input into
  /// smaller batches.
  public var findingsTruncated: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Represents a piece of potentially sensitive content.
public struct Google_Privacy_Dlp_V2_Finding {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Resource name in format
  /// projects/{project}/locations/{location}/findings/{finding} Populated only
  /// when viewing persisted findings.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// The content that was found. Even if the content is not textual, it
  /// may be converted to a textual representation here.
  /// Provided if `include_quote` is true and the finding is
  /// less than or equal to 4096 bytes long. If the finding exceeds 4096 bytes
  /// in length, the quote may be omitted.
  public var quote: String {
    get {return _storage._quote}
    set {_uniqueStorage()._quote = newValue}
  }

  /// The type of content that might have been found.
  /// Provided if `excluded_types` is false.
  public var infoType: Google_Privacy_Dlp_V2_InfoType {
    get {return _storage._infoType ?? Google_Privacy_Dlp_V2_InfoType()}
    set {_uniqueStorage()._infoType = newValue}
  }
  /// Returns true if `infoType` has been explicitly set.
  public var hasInfoType: Bool {return _storage._infoType != nil}
  /// Clears the value of `infoType`. Subsequent reads from it will return its default value.
  public mutating func clearInfoType() {_uniqueStorage()._infoType = nil}

  /// Confidence of how likely it is that the `info_type` is correct.
  public var likelihood: Google_Privacy_Dlp_V2_Likelihood {
    get {return _storage._likelihood}
    set {_uniqueStorage()._likelihood = newValue}
  }

  /// Where the content was found.
  public var location: Google_Privacy_Dlp_V2_Location {
    get {return _storage._location ?? Google_Privacy_Dlp_V2_Location()}
    set {_uniqueStorage()._location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  public var hasLocation: Bool {return _storage._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  public mutating func clearLocation() {_uniqueStorage()._location = nil}

  /// Timestamp when finding was detected.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return _storage._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {_uniqueStorage()._createTime = nil}

  /// Contains data parsed from quotes. Only populated if include_quote was set
  /// to true and a supported infoType was requested. Currently supported
  /// infoTypes: DATE, DATE_OF_BIRTH and TIME.
  public var quoteInfo: Google_Privacy_Dlp_V2_QuoteInfo {
    get {return _storage._quoteInfo ?? Google_Privacy_Dlp_V2_QuoteInfo()}
    set {_uniqueStorage()._quoteInfo = newValue}
  }
  /// Returns true if `quoteInfo` has been explicitly set.
  public var hasQuoteInfo: Bool {return _storage._quoteInfo != nil}
  /// Clears the value of `quoteInfo`. Subsequent reads from it will return its default value.
  public mutating func clearQuoteInfo() {_uniqueStorage()._quoteInfo = nil}

  /// The job that stored the finding.
  public var resourceName: String {
    get {return _storage._resourceName}
    set {_uniqueStorage()._resourceName = newValue}
  }

  /// Job trigger name, if applicable, for this finding.
  public var triggerName: String {
    get {return _storage._triggerName}
    set {_uniqueStorage()._triggerName = newValue}
  }

  /// The labels associated with this `Finding`.
  ///
  /// Label keys must be between 1 and 63 characters long and must conform
  /// to the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`.
  ///
  /// Label values must be between 0 and 63 characters long and must conform
  /// to the regular expression `([a-z]([-a-z0-9]*[a-z0-9])?)?`.
  ///
  /// No more than 10 labels can be associated with a given finding.
  ///
  /// Examples:
  /// * `"environment" : "production"`
  /// * `"pipeline" : "etl"`
  public var labels: Dictionary<String,String> {
    get {return _storage._labels}
    set {_uniqueStorage()._labels = newValue}
  }

  /// Time the job started that produced this finding.
  public var jobCreateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._jobCreateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._jobCreateTime = newValue}
  }
  /// Returns true if `jobCreateTime` has been explicitly set.
  public var hasJobCreateTime: Bool {return _storage._jobCreateTime != nil}
  /// Clears the value of `jobCreateTime`. Subsequent reads from it will return its default value.
  public mutating func clearJobCreateTime() {_uniqueStorage()._jobCreateTime = nil}

  /// The job that stored the finding.
  public var jobName: String {
    get {return _storage._jobName}
    set {_uniqueStorage()._jobName = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specifies the location of the finding.
public struct Google_Privacy_Dlp_V2_Location {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Zero-based byte offsets delimiting the finding.
  /// These are relative to the finding's containing element.
  /// Note that when the content is not textual, this references
  /// the UTF-8 encoded textual representation of the content.
  /// Omitted if content is an image.
  public var byteRange: Google_Privacy_Dlp_V2_Range {
    get {return _byteRange ?? Google_Privacy_Dlp_V2_Range()}
    set {_byteRange = newValue}
  }
  /// Returns true if `byteRange` has been explicitly set.
  public var hasByteRange: Bool {return self._byteRange != nil}
  /// Clears the value of `byteRange`. Subsequent reads from it will return its default value.
  public mutating func clearByteRange() {self._byteRange = nil}

  /// Unicode character offsets delimiting the finding.
  /// These are relative to the finding's containing element.
  /// Provided when the content is text.
  public var codepointRange: Google_Privacy_Dlp_V2_Range {
    get {return _codepointRange ?? Google_Privacy_Dlp_V2_Range()}
    set {_codepointRange = newValue}
  }
  /// Returns true if `codepointRange` has been explicitly set.
  public var hasCodepointRange: Bool {return self._codepointRange != nil}
  /// Clears the value of `codepointRange`. Subsequent reads from it will return its default value.
  public mutating func clearCodepointRange() {self._codepointRange = nil}

  /// List of nested objects pointing to the precise location of the finding
  /// within the file or record.
  public var contentLocations: [Google_Privacy_Dlp_V2_ContentLocation] = []

  /// Information about the container where this finding occurred, if available.
  public var container: Google_Privacy_Dlp_V2_Container {
    get {return _container ?? Google_Privacy_Dlp_V2_Container()}
    set {_container = newValue}
  }
  /// Returns true if `container` has been explicitly set.
  public var hasContainer: Bool {return self._container != nil}
  /// Clears the value of `container`. Subsequent reads from it will return its default value.
  public mutating func clearContainer() {self._container = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _byteRange: Google_Privacy_Dlp_V2_Range? = nil
  fileprivate var _codepointRange: Google_Privacy_Dlp_V2_Range? = nil
  fileprivate var _container: Google_Privacy_Dlp_V2_Container? = nil
}

/// Precise location of the finding within a document, record, image, or metadata
/// container.
public struct Google_Privacy_Dlp_V2_ContentLocation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the container where the finding is located.
  /// The top level name is the source file name or table name. Names of some
  /// common storage containers are formatted as follows:
  ///
  /// * BigQuery tables:  `{project_id}:{dataset_id}.{table_id}`
  /// * Cloud Storage files: `gs://{bucket}/{path}`
  /// * Datastore namespace: {namespace}
  ///
  /// Nested names could be absent if the embedded object has no string
  /// identifier (for an example an image contained within a document).
  public var containerName: String = String()

  /// Type of the container within the file with location of the finding.
  public var location: Google_Privacy_Dlp_V2_ContentLocation.OneOf_Location? = nil

  /// Location within a row or record of a database table.
  public var recordLocation: Google_Privacy_Dlp_V2_RecordLocation {
    get {
      if case .recordLocation(let v)? = location {return v}
      return Google_Privacy_Dlp_V2_RecordLocation()
    }
    set {location = .recordLocation(newValue)}
  }

  /// Location within an image's pixels.
  public var imageLocation: Google_Privacy_Dlp_V2_ImageLocation {
    get {
      if case .imageLocation(let v)? = location {return v}
      return Google_Privacy_Dlp_V2_ImageLocation()
    }
    set {location = .imageLocation(newValue)}
  }

  /// Location data for document files.
  public var documentLocation: Google_Privacy_Dlp_V2_DocumentLocation {
    get {
      if case .documentLocation(let v)? = location {return v}
      return Google_Privacy_Dlp_V2_DocumentLocation()
    }
    set {location = .documentLocation(newValue)}
  }

  /// Location within the metadata for inspected content.
  public var metadataLocation: Google_Privacy_Dlp_V2_MetadataLocation {
    get {
      if case .metadataLocation(let v)? = location {return v}
      return Google_Privacy_Dlp_V2_MetadataLocation()
    }
    set {location = .metadataLocation(newValue)}
  }

  /// Findings container modification timestamp, if applicable.
  /// For Google Cloud Storage contains last file modification timestamp.
  /// For BigQuery table contains last_modified_time property.
  /// For Datastore - not populated.
  public var containerTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _containerTimestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_containerTimestamp = newValue}
  }
  /// Returns true if `containerTimestamp` has been explicitly set.
  public var hasContainerTimestamp: Bool {return self._containerTimestamp != nil}
  /// Clears the value of `containerTimestamp`. Subsequent reads from it will return its default value.
  public mutating func clearContainerTimestamp() {self._containerTimestamp = nil}

  /// Findings container version, if available
  /// ("generation" for Google Cloud Storage).
  public var containerVersion: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Type of the container within the file with location of the finding.
  public enum OneOf_Location: Equatable {
    /// Location within a row or record of a database table.
    case recordLocation(Google_Privacy_Dlp_V2_RecordLocation)
    /// Location within an image's pixels.
    case imageLocation(Google_Privacy_Dlp_V2_ImageLocation)
    /// Location data for document files.
    case documentLocation(Google_Privacy_Dlp_V2_DocumentLocation)
    /// Location within the metadata for inspected content.
    case metadataLocation(Google_Privacy_Dlp_V2_MetadataLocation)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Privacy_Dlp_V2_ContentLocation.OneOf_Location, rhs: Google_Privacy_Dlp_V2_ContentLocation.OneOf_Location) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.recordLocation, .recordLocation): return {
        guard case .recordLocation(let l) = lhs, case .recordLocation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.imageLocation, .imageLocation): return {
        guard case .imageLocation(let l) = lhs, case .imageLocation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.documentLocation, .documentLocation): return {
        guard case .documentLocation(let l) = lhs, case .documentLocation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.metadataLocation, .metadataLocation): return {
        guard case .metadataLocation(let l) = lhs, case .metadataLocation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _containerTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Metadata Location
public struct Google_Privacy_Dlp_V2_MetadataLocation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of metadata containing the finding.
  public var type: Google_Privacy_Dlp_V2_MetadataType = .unspecified

  /// Label of the piece of metadata containing the finding, for example -
  /// latitude, author, caption.
  public var label: Google_Privacy_Dlp_V2_MetadataLocation.OneOf_Label? = nil

  /// Storage metadata.
  public var storageLabel: Google_Privacy_Dlp_V2_StorageMetadataLabel {
    get {
      if case .storageLabel(let v)? = label {return v}
      return Google_Privacy_Dlp_V2_StorageMetadataLabel()
    }
    set {label = .storageLabel(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Label of the piece of metadata containing the finding, for example -
  /// latitude, author, caption.
  public enum OneOf_Label: Equatable {
    /// Storage metadata.
    case storageLabel(Google_Privacy_Dlp_V2_StorageMetadataLabel)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Privacy_Dlp_V2_MetadataLocation.OneOf_Label, rhs: Google_Privacy_Dlp_V2_MetadataLocation.OneOf_Label) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.storageLabel, .storageLabel): return {
        guard case .storageLabel(let l) = lhs, case .storageLabel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

/// Storage metadata label to indicate which metadata entry contains findings.
public struct Google_Privacy_Dlp_V2_StorageMetadataLabel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Location of a finding within a document.
public struct Google_Privacy_Dlp_V2_DocumentLocation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Offset of the line, from the beginning of the file, where the finding
  /// is located.
  public var fileOffset: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Location of a finding within a row or record.
public struct Google_Privacy_Dlp_V2_RecordLocation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Key of the finding.
  public var recordKey: Google_Privacy_Dlp_V2_RecordKey {
    get {return _recordKey ?? Google_Privacy_Dlp_V2_RecordKey()}
    set {_recordKey = newValue}
  }
  /// Returns true if `recordKey` has been explicitly set.
  public var hasRecordKey: Bool {return self._recordKey != nil}
  /// Clears the value of `recordKey`. Subsequent reads from it will return its default value.
  public mutating func clearRecordKey() {self._recordKey = nil}

  /// Field id of the field containing the finding.
  public var fieldID: Google_Privacy_Dlp_V2_FieldId {
    get {return _fieldID ?? Google_Privacy_Dlp_V2_FieldId()}
    set {_fieldID = newValue}
  }
  /// Returns true if `fieldID` has been explicitly set.
  public var hasFieldID: Bool {return self._fieldID != nil}
  /// Clears the value of `fieldID`. Subsequent reads from it will return its default value.
  public mutating func clearFieldID() {self._fieldID = nil}

  /// Location within a `ContentItem.Table`.
  public var tableLocation: Google_Privacy_Dlp_V2_TableLocation {
    get {return _tableLocation ?? Google_Privacy_Dlp_V2_TableLocation()}
    set {_tableLocation = newValue}
  }
  /// Returns true if `tableLocation` has been explicitly set.
  public var hasTableLocation: Bool {return self._tableLocation != nil}
  /// Clears the value of `tableLocation`. Subsequent reads from it will return its default value.
  public mutating func clearTableLocation() {self._tableLocation = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _recordKey: Google_Privacy_Dlp_V2_RecordKey? = nil
  fileprivate var _fieldID: Google_Privacy_Dlp_V2_FieldId? = nil
  fileprivate var _tableLocation: Google_Privacy_Dlp_V2_TableLocation? = nil
}

/// Location of a finding within a table.
public struct Google_Privacy_Dlp_V2_TableLocation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The zero-based index of the row where the finding is located. Only
  /// populated for resources that have a natural ordering, not BigQuery. In
  /// BigQuery, to identify the row a finding came from, populate
  /// BigQueryOptions.identifying_fields with your primary key column names and
  /// when you store the findings the value of those columns will be stored
  /// inside of Finding.
  public var rowIndex: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Represents a container that may contain DLP findings.
/// Examples of a container include a file, table, or database record.
public struct Google_Privacy_Dlp_V2_Container {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Container type, for example BigQuery or Google Cloud Storage.
  public var type: String = String()

  /// Project where the finding was found.
  /// Can be different from the project that owns the finding.
  public var projectID: String = String()

  /// A string representation of the full container name.
  /// Examples:
  /// - BigQuery: 'Project:DataSetId.TableId'
  /// - Google Cloud Storage: 'gs://Bucket/folders/filename.txt'
  public var fullPath: String = String()

  /// The root of the container.
  /// Examples:
  /// - For BigQuery table `project_id:dataset_id.table_id`, the root is
  ///  `dataset_id`
  /// - For Google Cloud Storage file `gs://bucket/folder/filename.txt`, the root
  ///  is `gs://bucket`
  public var rootPath: String = String()

  /// The rest of the path after the root.
  /// Examples:
  /// - For BigQuery table `project_id:dataset_id.table_id`, the relative path is
  ///  `table_id`
  /// - Google Cloud Storage file `gs://bucket/folder/filename.txt`, the relative
  ///  path is `folder/filename.txt`
  public var relativePath: String = String()

  /// Findings container modification timestamp, if applicable.
  /// For Google Cloud Storage contains last file modification timestamp.
  /// For BigQuery table contains last_modified_time property.
  /// For Datastore - not populated.
  public var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  public var hasUpdateTime: Bool {return self._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateTime() {self._updateTime = nil}

  /// Findings container version, if available
  /// ("generation" for Google Cloud Storage).
  public var version: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Generic half-open interval [start, end)
public struct Google_Privacy_Dlp_V2_Range {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Index of the first character of the range (inclusive).
  public var start: Int64 = 0

  /// Index of the last character of the range (exclusive).
  public var end: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Location of the finding within an image.
public struct Google_Privacy_Dlp_V2_ImageLocation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Bounding boxes locating the pixels within the image containing the finding.
  public var boundingBoxes: [Google_Privacy_Dlp_V2_BoundingBox] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Bounding box encompassing detected text within an image.
public struct Google_Privacy_Dlp_V2_BoundingBox {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Top coordinate of the bounding box. (0,0) is upper left.
  public var top: Int32 = 0

  /// Left coordinate of the bounding box. (0,0) is upper left.
  public var left: Int32 = 0

  /// Width of the bounding box in pixels.
  public var width: Int32 = 0

  /// Height of the bounding box in pixels.
  public var height: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to search for potentially sensitive info in an image and redact it
/// by covering it with a colored rectangle.
public struct Google_Privacy_Dlp_V2_RedactImageRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Parent resource name.
  ///
  /// The format of this value varies depending on whether you have [specified a
  /// processing
  /// location](https://cloud.google.com/dlp/docs/specifying-location):
  ///
  /// + Projects scope, location specified:<br/>
  ///   `projects/`<var>PROJECT_ID</var>`/locations/`<var>LOCATION_ID</var>
  /// + Projects scope, no location specified (defaults to global):<br/>
  ///   `projects/`<var>PROJECT_ID</var>
  ///
  /// The following example `parent` string specifies a parent project with the
  /// identifier `example-project`, and specifies the `europe-west3` location
  /// for processing data:
  ///
  ///     parent=projects/example-project/locations/europe-west3
  public var parent: String = String()

  /// Deprecated. This field has no effect.
  public var locationID: String = String()

  /// Configuration for the inspector.
  public var inspectConfig: Google_Privacy_Dlp_V2_InspectConfig {
    get {return _inspectConfig ?? Google_Privacy_Dlp_V2_InspectConfig()}
    set {_inspectConfig = newValue}
  }
  /// Returns true if `inspectConfig` has been explicitly set.
  public var hasInspectConfig: Bool {return self._inspectConfig != nil}
  /// Clears the value of `inspectConfig`. Subsequent reads from it will return its default value.
  public mutating func clearInspectConfig() {self._inspectConfig = nil}

  /// The configuration for specifying what content to redact from images.
  public var imageRedactionConfigs: [Google_Privacy_Dlp_V2_RedactImageRequest.ImageRedactionConfig] = []

  /// Whether the response should include findings along with the redacted
  /// image.
  public var includeFindings: Bool = false

  /// The content must be PNG, JPEG, SVG or BMP.
  public var byteItem: Google_Privacy_Dlp_V2_ByteContentItem {
    get {return _byteItem ?? Google_Privacy_Dlp_V2_ByteContentItem()}
    set {_byteItem = newValue}
  }
  /// Returns true if `byteItem` has been explicitly set.
  public var hasByteItem: Bool {return self._byteItem != nil}
  /// Clears the value of `byteItem`. Subsequent reads from it will return its default value.
  public mutating func clearByteItem() {self._byteItem = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Configuration for determining how redaction of images should occur.
  public struct ImageRedactionConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Type of information to redact from images.
    public var target: Google_Privacy_Dlp_V2_RedactImageRequest.ImageRedactionConfig.OneOf_Target? = nil

    /// Only one per info_type should be provided per request. If not
    /// specified, and redact_all_text is false, the DLP API will redact all
    /// text that it matches against all info_types that are found, but not
    /// specified in another ImageRedactionConfig.
    public var infoType: Google_Privacy_Dlp_V2_InfoType {
      get {
        if case .infoType(let v)? = target {return v}
        return Google_Privacy_Dlp_V2_InfoType()
      }
      set {target = .infoType(newValue)}
    }

    /// If true, all text found in the image, regardless whether it matches an
    /// info_type, is redacted. Only one should be provided.
    public var redactAllText: Bool {
      get {
        if case .redactAllText(let v)? = target {return v}
        return false
      }
      set {target = .redactAllText(newValue)}
    }

    /// The color to use when redacting content from an image. If not specified,
    /// the default is black.
    public var redactionColor: Google_Privacy_Dlp_V2_Color {
      get {return _redactionColor ?? Google_Privacy_Dlp_V2_Color()}
      set {_redactionColor = newValue}
    }
    /// Returns true if `redactionColor` has been explicitly set.
    public var hasRedactionColor: Bool {return self._redactionColor != nil}
    /// Clears the value of `redactionColor`. Subsequent reads from it will return its default value.
    public mutating func clearRedactionColor() {self._redactionColor = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Type of information to redact from images.
    public enum OneOf_Target: Equatable {
      /// Only one per info_type should be provided per request. If not
      /// specified, and redact_all_text is false, the DLP API will redact all
      /// text that it matches against all info_types that are found, but not
      /// specified in another ImageRedactionConfig.
      case infoType(Google_Privacy_Dlp_V2_InfoType)
      /// If true, all text found in the image, regardless whether it matches an
      /// info_type, is redacted. Only one should be provided.
      case redactAllText(Bool)

    #if !swift(>=4.1)
      public static func ==(lhs: Google_Privacy_Dlp_V2_RedactImageRequest.ImageRedactionConfig.OneOf_Target, rhs: Google_Privacy_Dlp_V2_RedactImageRequest.ImageRedactionConfig.OneOf_Target) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.infoType, .infoType): return {
          guard case .infoType(let l) = lhs, case .infoType(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.redactAllText, .redactAllText): return {
          guard case .redactAllText(let l) = lhs, case .redactAllText(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}

    fileprivate var _redactionColor: Google_Privacy_Dlp_V2_Color? = nil
  }

  public init() {}

  fileprivate var _inspectConfig: Google_Privacy_Dlp_V2_InspectConfig? = nil
  fileprivate var _byteItem: Google_Privacy_Dlp_V2_ByteContentItem? = nil
}

/// Represents a color in the RGB color space.
public struct Google_Privacy_Dlp_V2_Color {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The amount of red in the color as a value in the interval [0, 1].
  public var red: Float = 0

  /// The amount of green in the color as a value in the interval [0, 1].
  public var green: Float = 0

  /// The amount of blue in the color as a value in the interval [0, 1].
  public var blue: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Results of redacting an image.
public struct Google_Privacy_Dlp_V2_RedactImageResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The redacted image. The type will be the same as the original image.
  public var redactedImage: Data = Data()

  /// If an image was being inspected and the InspectConfig's include_quote was
  /// set to true, then this field will include all text, if any, that was found
  /// in the image.
  public var extractedText: String = String()

  /// The findings. Populated when include_findings in the request is true.
  public var inspectResult: Google_Privacy_Dlp_V2_InspectResult {
    get {return _inspectResult ?? Google_Privacy_Dlp_V2_InspectResult()}
    set {_inspectResult = newValue}
  }
  /// Returns true if `inspectResult` has been explicitly set.
  public var hasInspectResult: Bool {return self._inspectResult != nil}
  /// Clears the value of `inspectResult`. Subsequent reads from it will return its default value.
  public mutating func clearInspectResult() {self._inspectResult = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _inspectResult: Google_Privacy_Dlp_V2_InspectResult? = nil
}

/// Request to de-identify a list of items.
public struct Google_Privacy_Dlp_V2_DeidentifyContentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Parent resource name.
  ///
  /// The format of this value varies depending on whether you have [specified a
  /// processing
  /// location](https://cloud.google.com/dlp/docs/specifying-location):
  ///
  /// + Projects scope, location specified:<br/>
  ///   `projects/`<var>PROJECT_ID</var>`/locations/`<var>LOCATION_ID</var>
  /// + Projects scope, no location specified (defaults to global):<br/>
  ///   `projects/`<var>PROJECT_ID</var>
  ///
  /// The following example `parent` string specifies a parent project with the
  /// identifier `example-project`, and specifies the `europe-west3` location
  /// for processing data:
  ///
  ///     parent=projects/example-project/locations/europe-west3
  public var parent: String {
    get {return _storage._parent}
    set {_uniqueStorage()._parent = newValue}
  }

  /// Configuration for the de-identification of the content item.
  /// Items specified here will override the template referenced by the
  /// deidentify_template_name argument.
  public var deidentifyConfig: Google_Privacy_Dlp_V2_DeidentifyConfig {
    get {return _storage._deidentifyConfig ?? Google_Privacy_Dlp_V2_DeidentifyConfig()}
    set {_uniqueStorage()._deidentifyConfig = newValue}
  }
  /// Returns true if `deidentifyConfig` has been explicitly set.
  public var hasDeidentifyConfig: Bool {return _storage._deidentifyConfig != nil}
  /// Clears the value of `deidentifyConfig`. Subsequent reads from it will return its default value.
  public mutating func clearDeidentifyConfig() {_uniqueStorage()._deidentifyConfig = nil}

  /// Configuration for the inspector.
  /// Items specified here will override the template referenced by the
  /// inspect_template_name argument.
  public var inspectConfig: Google_Privacy_Dlp_V2_InspectConfig {
    get {return _storage._inspectConfig ?? Google_Privacy_Dlp_V2_InspectConfig()}
    set {_uniqueStorage()._inspectConfig = newValue}
  }
  /// Returns true if `inspectConfig` has been explicitly set.
  public var hasInspectConfig: Bool {return _storage._inspectConfig != nil}
  /// Clears the value of `inspectConfig`. Subsequent reads from it will return its default value.
  public mutating func clearInspectConfig() {_uniqueStorage()._inspectConfig = nil}

  /// The item to de-identify. Will be treated as text.
  public var item: Google_Privacy_Dlp_V2_ContentItem {
    get {return _storage._item ?? Google_Privacy_Dlp_V2_ContentItem()}
    set {_uniqueStorage()._item = newValue}
  }
  /// Returns true if `item` has been explicitly set.
  public var hasItem: Bool {return _storage._item != nil}
  /// Clears the value of `item`. Subsequent reads from it will return its default value.
  public mutating func clearItem() {_uniqueStorage()._item = nil}

  /// Template to use. Any configuration directly specified in
  /// inspect_config will override those set in the template. Singular fields
  /// that are set in this request will replace their corresponding fields in the
  /// template. Repeated fields are appended. Singular sub-messages and groups
  /// are recursively merged.
  public var inspectTemplateName: String {
    get {return _storage._inspectTemplateName}
    set {_uniqueStorage()._inspectTemplateName = newValue}
  }

  /// Template to use. Any configuration directly specified in
  /// deidentify_config will override those set in the template. Singular fields
  /// that are set in this request will replace their corresponding fields in the
  /// template. Repeated fields are appended. Singular sub-messages and groups
  /// are recursively merged.
  public var deidentifyTemplateName: String {
    get {return _storage._deidentifyTemplateName}
    set {_uniqueStorage()._deidentifyTemplateName = newValue}
  }

  /// Deprecated. This field has no effect.
  public var locationID: String {
    get {return _storage._locationID}
    set {_uniqueStorage()._locationID = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Results of de-identifying a ContentItem.
public struct Google_Privacy_Dlp_V2_DeidentifyContentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The de-identified item.
  public var item: Google_Privacy_Dlp_V2_ContentItem {
    get {return _item ?? Google_Privacy_Dlp_V2_ContentItem()}
    set {_item = newValue}
  }
  /// Returns true if `item` has been explicitly set.
  public var hasItem: Bool {return self._item != nil}
  /// Clears the value of `item`. Subsequent reads from it will return its default value.
  public mutating func clearItem() {self._item = nil}

  /// An overview of the changes that were made on the `item`.
  public var overview: Google_Privacy_Dlp_V2_TransformationOverview {
    get {return _overview ?? Google_Privacy_Dlp_V2_TransformationOverview()}
    set {_overview = newValue}
  }
  /// Returns true if `overview` has been explicitly set.
  public var hasOverview: Bool {return self._overview != nil}
  /// Clears the value of `overview`. Subsequent reads from it will return its default value.
  public mutating func clearOverview() {self._overview = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _item: Google_Privacy_Dlp_V2_ContentItem? = nil
  fileprivate var _overview: Google_Privacy_Dlp_V2_TransformationOverview? = nil
}

/// Request to re-identify an item.
public struct Google_Privacy_Dlp_V2_ReidentifyContentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Parent resource name.
  ///
  /// The format of this value varies depending on whether you have [specified a
  /// processing
  /// location](https://cloud.google.com/dlp/docs/specifying-location):
  ///
  /// + Projects scope, location specified:<br/>
  ///   `projects/`<var>PROJECT_ID</var>`/locations/`<var>LOCATION_ID</var>
  /// + Projects scope, no location specified (defaults to global):<br/>
  ///   `projects/`<var>PROJECT_ID</var>
  ///
  /// The following example `parent` string specifies a parent project with the
  /// identifier `example-project`, and specifies the `europe-west3` location
  /// for processing data:
  ///
  ///     parent=projects/example-project/locations/europe-west3
  public var parent: String {
    get {return _storage._parent}
    set {_uniqueStorage()._parent = newValue}
  }

  /// Configuration for the re-identification of the content item.
  /// This field shares the same proto message type that is used for
  /// de-identification, however its usage here is for the reversal of the
  /// previous de-identification. Re-identification is performed by examining
  /// the transformations used to de-identify the items and executing the
  /// reverse. This requires that only reversible transformations
  /// be provided here. The reversible transformations are:
  ///
  ///  - `CryptoDeterministicConfig`
  ///  - `CryptoReplaceFfxFpeConfig`
  public var reidentifyConfig: Google_Privacy_Dlp_V2_DeidentifyConfig {
    get {return _storage._reidentifyConfig ?? Google_Privacy_Dlp_V2_DeidentifyConfig()}
    set {_uniqueStorage()._reidentifyConfig = newValue}
  }
  /// Returns true if `reidentifyConfig` has been explicitly set.
  public var hasReidentifyConfig: Bool {return _storage._reidentifyConfig != nil}
  /// Clears the value of `reidentifyConfig`. Subsequent reads from it will return its default value.
  public mutating func clearReidentifyConfig() {_uniqueStorage()._reidentifyConfig = nil}

  /// Configuration for the inspector.
  public var inspectConfig: Google_Privacy_Dlp_V2_InspectConfig {
    get {return _storage._inspectConfig ?? Google_Privacy_Dlp_V2_InspectConfig()}
    set {_uniqueStorage()._inspectConfig = newValue}
  }
  /// Returns true if `inspectConfig` has been explicitly set.
  public var hasInspectConfig: Bool {return _storage._inspectConfig != nil}
  /// Clears the value of `inspectConfig`. Subsequent reads from it will return its default value.
  public mutating func clearInspectConfig() {_uniqueStorage()._inspectConfig = nil}

  /// The item to re-identify. Will be treated as text.
  public var item: Google_Privacy_Dlp_V2_ContentItem {
    get {return _storage._item ?? Google_Privacy_Dlp_V2_ContentItem()}
    set {_uniqueStorage()._item = newValue}
  }
  /// Returns true if `item` has been explicitly set.
  public var hasItem: Bool {return _storage._item != nil}
  /// Clears the value of `item`. Subsequent reads from it will return its default value.
  public mutating func clearItem() {_uniqueStorage()._item = nil}

  /// Template to use. Any configuration directly specified in
  /// `inspect_config` will override those set in the template. Singular fields
  /// that are set in this request will replace their corresponding fields in the
  /// template. Repeated fields are appended. Singular sub-messages and groups
  /// are recursively merged.
  public var inspectTemplateName: String {
    get {return _storage._inspectTemplateName}
    set {_uniqueStorage()._inspectTemplateName = newValue}
  }

  /// Template to use. References an instance of `DeidentifyTemplate`.
  /// Any configuration directly specified in `reidentify_config` or
  /// `inspect_config` will override those set in the template. The
  /// `DeidentifyTemplate` used must include only reversible transformations.
  /// Singular fields that are set in this request will replace their
  /// corresponding fields in the template. Repeated fields are appended.
  /// Singular sub-messages and groups are recursively merged.
  public var reidentifyTemplateName: String {
    get {return _storage._reidentifyTemplateName}
    set {_uniqueStorage()._reidentifyTemplateName = newValue}
  }

  /// Deprecated. This field has no effect.
  public var locationID: String {
    get {return _storage._locationID}
    set {_uniqueStorage()._locationID = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Results of re-identifying a item.
public struct Google_Privacy_Dlp_V2_ReidentifyContentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The re-identified item.
  public var item: Google_Privacy_Dlp_V2_ContentItem {
    get {return _item ?? Google_Privacy_Dlp_V2_ContentItem()}
    set {_item = newValue}
  }
  /// Returns true if `item` has been explicitly set.
  public var hasItem: Bool {return self._item != nil}
  /// Clears the value of `item`. Subsequent reads from it will return its default value.
  public mutating func clearItem() {self._item = nil}

  /// An overview of the changes that were made to the `item`.
  public var overview: Google_Privacy_Dlp_V2_TransformationOverview {
    get {return _overview ?? Google_Privacy_Dlp_V2_TransformationOverview()}
    set {_overview = newValue}
  }
  /// Returns true if `overview` has been explicitly set.
  public var hasOverview: Bool {return self._overview != nil}
  /// Clears the value of `overview`. Subsequent reads from it will return its default value.
  public mutating func clearOverview() {self._overview = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _item: Google_Privacy_Dlp_V2_ContentItem? = nil
  fileprivate var _overview: Google_Privacy_Dlp_V2_TransformationOverview? = nil
}

/// Request to search for potentially sensitive info in a ContentItem.
public struct Google_Privacy_Dlp_V2_InspectContentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Parent resource name.
  ///
  /// The format of this value varies depending on whether you have [specified a
  /// processing
  /// location](https://cloud.google.com/dlp/docs/specifying-location):
  ///
  /// + Projects scope, location specified:<br/>
  ///   `projects/`<var>PROJECT_ID</var>`/locations/`<var>LOCATION_ID</var>
  /// + Projects scope, no location specified (defaults to global):<br/>
  ///   `projects/`<var>PROJECT_ID</var>
  ///
  /// The following example `parent` string specifies a parent project with the
  /// identifier `example-project`, and specifies the `europe-west3` location
  /// for processing data:
  ///
  ///     parent=projects/example-project/locations/europe-west3
  public var parent: String = String()

  /// Configuration for the inspector. What specified here will override
  /// the template referenced by the inspect_template_name argument.
  public var inspectConfig: Google_Privacy_Dlp_V2_InspectConfig {
    get {return _inspectConfig ?? Google_Privacy_Dlp_V2_InspectConfig()}
    set {_inspectConfig = newValue}
  }
  /// Returns true if `inspectConfig` has been explicitly set.
  public var hasInspectConfig: Bool {return self._inspectConfig != nil}
  /// Clears the value of `inspectConfig`. Subsequent reads from it will return its default value.
  public mutating func clearInspectConfig() {self._inspectConfig = nil}

  /// The item to inspect.
  public var item: Google_Privacy_Dlp_V2_ContentItem {
    get {return _item ?? Google_Privacy_Dlp_V2_ContentItem()}
    set {_item = newValue}
  }
  /// Returns true if `item` has been explicitly set.
  public var hasItem: Bool {return self._item != nil}
  /// Clears the value of `item`. Subsequent reads from it will return its default value.
  public mutating func clearItem() {self._item = nil}

  /// Template to use. Any configuration directly specified in
  /// inspect_config will override those set in the template. Singular fields
  /// that are set in this request will replace their corresponding fields in the
  /// template. Repeated fields are appended. Singular sub-messages and groups
  /// are recursively merged.
  public var inspectTemplateName: String = String()

  /// Deprecated. This field has no effect.
  public var locationID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _inspectConfig: Google_Privacy_Dlp_V2_InspectConfig? = nil
  fileprivate var _item: Google_Privacy_Dlp_V2_ContentItem? = nil
}

/// Results of inspecting an item.
public struct Google_Privacy_Dlp_V2_InspectContentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The findings.
  public var result: Google_Privacy_Dlp_V2_InspectResult {
    get {return _result ?? Google_Privacy_Dlp_V2_InspectResult()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  public var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  public mutating func clearResult() {self._result = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _result: Google_Privacy_Dlp_V2_InspectResult? = nil
}

/// Cloud repository for storing output.
public struct Google_Privacy_Dlp_V2_OutputStorageConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output storage types.
  public var type: Google_Privacy_Dlp_V2_OutputStorageConfig.OneOf_Type? = nil

  /// Store findings in an existing table or a new table in an existing
  /// dataset. If table_id is not set a new one will be generated
  /// for you with the following format:
  /// dlp_googleapis_yyyy_mm_dd_[dlp_job_id]. Pacific timezone will be used for
  /// generating the date details.
  ///
  /// For Inspect, each column in an existing output table must have the same
  /// name, type, and mode of a field in the `Finding` object.
  ///
  /// For Risk, an existing output table should be the output of a previous
  /// Risk analysis job run on the same source table, with the same privacy
  /// metric and quasi-identifiers. Risk jobs that analyze the same table but
  /// compute a different privacy metric, or use different sets of
  /// quasi-identifiers, cannot store their results in the same table.
  public var table: Google_Privacy_Dlp_V2_BigQueryTable {
    get {
      if case .table(let v)? = type {return v}
      return Google_Privacy_Dlp_V2_BigQueryTable()
    }
    set {type = .table(newValue)}
  }

  /// Schema used for writing the findings for Inspect jobs. This field is only
  /// used for Inspect and must be unspecified for Risk jobs. Columns are derived
  /// from the `Finding` object. If appending to an existing table, any columns
  /// from the predefined schema that are missing will be added. No columns in
  /// the existing table will be deleted.
  ///
  /// If unspecified, then all available columns will be used for a new table or
  /// an (existing) table with no schema, and no changes will be made to an
  /// existing table that has a schema.
  /// Only for use with external storage.
  public var outputSchema: Google_Privacy_Dlp_V2_OutputStorageConfig.OutputSchema = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Output storage types.
  public enum OneOf_Type: Equatable {
    /// Store findings in an existing table or a new table in an existing
    /// dataset. If table_id is not set a new one will be generated
    /// for you with the following format:
    /// dlp_googleapis_yyyy_mm_dd_[dlp_job_id]. Pacific timezone will be used for
    /// generating the date details.
    ///
    /// For Inspect, each column in an existing output table must have the same
    /// name, type, and mode of a field in the `Finding` object.
    ///
    /// For Risk, an existing output table should be the output of a previous
    /// Risk analysis job run on the same source table, with the same privacy
    /// metric and quasi-identifiers. Risk jobs that analyze the same table but
    /// compute a different privacy metric, or use different sets of
    /// quasi-identifiers, cannot store their results in the same table.
    case table(Google_Privacy_Dlp_V2_BigQueryTable)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Privacy_Dlp_V2_OutputStorageConfig.OneOf_Type, rhs: Google_Privacy_Dlp_V2_OutputStorageConfig.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.table, .table): return {
        guard case .table(let l) = lhs, case .table(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  /// Predefined schemas for storing findings.
  /// Only for use with external storage.
  public enum OutputSchema: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unused.
    case unspecified // = 0

    /// Basic schema including only `info_type`, `quote`, `certainty`, and
    /// `timestamp`.
    case basicColumns // = 1

    /// Schema tailored to findings from scanning Google Cloud Storage.
    case gcsColumns // = 2

    /// Schema tailored to findings from scanning Google Datastore.
    case datastoreColumns // = 3

    /// Schema tailored to findings from scanning Google BigQuery.
    case bigQueryColumns // = 4

    /// Schema containing all columns.
    case allColumns // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .basicColumns
      case 2: self = .gcsColumns
      case 3: self = .datastoreColumns
      case 4: self = .bigQueryColumns
      case 5: self = .allColumns
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .basicColumns: return 1
      case .gcsColumns: return 2
      case .datastoreColumns: return 3
      case .bigQueryColumns: return 4
      case .allColumns: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Privacy_Dlp_V2_OutputStorageConfig.OutputSchema: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Privacy_Dlp_V2_OutputStorageConfig.OutputSchema] = [
    .unspecified,
    .basicColumns,
    .gcsColumns,
    .datastoreColumns,
    .bigQueryColumns,
    .allColumns,
  ]
}

#endif  // swift(>=4.2)

/// Statistics regarding a specific InfoType.
public struct Google_Privacy_Dlp_V2_InfoTypeStats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of finding this stat is for.
  public var infoType: Google_Privacy_Dlp_V2_InfoType {
    get {return _infoType ?? Google_Privacy_Dlp_V2_InfoType()}
    set {_infoType = newValue}
  }
  /// Returns true if `infoType` has been explicitly set.
  public var hasInfoType: Bool {return self._infoType != nil}
  /// Clears the value of `infoType`. Subsequent reads from it will return its default value.
  public mutating func clearInfoType() {self._infoType = nil}

  /// Number of findings for this infoType.
  public var count: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _infoType: Google_Privacy_Dlp_V2_InfoType? = nil
}

/// The results of an inspect DataSource job.
public struct Google_Privacy_Dlp_V2_InspectDataSourceDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The configuration used for this job.
  public var requestedOptions: Google_Privacy_Dlp_V2_InspectDataSourceDetails.RequestedOptions {
    get {return _requestedOptions ?? Google_Privacy_Dlp_V2_InspectDataSourceDetails.RequestedOptions()}
    set {_requestedOptions = newValue}
  }
  /// Returns true if `requestedOptions` has been explicitly set.
  public var hasRequestedOptions: Bool {return self._requestedOptions != nil}
  /// Clears the value of `requestedOptions`. Subsequent reads from it will return its default value.
  public mutating func clearRequestedOptions() {self._requestedOptions = nil}

  /// A summary of the outcome of this inspect job.
  public var result: Google_Privacy_Dlp_V2_InspectDataSourceDetails.Result {
    get {return _result ?? Google_Privacy_Dlp_V2_InspectDataSourceDetails.Result()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  public var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  public mutating func clearResult() {self._result = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Snapshot of the inspection configuration.
  public struct RequestedOptions {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// If run with an InspectTemplate, a snapshot of its state at the time of
    /// this run.
    public var snapshotInspectTemplate: Google_Privacy_Dlp_V2_InspectTemplate {
      get {return _snapshotInspectTemplate ?? Google_Privacy_Dlp_V2_InspectTemplate()}
      set {_snapshotInspectTemplate = newValue}
    }
    /// Returns true if `snapshotInspectTemplate` has been explicitly set.
    public var hasSnapshotInspectTemplate: Bool {return self._snapshotInspectTemplate != nil}
    /// Clears the value of `snapshotInspectTemplate`. Subsequent reads from it will return its default value.
    public mutating func clearSnapshotInspectTemplate() {self._snapshotInspectTemplate = nil}

    /// Inspect config.
    public var jobConfig: Google_Privacy_Dlp_V2_InspectJobConfig {
      get {return _jobConfig ?? Google_Privacy_Dlp_V2_InspectJobConfig()}
      set {_jobConfig = newValue}
    }
    /// Returns true if `jobConfig` has been explicitly set.
    public var hasJobConfig: Bool {return self._jobConfig != nil}
    /// Clears the value of `jobConfig`. Subsequent reads from it will return its default value.
    public mutating func clearJobConfig() {self._jobConfig = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _snapshotInspectTemplate: Google_Privacy_Dlp_V2_InspectTemplate? = nil
    fileprivate var _jobConfig: Google_Privacy_Dlp_V2_InspectJobConfig? = nil
  }

  /// All result fields mentioned below are updated while the job is processing.
  public struct Result {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Total size in bytes that were processed.
    public var processedBytes: Int64 = 0

    /// Estimate of the number of bytes to process.
    public var totalEstimatedBytes: Int64 = 0

    /// Statistics of how many instances of each info type were found during
    /// inspect job.
    public var infoTypeStats: [Google_Privacy_Dlp_V2_InfoTypeStats] = []

    /// Statistics related to the processing of hybrid inspect.
    /// Early access feature is in a pre-release state and might change or have
    /// limited support. For more information, see
    /// https://cloud.google.com/products#product-launch-stages.
    public var hybridStats: Google_Privacy_Dlp_V2_HybridInspectStatistics {
      get {return _hybridStats ?? Google_Privacy_Dlp_V2_HybridInspectStatistics()}
      set {_hybridStats = newValue}
    }
    /// Returns true if `hybridStats` has been explicitly set.
    public var hasHybridStats: Bool {return self._hybridStats != nil}
    /// Clears the value of `hybridStats`. Subsequent reads from it will return its default value.
    public mutating func clearHybridStats() {self._hybridStats = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _hybridStats: Google_Privacy_Dlp_V2_HybridInspectStatistics? = nil
  }

  public init() {}

  fileprivate var _requestedOptions: Google_Privacy_Dlp_V2_InspectDataSourceDetails.RequestedOptions? = nil
  fileprivate var _result: Google_Privacy_Dlp_V2_InspectDataSourceDetails.Result? = nil
}

/// Statistics related to processing hybrid inspect requests.
public struct Google_Privacy_Dlp_V2_HybridInspectStatistics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The number of hybrid inspection requests processed within this job.
  public var processedCount: Int64 = 0

  /// The number of hybrid inspection requests aborted because the job ran
  /// out of quota or was ended before they could be processed.
  public var abortedCount: Int64 = 0

  /// The number of hybrid requests currently being processed. Only populated
  /// when called via method `getDlpJob`.
  /// A burst of traffic may cause hybrid inspect requests to be enqueued.
  /// Processing will take place as quickly as possible, but resource limitations
  /// may impact how long a request is enqueued for.
  public var pendingCount: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// InfoType description.
public struct Google_Privacy_Dlp_V2_InfoTypeDescription {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Internal name of the infoType.
  public var name: String = String()

  /// Human readable form of the infoType name.
  public var displayName: String = String()

  /// Which parts of the API supports this InfoType.
  public var supportedBy: [Google_Privacy_Dlp_V2_InfoTypeSupportedBy] = []

  /// Description of the infotype. Translated when language is provided in the
  /// request.
  public var description_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request for the list of infoTypes.
public struct Google_Privacy_Dlp_V2_ListInfoTypesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The parent resource name.
  ///
  /// The format of this value is as follows:
  ///
  ///     locations/<var>LOCATION_ID</var>
  public var parent: String = String()

  /// BCP-47 language code for localized infoType friendly
  /// names. If omitted, or if localized strings are not available,
  /// en-US strings will be returned.
  public var languageCode: String = String()

  /// filter to only return infoTypes supported by certain parts of the
  /// API. Defaults to supported_by=INSPECT.
  public var filter: String = String()

  /// Deprecated. This field has no effect.
  public var locationID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response to the ListInfoTypes request.
public struct Google_Privacy_Dlp_V2_ListInfoTypesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Set of sensitive infoTypes.
  public var infoTypes: [Google_Privacy_Dlp_V2_InfoTypeDescription] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Configuration for a risk analysis job. See
/// https://cloud.google.com/dlp/docs/concepts-risk-analysis to learn more.
public struct Google_Privacy_Dlp_V2_RiskAnalysisJobConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Privacy metric to compute.
  public var privacyMetric: Google_Privacy_Dlp_V2_PrivacyMetric {
    get {return _privacyMetric ?? Google_Privacy_Dlp_V2_PrivacyMetric()}
    set {_privacyMetric = newValue}
  }
  /// Returns true if `privacyMetric` has been explicitly set.
  public var hasPrivacyMetric: Bool {return self._privacyMetric != nil}
  /// Clears the value of `privacyMetric`. Subsequent reads from it will return its default value.
  public mutating func clearPrivacyMetric() {self._privacyMetric = nil}

  /// Input dataset to compute metrics over.
  public var sourceTable: Google_Privacy_Dlp_V2_BigQueryTable {
    get {return _sourceTable ?? Google_Privacy_Dlp_V2_BigQueryTable()}
    set {_sourceTable = newValue}
  }
  /// Returns true if `sourceTable` has been explicitly set.
  public var hasSourceTable: Bool {return self._sourceTable != nil}
  /// Clears the value of `sourceTable`. Subsequent reads from it will return its default value.
  public mutating func clearSourceTable() {self._sourceTable = nil}

  /// Actions to execute at the completion of the job. Are executed in the order
  /// provided.
  public var actions: [Google_Privacy_Dlp_V2_Action] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _privacyMetric: Google_Privacy_Dlp_V2_PrivacyMetric? = nil
  fileprivate var _sourceTable: Google_Privacy_Dlp_V2_BigQueryTable? = nil
}

/// A column with a semantic tag attached.
public struct Google_Privacy_Dlp_V2_QuasiId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Identifies the column.
  public var field: Google_Privacy_Dlp_V2_FieldId {
    get {return _field ?? Google_Privacy_Dlp_V2_FieldId()}
    set {_field = newValue}
  }
  /// Returns true if `field` has been explicitly set.
  public var hasField: Bool {return self._field != nil}
  /// Clears the value of `field`. Subsequent reads from it will return its default value.
  public mutating func clearField() {self._field = nil}

  /// Semantic tag that identifies what a column contains, to determine which
  /// statistical model to use to estimate the reidentifiability of each
  /// value. [required]
  public var tag: Google_Privacy_Dlp_V2_QuasiId.OneOf_Tag? = nil

  /// A column can be tagged with a InfoType to use the relevant public
  /// dataset as a statistical model of population, if available. We
  /// currently support US ZIP codes, region codes, ages and genders.
  /// To programmatically obtain the list of supported InfoTypes, use
  /// ListInfoTypes with the supported_by=RISK_ANALYSIS filter.
  public var infoType: Google_Privacy_Dlp_V2_InfoType {
    get {
      if case .infoType(let v)? = tag {return v}
      return Google_Privacy_Dlp_V2_InfoType()
    }
    set {tag = .infoType(newValue)}
  }

  /// A column can be tagged with a custom tag. In this case, the user must
  /// indicate an auxiliary table that contains statistical information on
  /// the possible values of this column (below).
  public var customTag: String {
    get {
      if case .customTag(let v)? = tag {return v}
      return String()
    }
    set {tag = .customTag(newValue)}
  }

  /// If no semantic tag is indicated, we infer the statistical model from
  /// the distribution of values in the input data
  public var inferred: SwiftProtobuf.Google_Protobuf_Empty {
    get {
      if case .inferred(let v)? = tag {return v}
      return SwiftProtobuf.Google_Protobuf_Empty()
    }
    set {tag = .inferred(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Semantic tag that identifies what a column contains, to determine which
  /// statistical model to use to estimate the reidentifiability of each
  /// value. [required]
  public enum OneOf_Tag: Equatable {
    /// A column can be tagged with a InfoType to use the relevant public
    /// dataset as a statistical model of population, if available. We
    /// currently support US ZIP codes, region codes, ages and genders.
    /// To programmatically obtain the list of supported InfoTypes, use
    /// ListInfoTypes with the supported_by=RISK_ANALYSIS filter.
    case infoType(Google_Privacy_Dlp_V2_InfoType)
    /// A column can be tagged with a custom tag. In this case, the user must
    /// indicate an auxiliary table that contains statistical information on
    /// the possible values of this column (below).
    case customTag(String)
    /// If no semantic tag is indicated, we infer the statistical model from
    /// the distribution of values in the input data
    case inferred(SwiftProtobuf.Google_Protobuf_Empty)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Privacy_Dlp_V2_QuasiId.OneOf_Tag, rhs: Google_Privacy_Dlp_V2_QuasiId.OneOf_Tag) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.infoType, .infoType): return {
        guard case .infoType(let l) = lhs, case .infoType(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.customTag, .customTag): return {
        guard case .customTag(let l) = lhs, case .customTag(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.inferred, .inferred): return {
        guard case .inferred(let l) = lhs, case .inferred(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _field: Google_Privacy_Dlp_V2_FieldId? = nil
}

/// An auxiliary table containing statistical information on the relative
/// frequency of different quasi-identifiers values. It has one or several
/// quasi-identifiers columns, and one column that indicates the relative
/// frequency of each quasi-identifier tuple.
/// If a tuple is present in the data but not in the auxiliary table, the
/// corresponding relative frequency is assumed to be zero (and thus, the
/// tuple is highly reidentifiable).
public struct Google_Privacy_Dlp_V2_StatisticalTable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Auxiliary table location.
  public var table: Google_Privacy_Dlp_V2_BigQueryTable {
    get {return _table ?? Google_Privacy_Dlp_V2_BigQueryTable()}
    set {_table = newValue}
  }
  /// Returns true if `table` has been explicitly set.
  public var hasTable: Bool {return self._table != nil}
  /// Clears the value of `table`. Subsequent reads from it will return its default value.
  public mutating func clearTable() {self._table = nil}

  /// Required. Quasi-identifier columns.
  public var quasiIds: [Google_Privacy_Dlp_V2_StatisticalTable.QuasiIdentifierField] = []

  /// Required. The relative frequency column must contain a floating-point number
  /// between 0 and 1 (inclusive). Null values are assumed to be zero.
  public var relativeFrequency: Google_Privacy_Dlp_V2_FieldId {
    get {return _relativeFrequency ?? Google_Privacy_Dlp_V2_FieldId()}
    set {_relativeFrequency = newValue}
  }
  /// Returns true if `relativeFrequency` has been explicitly set.
  public var hasRelativeFrequency: Bool {return self._relativeFrequency != nil}
  /// Clears the value of `relativeFrequency`. Subsequent reads from it will return its default value.
  public mutating func clearRelativeFrequency() {self._relativeFrequency = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A quasi-identifier column has a custom_tag, used to know which column
  /// in the data corresponds to which column in the statistical model.
  public struct QuasiIdentifierField {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Identifies the column.
    public var field: Google_Privacy_Dlp_V2_FieldId {
      get {return _field ?? Google_Privacy_Dlp_V2_FieldId()}
      set {_field = newValue}
    }
    /// Returns true if `field` has been explicitly set.
    public var hasField: Bool {return self._field != nil}
    /// Clears the value of `field`. Subsequent reads from it will return its default value.
    public mutating func clearField() {self._field = nil}

    /// A column can be tagged with a custom tag. In this case, the user must
    /// indicate an auxiliary table that contains statistical information on
    /// the possible values of this column (below).
    public var customTag: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _field: Google_Privacy_Dlp_V2_FieldId? = nil
  }

  public init() {}

  fileprivate var _table: Google_Privacy_Dlp_V2_BigQueryTable? = nil
  fileprivate var _relativeFrequency: Google_Privacy_Dlp_V2_FieldId? = nil
}

/// Privacy metric to compute for reidentification risk analysis.
public struct Google_Privacy_Dlp_V2_PrivacyMetric {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Types of analysis.
  public var type: Google_Privacy_Dlp_V2_PrivacyMetric.OneOf_Type? = nil

  /// Numerical stats
  public var numericalStatsConfig: Google_Privacy_Dlp_V2_PrivacyMetric.NumericalStatsConfig {
    get {
      if case .numericalStatsConfig(let v)? = type {return v}
      return Google_Privacy_Dlp_V2_PrivacyMetric.NumericalStatsConfig()
    }
    set {type = .numericalStatsConfig(newValue)}
  }

  /// Categorical stats
  public var categoricalStatsConfig: Google_Privacy_Dlp_V2_PrivacyMetric.CategoricalStatsConfig {
    get {
      if case .categoricalStatsConfig(let v)? = type {return v}
      return Google_Privacy_Dlp_V2_PrivacyMetric.CategoricalStatsConfig()
    }
    set {type = .categoricalStatsConfig(newValue)}
  }

  /// K-anonymity
  public var kAnonymityConfig: Google_Privacy_Dlp_V2_PrivacyMetric.KAnonymityConfig {
    get {
      if case .kAnonymityConfig(let v)? = type {return v}
      return Google_Privacy_Dlp_V2_PrivacyMetric.KAnonymityConfig()
    }
    set {type = .kAnonymityConfig(newValue)}
  }

  /// l-diversity
  public var lDiversityConfig: Google_Privacy_Dlp_V2_PrivacyMetric.LDiversityConfig {
    get {
      if case .lDiversityConfig(let v)? = type {return v}
      return Google_Privacy_Dlp_V2_PrivacyMetric.LDiversityConfig()
    }
    set {type = .lDiversityConfig(newValue)}
  }

  /// k-map
  public var kMapEstimationConfig: Google_Privacy_Dlp_V2_PrivacyMetric.KMapEstimationConfig {
    get {
      if case .kMapEstimationConfig(let v)? = type {return v}
      return Google_Privacy_Dlp_V2_PrivacyMetric.KMapEstimationConfig()
    }
    set {type = .kMapEstimationConfig(newValue)}
  }

  /// delta-presence
  public var deltaPresenceEstimationConfig: Google_Privacy_Dlp_V2_PrivacyMetric.DeltaPresenceEstimationConfig {
    get {
      if case .deltaPresenceEstimationConfig(let v)? = type {return v}
      return Google_Privacy_Dlp_V2_PrivacyMetric.DeltaPresenceEstimationConfig()
    }
    set {type = .deltaPresenceEstimationConfig(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Types of analysis.
  public enum OneOf_Type: Equatable {
    /// Numerical stats
    case numericalStatsConfig(Google_Privacy_Dlp_V2_PrivacyMetric.NumericalStatsConfig)
    /// Categorical stats
    case categoricalStatsConfig(Google_Privacy_Dlp_V2_PrivacyMetric.CategoricalStatsConfig)
    /// K-anonymity
    case kAnonymityConfig(Google_Privacy_Dlp_V2_PrivacyMetric.KAnonymityConfig)
    /// l-diversity
    case lDiversityConfig(Google_Privacy_Dlp_V2_PrivacyMetric.LDiversityConfig)
    /// k-map
    case kMapEstimationConfig(Google_Privacy_Dlp_V2_PrivacyMetric.KMapEstimationConfig)
    /// delta-presence
    case deltaPresenceEstimationConfig(Google_Privacy_Dlp_V2_PrivacyMetric.DeltaPresenceEstimationConfig)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Privacy_Dlp_V2_PrivacyMetric.OneOf_Type, rhs: Google_Privacy_Dlp_V2_PrivacyMetric.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.numericalStatsConfig, .numericalStatsConfig): return {
        guard case .numericalStatsConfig(let l) = lhs, case .numericalStatsConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.categoricalStatsConfig, .categoricalStatsConfig): return {
        guard case .categoricalStatsConfig(let l) = lhs, case .categoricalStatsConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.kAnonymityConfig, .kAnonymityConfig): return {
        guard case .kAnonymityConfig(let l) = lhs, case .kAnonymityConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.lDiversityConfig, .lDiversityConfig): return {
        guard case .lDiversityConfig(let l) = lhs, case .lDiversityConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.kMapEstimationConfig, .kMapEstimationConfig): return {
        guard case .kMapEstimationConfig(let l) = lhs, case .kMapEstimationConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deltaPresenceEstimationConfig, .deltaPresenceEstimationConfig): return {
        guard case .deltaPresenceEstimationConfig(let l) = lhs, case .deltaPresenceEstimationConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Compute numerical stats over an individual column, including
  /// min, max, and quantiles.
  public struct NumericalStatsConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Field to compute numerical stats on. Supported types are
    /// integer, float, date, datetime, timestamp, time.
    public var field: Google_Privacy_Dlp_V2_FieldId {
      get {return _field ?? Google_Privacy_Dlp_V2_FieldId()}
      set {_field = newValue}
    }
    /// Returns true if `field` has been explicitly set.
    public var hasField: Bool {return self._field != nil}
    /// Clears the value of `field`. Subsequent reads from it will return its default value.
    public mutating func clearField() {self._field = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _field: Google_Privacy_Dlp_V2_FieldId? = nil
  }

  /// Compute numerical stats over an individual column, including
  /// number of distinct values and value count distribution.
  public struct CategoricalStatsConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Field to compute categorical stats on. All column types are
    /// supported except for arrays and structs. However, it may be more
    /// informative to use NumericalStats when the field type is supported,
    /// depending on the data.
    public var field: Google_Privacy_Dlp_V2_FieldId {
      get {return _field ?? Google_Privacy_Dlp_V2_FieldId()}
      set {_field = newValue}
    }
    /// Returns true if `field` has been explicitly set.
    public var hasField: Bool {return self._field != nil}
    /// Clears the value of `field`. Subsequent reads from it will return its default value.
    public mutating func clearField() {self._field = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _field: Google_Privacy_Dlp_V2_FieldId? = nil
  }

  /// k-anonymity metric, used for analysis of reidentification risk.
  public struct KAnonymityConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Set of fields to compute k-anonymity over. When multiple fields are
    /// specified, they are considered a single composite key. Structs and
    /// repeated data types are not supported; however, nested fields are
    /// supported so long as they are not structs themselves or nested within
    /// a repeated field.
    public var quasiIds: [Google_Privacy_Dlp_V2_FieldId] = []

    /// Message indicating that multiple rows might be associated to a
    /// single individual. If the same entity_id is associated to multiple
    /// quasi-identifier tuples over distinct rows, we consider the entire
    /// collection of tuples as the composite quasi-identifier. This collection
    /// is a multiset: the order in which the different tuples appear in the
    /// dataset is ignored, but their frequency is taken into account.
    ///
    /// Important note: a maximum of 1000 rows can be associated to a single
    /// entity ID. If more rows are associated with the same entity ID, some
    /// might be ignored.
    public var entityID: Google_Privacy_Dlp_V2_EntityId {
      get {return _entityID ?? Google_Privacy_Dlp_V2_EntityId()}
      set {_entityID = newValue}
    }
    /// Returns true if `entityID` has been explicitly set.
    public var hasEntityID: Bool {return self._entityID != nil}
    /// Clears the value of `entityID`. Subsequent reads from it will return its default value.
    public mutating func clearEntityID() {self._entityID = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _entityID: Google_Privacy_Dlp_V2_EntityId? = nil
  }

  /// l-diversity metric, used for analysis of reidentification risk.
  public struct LDiversityConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Set of quasi-identifiers indicating how equivalence classes are
    /// defined for the l-diversity computation. When multiple fields are
    /// specified, they are considered a single composite key.
    public var quasiIds: [Google_Privacy_Dlp_V2_FieldId] = []

    /// Sensitive field for computing the l-value.
    public var sensitiveAttribute: Google_Privacy_Dlp_V2_FieldId {
      get {return _sensitiveAttribute ?? Google_Privacy_Dlp_V2_FieldId()}
      set {_sensitiveAttribute = newValue}
    }
    /// Returns true if `sensitiveAttribute` has been explicitly set.
    public var hasSensitiveAttribute: Bool {return self._sensitiveAttribute != nil}
    /// Clears the value of `sensitiveAttribute`. Subsequent reads from it will return its default value.
    public mutating func clearSensitiveAttribute() {self._sensitiveAttribute = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _sensitiveAttribute: Google_Privacy_Dlp_V2_FieldId? = nil
  }

  /// Reidentifiability metric. This corresponds to a risk model similar to what
  /// is called "journalist risk" in the literature, except the attack dataset is
  /// statistically modeled instead of being perfectly known. This can be done
  /// using publicly available data (like the US Census), or using a custom
  /// statistical model (indicated as one or several BigQuery tables), or by
  /// extrapolating from the distribution of values in the input dataset.
  public struct KMapEstimationConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. Fields considered to be quasi-identifiers. No two columns can have the
    /// same tag.
    public var quasiIds: [Google_Privacy_Dlp_V2_PrivacyMetric.KMapEstimationConfig.TaggedField] = []

    /// ISO 3166-1 alpha-2 region code to use in the statistical modeling.
    /// Set if no column is tagged with a region-specific InfoType (like
    /// US_ZIP_5) or a region code.
    public var regionCode: String = String()

    /// Several auxiliary tables can be used in the analysis. Each custom_tag
    /// used to tag a quasi-identifiers column must appear in exactly one column
    /// of one auxiliary table.
    public var auxiliaryTables: [Google_Privacy_Dlp_V2_PrivacyMetric.KMapEstimationConfig.AuxiliaryTable] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// A column with a semantic tag attached.
    public struct TaggedField {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Required. Identifies the column.
      public var field: Google_Privacy_Dlp_V2_FieldId {
        get {return _field ?? Google_Privacy_Dlp_V2_FieldId()}
        set {_field = newValue}
      }
      /// Returns true if `field` has been explicitly set.
      public var hasField: Bool {return self._field != nil}
      /// Clears the value of `field`. Subsequent reads from it will return its default value.
      public mutating func clearField() {self._field = nil}

      /// Semantic tag that identifies what a column contains, to determine which
      /// statistical model to use to estimate the reidentifiability of each
      /// value. [required]
      public var tag: Google_Privacy_Dlp_V2_PrivacyMetric.KMapEstimationConfig.TaggedField.OneOf_Tag? = nil

      /// A column can be tagged with a InfoType to use the relevant public
      /// dataset as a statistical model of population, if available. We
      /// currently support US ZIP codes, region codes, ages and genders.
      /// To programmatically obtain the list of supported InfoTypes, use
      /// ListInfoTypes with the supported_by=RISK_ANALYSIS filter.
      public var infoType: Google_Privacy_Dlp_V2_InfoType {
        get {
          if case .infoType(let v)? = tag {return v}
          return Google_Privacy_Dlp_V2_InfoType()
        }
        set {tag = .infoType(newValue)}
      }

      /// A column can be tagged with a custom tag. In this case, the user must
      /// indicate an auxiliary table that contains statistical information on
      /// the possible values of this column (below).
      public var customTag: String {
        get {
          if case .customTag(let v)? = tag {return v}
          return String()
        }
        set {tag = .customTag(newValue)}
      }

      /// If no semantic tag is indicated, we infer the statistical model from
      /// the distribution of values in the input data
      public var inferred: SwiftProtobuf.Google_Protobuf_Empty {
        get {
          if case .inferred(let v)? = tag {return v}
          return SwiftProtobuf.Google_Protobuf_Empty()
        }
        set {tag = .inferred(newValue)}
      }

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      /// Semantic tag that identifies what a column contains, to determine which
      /// statistical model to use to estimate the reidentifiability of each
      /// value. [required]
      public enum OneOf_Tag: Equatable {
        /// A column can be tagged with a InfoType to use the relevant public
        /// dataset as a statistical model of population, if available. We
        /// currently support US ZIP codes, region codes, ages and genders.
        /// To programmatically obtain the list of supported InfoTypes, use
        /// ListInfoTypes with the supported_by=RISK_ANALYSIS filter.
        case infoType(Google_Privacy_Dlp_V2_InfoType)
        /// A column can be tagged with a custom tag. In this case, the user must
        /// indicate an auxiliary table that contains statistical information on
        /// the possible values of this column (below).
        case customTag(String)
        /// If no semantic tag is indicated, we infer the statistical model from
        /// the distribution of values in the input data
        case inferred(SwiftProtobuf.Google_Protobuf_Empty)

      #if !swift(>=4.1)
        public static func ==(lhs: Google_Privacy_Dlp_V2_PrivacyMetric.KMapEstimationConfig.TaggedField.OneOf_Tag, rhs: Google_Privacy_Dlp_V2_PrivacyMetric.KMapEstimationConfig.TaggedField.OneOf_Tag) -> Bool {
          // The use of inline closures is to circumvent an issue where the compiler
          // allocates stack space for every case branch when no optimizations are
          // enabled. https://github.com/apple/swift-protobuf/issues/1034
          switch (lhs, rhs) {
          case (.infoType, .infoType): return {
            guard case .infoType(let l) = lhs, case .infoType(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.customTag, .customTag): return {
            guard case .customTag(let l) = lhs, case .customTag(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.inferred, .inferred): return {
            guard case .inferred(let l) = lhs, case .inferred(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          default: return false
          }
        }
      #endif
      }

      public init() {}

      fileprivate var _field: Google_Privacy_Dlp_V2_FieldId? = nil
    }

    /// An auxiliary table contains statistical information on the relative
    /// frequency of different quasi-identifiers values. It has one or several
    /// quasi-identifiers columns, and one column that indicates the relative
    /// frequency of each quasi-identifier tuple.
    /// If a tuple is present in the data but not in the auxiliary table, the
    /// corresponding relative frequency is assumed to be zero (and thus, the
    /// tuple is highly reidentifiable).
    public struct AuxiliaryTable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Required. Auxiliary table location.
      public var table: Google_Privacy_Dlp_V2_BigQueryTable {
        get {return _table ?? Google_Privacy_Dlp_V2_BigQueryTable()}
        set {_table = newValue}
      }
      /// Returns true if `table` has been explicitly set.
      public var hasTable: Bool {return self._table != nil}
      /// Clears the value of `table`. Subsequent reads from it will return its default value.
      public mutating func clearTable() {self._table = nil}

      /// Required. Quasi-identifier columns.
      public var quasiIds: [Google_Privacy_Dlp_V2_PrivacyMetric.KMapEstimationConfig.AuxiliaryTable.QuasiIdField] = []

      /// Required. The relative frequency column must contain a floating-point number
      /// between 0 and 1 (inclusive). Null values are assumed to be zero.
      public var relativeFrequency: Google_Privacy_Dlp_V2_FieldId {
        get {return _relativeFrequency ?? Google_Privacy_Dlp_V2_FieldId()}
        set {_relativeFrequency = newValue}
      }
      /// Returns true if `relativeFrequency` has been explicitly set.
      public var hasRelativeFrequency: Bool {return self._relativeFrequency != nil}
      /// Clears the value of `relativeFrequency`. Subsequent reads from it will return its default value.
      public mutating func clearRelativeFrequency() {self._relativeFrequency = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      /// A quasi-identifier column has a custom_tag, used to know which column
      /// in the data corresponds to which column in the statistical model.
      public struct QuasiIdField {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// Identifies the column.
        public var field: Google_Privacy_Dlp_V2_FieldId {
          get {return _field ?? Google_Privacy_Dlp_V2_FieldId()}
          set {_field = newValue}
        }
        /// Returns true if `field` has been explicitly set.
        public var hasField: Bool {return self._field != nil}
        /// Clears the value of `field`. Subsequent reads from it will return its default value.
        public mutating func clearField() {self._field = nil}

        /// A auxiliary field.
        public var customTag: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _field: Google_Privacy_Dlp_V2_FieldId? = nil
      }

      public init() {}

      fileprivate var _table: Google_Privacy_Dlp_V2_BigQueryTable? = nil
      fileprivate var _relativeFrequency: Google_Privacy_Dlp_V2_FieldId? = nil
    }

    public init() {}
  }

  /// δ-presence metric, used to estimate how likely it is for an attacker to
  /// figure out that one given individual appears in a de-identified dataset.
  /// Similarly to the k-map metric, we cannot compute δ-presence exactly without
  /// knowing the attack dataset, so we use a statistical model instead.
  public struct DeltaPresenceEstimationConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. Fields considered to be quasi-identifiers. No two fields can have the
    /// same tag.
    public var quasiIds: [Google_Privacy_Dlp_V2_QuasiId] = []

    /// ISO 3166-1 alpha-2 region code to use in the statistical modeling.
    /// Set if no column is tagged with a region-specific InfoType (like
    /// US_ZIP_5) or a region code.
    public var regionCode: String = String()

    /// Several auxiliary tables can be used in the analysis. Each custom_tag
    /// used to tag a quasi-identifiers field must appear in exactly one
    /// field of one auxiliary table.
    public var auxiliaryTables: [Google_Privacy_Dlp_V2_StatisticalTable] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Result of a risk analysis operation request.
public struct Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Privacy metric to compute.
  public var requestedPrivacyMetric: Google_Privacy_Dlp_V2_PrivacyMetric {
    get {return _storage._requestedPrivacyMetric ?? Google_Privacy_Dlp_V2_PrivacyMetric()}
    set {_uniqueStorage()._requestedPrivacyMetric = newValue}
  }
  /// Returns true if `requestedPrivacyMetric` has been explicitly set.
  public var hasRequestedPrivacyMetric: Bool {return _storage._requestedPrivacyMetric != nil}
  /// Clears the value of `requestedPrivacyMetric`. Subsequent reads from it will return its default value.
  public mutating func clearRequestedPrivacyMetric() {_uniqueStorage()._requestedPrivacyMetric = nil}

  /// Input dataset to compute metrics over.
  public var requestedSourceTable: Google_Privacy_Dlp_V2_BigQueryTable {
    get {return _storage._requestedSourceTable ?? Google_Privacy_Dlp_V2_BigQueryTable()}
    set {_uniqueStorage()._requestedSourceTable = newValue}
  }
  /// Returns true if `requestedSourceTable` has been explicitly set.
  public var hasRequestedSourceTable: Bool {return _storage._requestedSourceTable != nil}
  /// Clears the value of `requestedSourceTable`. Subsequent reads from it will return its default value.
  public mutating func clearRequestedSourceTable() {_uniqueStorage()._requestedSourceTable = nil}

  /// Values associated with this metric.
  public var result: OneOf_Result? {
    get {return _storage._result}
    set {_uniqueStorage()._result = newValue}
  }

  /// Numerical stats result
  public var numericalStatsResult: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.NumericalStatsResult {
    get {
      if case .numericalStatsResult(let v)? = _storage._result {return v}
      return Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.NumericalStatsResult()
    }
    set {_uniqueStorage()._result = .numericalStatsResult(newValue)}
  }

  /// Categorical stats result
  public var categoricalStatsResult: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.CategoricalStatsResult {
    get {
      if case .categoricalStatsResult(let v)? = _storage._result {return v}
      return Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.CategoricalStatsResult()
    }
    set {_uniqueStorage()._result = .categoricalStatsResult(newValue)}
  }

  /// K-anonymity result
  public var kAnonymityResult: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.KAnonymityResult {
    get {
      if case .kAnonymityResult(let v)? = _storage._result {return v}
      return Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.KAnonymityResult()
    }
    set {_uniqueStorage()._result = .kAnonymityResult(newValue)}
  }

  /// L-divesity result
  public var lDiversityResult: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.LDiversityResult {
    get {
      if case .lDiversityResult(let v)? = _storage._result {return v}
      return Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.LDiversityResult()
    }
    set {_uniqueStorage()._result = .lDiversityResult(newValue)}
  }

  /// K-map result
  public var kMapEstimationResult: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.KMapEstimationResult {
    get {
      if case .kMapEstimationResult(let v)? = _storage._result {return v}
      return Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.KMapEstimationResult()
    }
    set {_uniqueStorage()._result = .kMapEstimationResult(newValue)}
  }

  /// Delta-presence result
  public var deltaPresenceEstimationResult: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.DeltaPresenceEstimationResult {
    get {
      if case .deltaPresenceEstimationResult(let v)? = _storage._result {return v}
      return Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.DeltaPresenceEstimationResult()
    }
    set {_uniqueStorage()._result = .deltaPresenceEstimationResult(newValue)}
  }

  /// The configuration used for this job.
  public var requestedOptions: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.RequestedRiskAnalysisOptions {
    get {return _storage._requestedOptions ?? Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.RequestedRiskAnalysisOptions()}
    set {_uniqueStorage()._requestedOptions = newValue}
  }
  /// Returns true if `requestedOptions` has been explicitly set.
  public var hasRequestedOptions: Bool {return _storage._requestedOptions != nil}
  /// Clears the value of `requestedOptions`. Subsequent reads from it will return its default value.
  public mutating func clearRequestedOptions() {_uniqueStorage()._requestedOptions = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Values associated with this metric.
  public enum OneOf_Result: Equatable {
    /// Numerical stats result
    case numericalStatsResult(Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.NumericalStatsResult)
    /// Categorical stats result
    case categoricalStatsResult(Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.CategoricalStatsResult)
    /// K-anonymity result
    case kAnonymityResult(Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.KAnonymityResult)
    /// L-divesity result
    case lDiversityResult(Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.LDiversityResult)
    /// K-map result
    case kMapEstimationResult(Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.KMapEstimationResult)
    /// Delta-presence result
    case deltaPresenceEstimationResult(Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.DeltaPresenceEstimationResult)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.OneOf_Result, rhs: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.OneOf_Result) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.numericalStatsResult, .numericalStatsResult): return {
        guard case .numericalStatsResult(let l) = lhs, case .numericalStatsResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.categoricalStatsResult, .categoricalStatsResult): return {
        guard case .categoricalStatsResult(let l) = lhs, case .categoricalStatsResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.kAnonymityResult, .kAnonymityResult): return {
        guard case .kAnonymityResult(let l) = lhs, case .kAnonymityResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.lDiversityResult, .lDiversityResult): return {
        guard case .lDiversityResult(let l) = lhs, case .lDiversityResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.kMapEstimationResult, .kMapEstimationResult): return {
        guard case .kMapEstimationResult(let l) = lhs, case .kMapEstimationResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deltaPresenceEstimationResult, .deltaPresenceEstimationResult): return {
        guard case .deltaPresenceEstimationResult(let l) = lhs, case .deltaPresenceEstimationResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Result of the numerical stats computation.
  public struct NumericalStatsResult {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Minimum value appearing in the column.
    public var minValue: Google_Privacy_Dlp_V2_Value {
      get {return _minValue ?? Google_Privacy_Dlp_V2_Value()}
      set {_minValue = newValue}
    }
    /// Returns true if `minValue` has been explicitly set.
    public var hasMinValue: Bool {return self._minValue != nil}
    /// Clears the value of `minValue`. Subsequent reads from it will return its default value.
    public mutating func clearMinValue() {self._minValue = nil}

    /// Maximum value appearing in the column.
    public var maxValue: Google_Privacy_Dlp_V2_Value {
      get {return _maxValue ?? Google_Privacy_Dlp_V2_Value()}
      set {_maxValue = newValue}
    }
    /// Returns true if `maxValue` has been explicitly set.
    public var hasMaxValue: Bool {return self._maxValue != nil}
    /// Clears the value of `maxValue`. Subsequent reads from it will return its default value.
    public mutating func clearMaxValue() {self._maxValue = nil}

    /// List of 99 values that partition the set of field values into 100 equal
    /// sized buckets.
    public var quantileValues: [Google_Privacy_Dlp_V2_Value] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _minValue: Google_Privacy_Dlp_V2_Value? = nil
    fileprivate var _maxValue: Google_Privacy_Dlp_V2_Value? = nil
  }

  /// Result of the categorical stats computation.
  public struct CategoricalStatsResult {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Histogram of value frequencies in the column.
    public var valueFrequencyHistogramBuckets: [Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.CategoricalStatsResult.CategoricalStatsHistogramBucket] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Histogram of value frequencies in the column.
    public struct CategoricalStatsHistogramBucket {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Lower bound on the value frequency of the values in this bucket.
      public var valueFrequencyLowerBound: Int64 = 0

      /// Upper bound on the value frequency of the values in this bucket.
      public var valueFrequencyUpperBound: Int64 = 0

      /// Total number of values in this bucket.
      public var bucketSize: Int64 = 0

      /// Sample of value frequencies in this bucket. The total number of
      /// values returned per bucket is capped at 20.
      public var bucketValues: [Google_Privacy_Dlp_V2_ValueFrequency] = []

      /// Total number of distinct values in this bucket.
      public var bucketValueCount: Int64 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  /// Result of the k-anonymity computation.
  public struct KAnonymityResult {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Histogram of k-anonymity equivalence classes.
    public var equivalenceClassHistogramBuckets: [Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.KAnonymityResult.KAnonymityHistogramBucket] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The set of columns' values that share the same ldiversity value
    public struct KAnonymityEquivalenceClass {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Set of values defining the equivalence class. One value per
      /// quasi-identifier column in the original KAnonymity metric message.
      /// The order is always the same as the original request.
      public var quasiIdsValues: [Google_Privacy_Dlp_V2_Value] = []

      /// Size of the equivalence class, for example number of rows with the
      /// above set of values.
      public var equivalenceClassSize: Int64 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// Histogram of k-anonymity equivalence classes.
    public struct KAnonymityHistogramBucket {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Lower bound on the size of the equivalence classes in this bucket.
      public var equivalenceClassSizeLowerBound: Int64 = 0

      /// Upper bound on the size of the equivalence classes in this bucket.
      public var equivalenceClassSizeUpperBound: Int64 = 0

      /// Total number of equivalence classes in this bucket.
      public var bucketSize: Int64 = 0

      /// Sample of equivalence classes in this bucket. The total number of
      /// classes returned per bucket is capped at 20.
      public var bucketValues: [Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.KAnonymityResult.KAnonymityEquivalenceClass] = []

      /// Total number of distinct equivalence classes in this bucket.
      public var bucketValueCount: Int64 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  /// Result of the l-diversity computation.
  public struct LDiversityResult {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Histogram of l-diversity equivalence class sensitive value frequencies.
    public var sensitiveValueFrequencyHistogramBuckets: [Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.LDiversityResult.LDiversityHistogramBucket] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The set of columns' values that share the same ldiversity value.
    public struct LDiversityEquivalenceClass {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Quasi-identifier values defining the k-anonymity equivalence
      /// class. The order is always the same as the original request.
      public var quasiIdsValues: [Google_Privacy_Dlp_V2_Value] = []

      /// Size of the k-anonymity equivalence class.
      public var equivalenceClassSize: Int64 = 0

      /// Number of distinct sensitive values in this equivalence class.
      public var numDistinctSensitiveValues: Int64 = 0

      /// Estimated frequencies of top sensitive values.
      public var topSensitiveValues: [Google_Privacy_Dlp_V2_ValueFrequency] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// Histogram of l-diversity equivalence class sensitive value frequencies.
    public struct LDiversityHistogramBucket {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Lower bound on the sensitive value frequencies of the equivalence
      /// classes in this bucket.
      public var sensitiveValueFrequencyLowerBound: Int64 = 0

      /// Upper bound on the sensitive value frequencies of the equivalence
      /// classes in this bucket.
      public var sensitiveValueFrequencyUpperBound: Int64 = 0

      /// Total number of equivalence classes in this bucket.
      public var bucketSize: Int64 = 0

      /// Sample of equivalence classes in this bucket. The total number of
      /// classes returned per bucket is capped at 20.
      public var bucketValues: [Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.LDiversityResult.LDiversityEquivalenceClass] = []

      /// Total number of distinct equivalence classes in this bucket.
      public var bucketValueCount: Int64 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  /// Result of the reidentifiability analysis. Note that these results are an
  /// estimation, not exact values.
  public struct KMapEstimationResult {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The intervals [min_anonymity, max_anonymity] do not overlap. If a value
    /// doesn't correspond to any such interval, the associated frequency is
    /// zero. For example, the following records:
    ///   {min_anonymity: 1, max_anonymity: 1, frequency: 17}
    ///   {min_anonymity: 2, max_anonymity: 3, frequency: 42}
    ///   {min_anonymity: 5, max_anonymity: 10, frequency: 99}
    /// mean that there are no record with an estimated anonymity of 4, 5, or
    /// larger than 10.
    public var kMapEstimationHistogram: [Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.KMapEstimationResult.KMapEstimationHistogramBucket] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// A tuple of values for the quasi-identifier columns.
    public struct KMapEstimationQuasiIdValues {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The quasi-identifier values.
      public var quasiIdsValues: [Google_Privacy_Dlp_V2_Value] = []

      /// The estimated anonymity for these quasi-identifier values.
      public var estimatedAnonymity: Int64 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// A KMapEstimationHistogramBucket message with the following values:
    ///   min_anonymity: 3
    ///   max_anonymity: 5
    ///   frequency: 42
    /// means that there are 42 records whose quasi-identifier values correspond
    /// to 3, 4 or 5 people in the overlying population. An important particular
    /// case is when min_anonymity = max_anonymity = 1: the frequency field then
    /// corresponds to the number of uniquely identifiable records.
    public struct KMapEstimationHistogramBucket {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Always positive.
      public var minAnonymity: Int64 = 0

      /// Always greater than or equal to min_anonymity.
      public var maxAnonymity: Int64 = 0

      /// Number of records within these anonymity bounds.
      public var bucketSize: Int64 = 0

      /// Sample of quasi-identifier tuple values in this bucket. The total
      /// number of classes returned per bucket is capped at 20.
      public var bucketValues: [Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.KMapEstimationResult.KMapEstimationQuasiIdValues] = []

      /// Total number of distinct quasi-identifier tuple values in this bucket.
      public var bucketValueCount: Int64 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  /// Result of the δ-presence computation. Note that these results are an
  /// estimation, not exact values.
  public struct DeltaPresenceEstimationResult {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The intervals [min_probability, max_probability) do not overlap. If a
    /// value doesn't correspond to any such interval, the associated frequency
    /// is zero. For example, the following records:
    ///   {min_probability: 0, max_probability: 0.1, frequency: 17}
    ///   {min_probability: 0.2, max_probability: 0.3, frequency: 42}
    ///   {min_probability: 0.3, max_probability: 0.4, frequency: 99}
    /// mean that there are no record with an estimated probability in [0.1, 0.2)
    /// nor larger or equal to 0.4.
    public var deltaPresenceEstimationHistogram: [Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.DeltaPresenceEstimationResult.DeltaPresenceEstimationHistogramBucket] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// A tuple of values for the quasi-identifier columns.
    public struct DeltaPresenceEstimationQuasiIdValues {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The quasi-identifier values.
      public var quasiIdsValues: [Google_Privacy_Dlp_V2_Value] = []

      /// The estimated probability that a given individual sharing these
      /// quasi-identifier values is in the dataset. This value, typically called
      /// δ, is the ratio between the number of records in the dataset with these
      /// quasi-identifier values, and the total number of individuals (inside
      /// *and* outside the dataset) with these quasi-identifier values.
      /// For example, if there are 15 individuals in the dataset who share the
      /// same quasi-identifier values, and an estimated 100 people in the entire
      /// population with these values, then δ is 0.15.
      public var estimatedProbability: Double = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// A DeltaPresenceEstimationHistogramBucket message with the following
    /// values:
    ///   min_probability: 0.1
    ///   max_probability: 0.2
    ///   frequency: 42
    /// means that there are 42 records for which δ is in [0.1, 0.2). An
    /// important particular case is when min_probability = max_probability = 1:
    /// then, every individual who shares this quasi-identifier combination is in
    /// the dataset.
    public struct DeltaPresenceEstimationHistogramBucket {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Between 0 and 1.
      public var minProbability: Double = 0

      /// Always greater than or equal to min_probability.
      public var maxProbability: Double = 0

      /// Number of records within these probability bounds.
      public var bucketSize: Int64 = 0

      /// Sample of quasi-identifier tuple values in this bucket. The total
      /// number of classes returned per bucket is capped at 20.
      public var bucketValues: [Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.DeltaPresenceEstimationResult.DeltaPresenceEstimationQuasiIdValues] = []

      /// Total number of distinct quasi-identifier tuple values in this bucket.
      public var bucketValueCount: Int64 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  /// Risk analysis options.
  public struct RequestedRiskAnalysisOptions {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The job config for the risk job.
    public var jobConfig: Google_Privacy_Dlp_V2_RiskAnalysisJobConfig {
      get {return _jobConfig ?? Google_Privacy_Dlp_V2_RiskAnalysisJobConfig()}
      set {_jobConfig = newValue}
    }
    /// Returns true if `jobConfig` has been explicitly set.
    public var hasJobConfig: Bool {return self._jobConfig != nil}
    /// Clears the value of `jobConfig`. Subsequent reads from it will return its default value.
    public mutating func clearJobConfig() {self._jobConfig = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _jobConfig: Google_Privacy_Dlp_V2_RiskAnalysisJobConfig? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A value of a field, including its frequency.
public struct Google_Privacy_Dlp_V2_ValueFrequency {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A value contained in the field in question.
  public var value: Google_Privacy_Dlp_V2_Value {
    get {return _value ?? Google_Privacy_Dlp_V2_Value()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  /// How many times the value is contained in the field.
  public var count: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _value: Google_Privacy_Dlp_V2_Value? = nil
}

/// Set of primitive values supported by the system.
/// Note that for the purposes of inspection or transformation, the number
/// of bytes considered to comprise a 'Value' is based on its representation
/// as a UTF-8 encoded string. For example, if 'integer_value' is set to
/// 123456789, the number of bytes would be counted as 9, even though an
/// int64 only holds up to 8 bytes of data.
public struct Google_Privacy_Dlp_V2_Value {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Value types
  public var type: Google_Privacy_Dlp_V2_Value.OneOf_Type? = nil

  /// integer
  public var integerValue: Int64 {
    get {
      if case .integerValue(let v)? = type {return v}
      return 0
    }
    set {type = .integerValue(newValue)}
  }

  /// float
  public var floatValue: Double {
    get {
      if case .floatValue(let v)? = type {return v}
      return 0
    }
    set {type = .floatValue(newValue)}
  }

  /// string
  public var stringValue: String {
    get {
      if case .stringValue(let v)? = type {return v}
      return String()
    }
    set {type = .stringValue(newValue)}
  }

  /// boolean
  public var booleanValue: Bool {
    get {
      if case .booleanValue(let v)? = type {return v}
      return false
    }
    set {type = .booleanValue(newValue)}
  }

  /// timestamp
  public var timestampValue: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {
      if case .timestampValue(let v)? = type {return v}
      return SwiftProtobuf.Google_Protobuf_Timestamp()
    }
    set {type = .timestampValue(newValue)}
  }

  /// time of day
  public var timeValue: Google_Type_TimeOfDay {
    get {
      if case .timeValue(let v)? = type {return v}
      return Google_Type_TimeOfDay()
    }
    set {type = .timeValue(newValue)}
  }

  /// date
  public var dateValue: Google_Type_Date {
    get {
      if case .dateValue(let v)? = type {return v}
      return Google_Type_Date()
    }
    set {type = .dateValue(newValue)}
  }

  /// day of week
  public var dayOfWeekValue: Google_Type_DayOfWeek {
    get {
      if case .dayOfWeekValue(let v)? = type {return v}
      return .unspecified
    }
    set {type = .dayOfWeekValue(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Value types
  public enum OneOf_Type: Equatable {
    /// integer
    case integerValue(Int64)
    /// float
    case floatValue(Double)
    /// string
    case stringValue(String)
    /// boolean
    case booleanValue(Bool)
    /// timestamp
    case timestampValue(SwiftProtobuf.Google_Protobuf_Timestamp)
    /// time of day
    case timeValue(Google_Type_TimeOfDay)
    /// date
    case dateValue(Google_Type_Date)
    /// day of week
    case dayOfWeekValue(Google_Type_DayOfWeek)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Privacy_Dlp_V2_Value.OneOf_Type, rhs: Google_Privacy_Dlp_V2_Value.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.integerValue, .integerValue): return {
        guard case .integerValue(let l) = lhs, case .integerValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.floatValue, .floatValue): return {
        guard case .floatValue(let l) = lhs, case .floatValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stringValue, .stringValue): return {
        guard case .stringValue(let l) = lhs, case .stringValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.booleanValue, .booleanValue): return {
        guard case .booleanValue(let l) = lhs, case .booleanValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.timestampValue, .timestampValue): return {
        guard case .timestampValue(let l) = lhs, case .timestampValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.timeValue, .timeValue): return {
        guard case .timeValue(let l) = lhs, case .timeValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dateValue, .dateValue): return {
        guard case .dateValue(let l) = lhs, case .dateValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dayOfWeekValue, .dayOfWeekValue): return {
        guard case .dayOfWeekValue(let l) = lhs, case .dayOfWeekValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Message for infoType-dependent details parsed from quote.
public struct Google_Privacy_Dlp_V2_QuoteInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Object representation of the quote.
  public var parsedQuote: Google_Privacy_Dlp_V2_QuoteInfo.OneOf_ParsedQuote? = nil

  /// The date time indicated by the quote.
  public var dateTime: Google_Privacy_Dlp_V2_DateTime {
    get {
      if case .dateTime(let v)? = parsedQuote {return v}
      return Google_Privacy_Dlp_V2_DateTime()
    }
    set {parsedQuote = .dateTime(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Object representation of the quote.
  public enum OneOf_ParsedQuote: Equatable {
    /// The date time indicated by the quote.
    case dateTime(Google_Privacy_Dlp_V2_DateTime)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Privacy_Dlp_V2_QuoteInfo.OneOf_ParsedQuote, rhs: Google_Privacy_Dlp_V2_QuoteInfo.OneOf_ParsedQuote) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.dateTime, .dateTime): return {
        guard case .dateTime(let l) = lhs, case .dateTime(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

/// Message for a date time object.
/// e.g. 2018-01-01, 5th August.
public struct Google_Privacy_Dlp_V2_DateTime {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// One or more of the following must be set.
  /// Must be a valid date or time value.
  public var date: Google_Type_Date {
    get {return _date ?? Google_Type_Date()}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  public var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  public mutating func clearDate() {self._date = nil}

  /// Day of week
  public var dayOfWeek: Google_Type_DayOfWeek = .unspecified

  /// Time of day
  public var time: Google_Type_TimeOfDay {
    get {return _time ?? Google_Type_TimeOfDay()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  /// Time zone
  public var timeZone: Google_Privacy_Dlp_V2_DateTime.TimeZone {
    get {return _timeZone ?? Google_Privacy_Dlp_V2_DateTime.TimeZone()}
    set {_timeZone = newValue}
  }
  /// Returns true if `timeZone` has been explicitly set.
  public var hasTimeZone: Bool {return self._timeZone != nil}
  /// Clears the value of `timeZone`. Subsequent reads from it will return its default value.
  public mutating func clearTimeZone() {self._timeZone = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Time zone of the date time object.
  public struct TimeZone {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Set only if the offset can be determined. Positive for time ahead of UTC.
    /// E.g. For "UTC-9", this value is -540.
    public var offsetMinutes: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _date: Google_Type_Date? = nil
  fileprivate var _time: Google_Type_TimeOfDay? = nil
  fileprivate var _timeZone: Google_Privacy_Dlp_V2_DateTime.TimeZone? = nil
}

/// The configuration that controls how the data will change.
public struct Google_Privacy_Dlp_V2_DeidentifyConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var transformation: Google_Privacy_Dlp_V2_DeidentifyConfig.OneOf_Transformation? = nil

  /// Treat the dataset as free-form text and apply the same free text
  /// transformation everywhere.
  public var infoTypeTransformations: Google_Privacy_Dlp_V2_InfoTypeTransformations {
    get {
      if case .infoTypeTransformations(let v)? = transformation {return v}
      return Google_Privacy_Dlp_V2_InfoTypeTransformations()
    }
    set {transformation = .infoTypeTransformations(newValue)}
  }

  /// Treat the dataset as structured. Transformations can be applied to
  /// specific locations within structured datasets, such as transforming
  /// a column within a table.
  public var recordTransformations: Google_Privacy_Dlp_V2_RecordTransformations {
    get {
      if case .recordTransformations(let v)? = transformation {return v}
      return Google_Privacy_Dlp_V2_RecordTransformations()
    }
    set {transformation = .recordTransformations(newValue)}
  }

  /// Mode for handling transformation errors. If left unspecified, the default
  /// mode is `TransformationErrorHandling.ThrowError`.
  public var transformationErrorHandling: Google_Privacy_Dlp_V2_TransformationErrorHandling {
    get {return _transformationErrorHandling ?? Google_Privacy_Dlp_V2_TransformationErrorHandling()}
    set {_transformationErrorHandling = newValue}
  }
  /// Returns true if `transformationErrorHandling` has been explicitly set.
  public var hasTransformationErrorHandling: Bool {return self._transformationErrorHandling != nil}
  /// Clears the value of `transformationErrorHandling`. Subsequent reads from it will return its default value.
  public mutating func clearTransformationErrorHandling() {self._transformationErrorHandling = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Transformation: Equatable {
    /// Treat the dataset as free-form text and apply the same free text
    /// transformation everywhere.
    case infoTypeTransformations(Google_Privacy_Dlp_V2_InfoTypeTransformations)
    /// Treat the dataset as structured. Transformations can be applied to
    /// specific locations within structured datasets, such as transforming
    /// a column within a table.
    case recordTransformations(Google_Privacy_Dlp_V2_RecordTransformations)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Privacy_Dlp_V2_DeidentifyConfig.OneOf_Transformation, rhs: Google_Privacy_Dlp_V2_DeidentifyConfig.OneOf_Transformation) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.infoTypeTransformations, .infoTypeTransformations): return {
        guard case .infoTypeTransformations(let l) = lhs, case .infoTypeTransformations(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.recordTransformations, .recordTransformations): return {
        guard case .recordTransformations(let l) = lhs, case .recordTransformations(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _transformationErrorHandling: Google_Privacy_Dlp_V2_TransformationErrorHandling? = nil
}

/// How to handle transformation errors during de-identification. A
/// transformation error occurs when the requested transformation is incompatible
/// with the data. For example, trying to de-identify an IP address using a
/// `DateShift` transformation would result in a transformation error, since date
/// info cannot be extracted from an IP address.
/// Information about any incompatible transformations, and how they were
/// handled, is returned in the response as part of the
/// `TransformationOverviews`.
public struct Google_Privacy_Dlp_V2_TransformationErrorHandling {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// How transformation errors should be handled.
  public var mode: Google_Privacy_Dlp_V2_TransformationErrorHandling.OneOf_Mode? = nil

  /// Throw an error
  public var throwError: Google_Privacy_Dlp_V2_TransformationErrorHandling.ThrowError {
    get {
      if case .throwError(let v)? = mode {return v}
      return Google_Privacy_Dlp_V2_TransformationErrorHandling.ThrowError()
    }
    set {mode = .throwError(newValue)}
  }

  /// Ignore errors
  public var leaveUntransformed: Google_Privacy_Dlp_V2_TransformationErrorHandling.LeaveUntransformed {
    get {
      if case .leaveUntransformed(let v)? = mode {return v}
      return Google_Privacy_Dlp_V2_TransformationErrorHandling.LeaveUntransformed()
    }
    set {mode = .leaveUntransformed(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// How transformation errors should be handled.
  public enum OneOf_Mode: Equatable {
    /// Throw an error
    case throwError(Google_Privacy_Dlp_V2_TransformationErrorHandling.ThrowError)
    /// Ignore errors
    case leaveUntransformed(Google_Privacy_Dlp_V2_TransformationErrorHandling.LeaveUntransformed)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Privacy_Dlp_V2_TransformationErrorHandling.OneOf_Mode, rhs: Google_Privacy_Dlp_V2_TransformationErrorHandling.OneOf_Mode) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.throwError, .throwError): return {
        guard case .throwError(let l) = lhs, case .throwError(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.leaveUntransformed, .leaveUntransformed): return {
        guard case .leaveUntransformed(let l) = lhs, case .leaveUntransformed(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Throw an error and fail the request when a transformation error occurs.
  public struct ThrowError {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Skips the data without modifying it if the requested transformation would
  /// cause an error. For example, if a `DateShift` transformation were applied
  /// an an IP address, this mode would leave the IP address unchanged in the
  /// response.
  public struct LeaveUntransformed {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// A rule for transforming a value.
public struct Google_Privacy_Dlp_V2_PrimitiveTransformation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var transformation: Google_Privacy_Dlp_V2_PrimitiveTransformation.OneOf_Transformation? = nil

  /// Replace
  public var replaceConfig: Google_Privacy_Dlp_V2_ReplaceValueConfig {
    get {
      if case .replaceConfig(let v)? = transformation {return v}
      return Google_Privacy_Dlp_V2_ReplaceValueConfig()
    }
    set {transformation = .replaceConfig(newValue)}
  }

  /// Redact
  public var redactConfig: Google_Privacy_Dlp_V2_RedactConfig {
    get {
      if case .redactConfig(let v)? = transformation {return v}
      return Google_Privacy_Dlp_V2_RedactConfig()
    }
    set {transformation = .redactConfig(newValue)}
  }

  /// Mask
  public var characterMaskConfig: Google_Privacy_Dlp_V2_CharacterMaskConfig {
    get {
      if case .characterMaskConfig(let v)? = transformation {return v}
      return Google_Privacy_Dlp_V2_CharacterMaskConfig()
    }
    set {transformation = .characterMaskConfig(newValue)}
  }

  /// Ffx-Fpe
  public var cryptoReplaceFfxFpeConfig: Google_Privacy_Dlp_V2_CryptoReplaceFfxFpeConfig {
    get {
      if case .cryptoReplaceFfxFpeConfig(let v)? = transformation {return v}
      return Google_Privacy_Dlp_V2_CryptoReplaceFfxFpeConfig()
    }
    set {transformation = .cryptoReplaceFfxFpeConfig(newValue)}
  }

  /// Fixed size bucketing
  public var fixedSizeBucketingConfig: Google_Privacy_Dlp_V2_FixedSizeBucketingConfig {
    get {
      if case .fixedSizeBucketingConfig(let v)? = transformation {return v}
      return Google_Privacy_Dlp_V2_FixedSizeBucketingConfig()
    }
    set {transformation = .fixedSizeBucketingConfig(newValue)}
  }

  /// Bucketing
  public var bucketingConfig: Google_Privacy_Dlp_V2_BucketingConfig {
    get {
      if case .bucketingConfig(let v)? = transformation {return v}
      return Google_Privacy_Dlp_V2_BucketingConfig()
    }
    set {transformation = .bucketingConfig(newValue)}
  }

  /// Replace with infotype
  public var replaceWithInfoTypeConfig: Google_Privacy_Dlp_V2_ReplaceWithInfoTypeConfig {
    get {
      if case .replaceWithInfoTypeConfig(let v)? = transformation {return v}
      return Google_Privacy_Dlp_V2_ReplaceWithInfoTypeConfig()
    }
    set {transformation = .replaceWithInfoTypeConfig(newValue)}
  }

  /// Time extraction
  public var timePartConfig: Google_Privacy_Dlp_V2_TimePartConfig {
    get {
      if case .timePartConfig(let v)? = transformation {return v}
      return Google_Privacy_Dlp_V2_TimePartConfig()
    }
    set {transformation = .timePartConfig(newValue)}
  }

  /// Crypto
  public var cryptoHashConfig: Google_Privacy_Dlp_V2_CryptoHashConfig {
    get {
      if case .cryptoHashConfig(let v)? = transformation {return v}
      return Google_Privacy_Dlp_V2_CryptoHashConfig()
    }
    set {transformation = .cryptoHashConfig(newValue)}
  }

  /// Date Shift
  public var dateShiftConfig: Google_Privacy_Dlp_V2_DateShiftConfig {
    get {
      if case .dateShiftConfig(let v)? = transformation {return v}
      return Google_Privacy_Dlp_V2_DateShiftConfig()
    }
    set {transformation = .dateShiftConfig(newValue)}
  }

  /// Deterministic Crypto
  public var cryptoDeterministicConfig: Google_Privacy_Dlp_V2_CryptoDeterministicConfig {
    get {
      if case .cryptoDeterministicConfig(let v)? = transformation {return v}
      return Google_Privacy_Dlp_V2_CryptoDeterministicConfig()
    }
    set {transformation = .cryptoDeterministicConfig(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Transformation: Equatable {
    /// Replace
    case replaceConfig(Google_Privacy_Dlp_V2_ReplaceValueConfig)
    /// Redact
    case redactConfig(Google_Privacy_Dlp_V2_RedactConfig)
    /// Mask
    case characterMaskConfig(Google_Privacy_Dlp_V2_CharacterMaskConfig)
    /// Ffx-Fpe
    case cryptoReplaceFfxFpeConfig(Google_Privacy_Dlp_V2_CryptoReplaceFfxFpeConfig)
    /// Fixed size bucketing
    case fixedSizeBucketingConfig(Google_Privacy_Dlp_V2_FixedSizeBucketingConfig)
    /// Bucketing
    case bucketingConfig(Google_Privacy_Dlp_V2_BucketingConfig)
    /// Replace with infotype
    case replaceWithInfoTypeConfig(Google_Privacy_Dlp_V2_ReplaceWithInfoTypeConfig)
    /// Time extraction
    case timePartConfig(Google_Privacy_Dlp_V2_TimePartConfig)
    /// Crypto
    case cryptoHashConfig(Google_Privacy_Dlp_V2_CryptoHashConfig)
    /// Date Shift
    case dateShiftConfig(Google_Privacy_Dlp_V2_DateShiftConfig)
    /// Deterministic Crypto
    case cryptoDeterministicConfig(Google_Privacy_Dlp_V2_CryptoDeterministicConfig)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Privacy_Dlp_V2_PrimitiveTransformation.OneOf_Transformation, rhs: Google_Privacy_Dlp_V2_PrimitiveTransformation.OneOf_Transformation) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.replaceConfig, .replaceConfig): return {
        guard case .replaceConfig(let l) = lhs, case .replaceConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.redactConfig, .redactConfig): return {
        guard case .redactConfig(let l) = lhs, case .redactConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.characterMaskConfig, .characterMaskConfig): return {
        guard case .characterMaskConfig(let l) = lhs, case .characterMaskConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cryptoReplaceFfxFpeConfig, .cryptoReplaceFfxFpeConfig): return {
        guard case .cryptoReplaceFfxFpeConfig(let l) = lhs, case .cryptoReplaceFfxFpeConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fixedSizeBucketingConfig, .fixedSizeBucketingConfig): return {
        guard case .fixedSizeBucketingConfig(let l) = lhs, case .fixedSizeBucketingConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bucketingConfig, .bucketingConfig): return {
        guard case .bucketingConfig(let l) = lhs, case .bucketingConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.replaceWithInfoTypeConfig, .replaceWithInfoTypeConfig): return {
        guard case .replaceWithInfoTypeConfig(let l) = lhs, case .replaceWithInfoTypeConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.timePartConfig, .timePartConfig): return {
        guard case .timePartConfig(let l) = lhs, case .timePartConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cryptoHashConfig, .cryptoHashConfig): return {
        guard case .cryptoHashConfig(let l) = lhs, case .cryptoHashConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dateShiftConfig, .dateShiftConfig): return {
        guard case .dateShiftConfig(let l) = lhs, case .dateShiftConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cryptoDeterministicConfig, .cryptoDeterministicConfig): return {
        guard case .cryptoDeterministicConfig(let l) = lhs, case .cryptoDeterministicConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// For use with `Date`, `Timestamp`, and `TimeOfDay`, extract or preserve a
/// portion of the value.
public struct Google_Privacy_Dlp_V2_TimePartConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The part of the time to keep.
  public var partToExtract: Google_Privacy_Dlp_V2_TimePartConfig.TimePart = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Components that make up time.
  public enum TimePart: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unused
    case unspecified // = 0

    /// [0-9999]
    case year // = 1

    /// [1-12]
    case month // = 2

    /// [1-31]
    case dayOfMonth // = 3

    /// [1-7]
    case dayOfWeek // = 4

    /// [1-53]
    case weekOfYear // = 5

    /// [0-23]
    case hourOfDay // = 6
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .year
      case 2: self = .month
      case 3: self = .dayOfMonth
      case 4: self = .dayOfWeek
      case 5: self = .weekOfYear
      case 6: self = .hourOfDay
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .year: return 1
      case .month: return 2
      case .dayOfMonth: return 3
      case .dayOfWeek: return 4
      case .weekOfYear: return 5
      case .hourOfDay: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Privacy_Dlp_V2_TimePartConfig.TimePart: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Privacy_Dlp_V2_TimePartConfig.TimePart] = [
    .unspecified,
    .year,
    .month,
    .dayOfMonth,
    .dayOfWeek,
    .weekOfYear,
    .hourOfDay,
  ]
}

#endif  // swift(>=4.2)

/// Pseudonymization method that generates surrogates via cryptographic hashing.
/// Uses SHA-256.
/// The key size must be either 32 or 64 bytes.
/// Outputs a base64 encoded representation of the hashed output
/// (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=).
/// Currently, only string and integer values can be hashed.
/// See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
public struct Google_Privacy_Dlp_V2_CryptoHashConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The key used by the hash function.
  public var cryptoKey: Google_Privacy_Dlp_V2_CryptoKey {
    get {return _cryptoKey ?? Google_Privacy_Dlp_V2_CryptoKey()}
    set {_cryptoKey = newValue}
  }
  /// Returns true if `cryptoKey` has been explicitly set.
  public var hasCryptoKey: Bool {return self._cryptoKey != nil}
  /// Clears the value of `cryptoKey`. Subsequent reads from it will return its default value.
  public mutating func clearCryptoKey() {self._cryptoKey = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _cryptoKey: Google_Privacy_Dlp_V2_CryptoKey? = nil
}

/// Pseudonymization method that generates deterministic encryption for the given
/// input. Outputs a base64 encoded representation of the encrypted output.
/// Uses AES-SIV based on the RFC https://tools.ietf.org/html/rfc5297.
public struct Google_Privacy_Dlp_V2_CryptoDeterministicConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The key used by the encryption function.
  public var cryptoKey: Google_Privacy_Dlp_V2_CryptoKey {
    get {return _cryptoKey ?? Google_Privacy_Dlp_V2_CryptoKey()}
    set {_cryptoKey = newValue}
  }
  /// Returns true if `cryptoKey` has been explicitly set.
  public var hasCryptoKey: Bool {return self._cryptoKey != nil}
  /// Clears the value of `cryptoKey`. Subsequent reads from it will return its default value.
  public mutating func clearCryptoKey() {self._cryptoKey = nil}

  /// The custom info type to annotate the surrogate with.
  /// This annotation will be applied to the surrogate by prefixing it with
  /// the name of the custom info type followed by the number of
  /// characters comprising the surrogate. The following scheme defines the
  /// format: {info type name}({surrogate character count}):{surrogate}
  ///
  /// For example, if the name of custom info type is 'MY_TOKEN_INFO_TYPE' and
  /// the surrogate is 'abc', the full replacement value
  /// will be: 'MY_TOKEN_INFO_TYPE(3):abc'
  ///
  /// This annotation identifies the surrogate when inspecting content using the
  /// custom info type 'Surrogate'. This facilitates reversal of the
  /// surrogate when it occurs in free text.
  ///
  /// Note: For record transformations where the entire cell in a table is being
  /// transformed, surrogates are not mandatory. Surrogates are used to denote
  /// the location of the token and are necessary for re-identification in free
  /// form text.
  ///
  /// In order for inspection to work properly, the name of this info type must
  /// not occur naturally anywhere in your data; otherwise, inspection may either
  ///
  /// - reverse a surrogate that does not correspond to an actual identifier
  /// - be unable to parse the surrogate and result in an error
  ///
  /// Therefore, choose your custom info type name carefully after considering
  /// what your data looks like. One way to select a name that has a high chance
  /// of yielding reliable detection is to include one or more unicode characters
  /// that are highly improbable to exist in your data.
  /// For example, assuming your data is entered from a regular ASCII keyboard,
  /// the symbol with the hex code point 29DD might be used like so:
  /// ⧝MY_TOKEN_TYPE.
  public var surrogateInfoType: Google_Privacy_Dlp_V2_InfoType {
    get {return _surrogateInfoType ?? Google_Privacy_Dlp_V2_InfoType()}
    set {_surrogateInfoType = newValue}
  }
  /// Returns true if `surrogateInfoType` has been explicitly set.
  public var hasSurrogateInfoType: Bool {return self._surrogateInfoType != nil}
  /// Clears the value of `surrogateInfoType`. Subsequent reads from it will return its default value.
  public mutating func clearSurrogateInfoType() {self._surrogateInfoType = nil}

  /// A context may be used for higher security and maintaining
  /// referential integrity such that the same identifier in two different
  /// contexts will be given a distinct surrogate. The context is appended to
  /// plaintext value being encrypted. On decryption the provided context is
  /// validated against the value used during encryption. If a context was
  /// provided during encryption, same context must be provided during decryption
  /// as well.
  ///
  /// If the context is not set, plaintext would be used as is for encryption.
  /// If the context is set but:
  ///
  /// 1. there is no record present when transforming a given value or
  /// 2. the field is not present when transforming a given value,
  ///
  /// plaintext would be used as is for encryption.
  ///
  /// Note that case (1) is expected when an `InfoTypeTransformation` is
  /// applied to both structured and non-structured `ContentItem`s.
  public var context: Google_Privacy_Dlp_V2_FieldId {
    get {return _context ?? Google_Privacy_Dlp_V2_FieldId()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {self._context = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _cryptoKey: Google_Privacy_Dlp_V2_CryptoKey? = nil
  fileprivate var _surrogateInfoType: Google_Privacy_Dlp_V2_InfoType? = nil
  fileprivate var _context: Google_Privacy_Dlp_V2_FieldId? = nil
}

/// Replace each input value with a given `Value`.
public struct Google_Privacy_Dlp_V2_ReplaceValueConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Value to replace it with.
  public var newValue: Google_Privacy_Dlp_V2_Value {
    get {return _newValue ?? Google_Privacy_Dlp_V2_Value()}
    set {_newValue = newValue}
  }
  /// Returns true if `newValue` has been explicitly set.
  public var hasNewValue: Bool {return self._newValue != nil}
  /// Clears the value of `newValue`. Subsequent reads from it will return its default value.
  public mutating func clearNewValue() {self._newValue = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _newValue: Google_Privacy_Dlp_V2_Value? = nil
}

/// Replace each matching finding with the name of the info_type.
public struct Google_Privacy_Dlp_V2_ReplaceWithInfoTypeConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Redact a given value. For example, if used with an `InfoTypeTransformation`
/// transforming PHONE_NUMBER, and input 'My phone number is 206-555-0123', the
/// output would be 'My phone number is '.
public struct Google_Privacy_Dlp_V2_RedactConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Characters to skip when doing deidentification of a value. These will be left
/// alone and skipped.
public struct Google_Privacy_Dlp_V2_CharsToIgnore {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var characters: Google_Privacy_Dlp_V2_CharsToIgnore.OneOf_Characters? = nil

  /// Characters to not transform when masking.
  public var charactersToSkip: String {
    get {
      if case .charactersToSkip(let v)? = characters {return v}
      return String()
    }
    set {characters = .charactersToSkip(newValue)}
  }

  /// Common characters to not transform when masking. Useful to avoid removing
  /// punctuation.
  public var commonCharactersToIgnore: Google_Privacy_Dlp_V2_CharsToIgnore.CommonCharsToIgnore {
    get {
      if case .commonCharactersToIgnore(let v)? = characters {return v}
      return .unspecified
    }
    set {characters = .commonCharactersToIgnore(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Characters: Equatable {
    /// Characters to not transform when masking.
    case charactersToSkip(String)
    /// Common characters to not transform when masking. Useful to avoid removing
    /// punctuation.
    case commonCharactersToIgnore(Google_Privacy_Dlp_V2_CharsToIgnore.CommonCharsToIgnore)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Privacy_Dlp_V2_CharsToIgnore.OneOf_Characters, rhs: Google_Privacy_Dlp_V2_CharsToIgnore.OneOf_Characters) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.charactersToSkip, .charactersToSkip): return {
        guard case .charactersToSkip(let l) = lhs, case .charactersToSkip(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.commonCharactersToIgnore, .commonCharactersToIgnore): return {
        guard case .commonCharactersToIgnore(let l) = lhs, case .commonCharactersToIgnore(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Convenience enum for indication common characters to not transform.
  public enum CommonCharsToIgnore: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unused.
    case unspecified // = 0

    /// 0-9
    case numeric // = 1

    /// A-Z
    case alphaUpperCase // = 2

    /// a-z
    case alphaLowerCase // = 3

    /// US Punctuation, one of !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
    case punctuation // = 4

    /// Whitespace character, one of [ \t\n\x0B\f\r]
    case whitespace // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .numeric
      case 2: self = .alphaUpperCase
      case 3: self = .alphaLowerCase
      case 4: self = .punctuation
      case 5: self = .whitespace
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .numeric: return 1
      case .alphaUpperCase: return 2
      case .alphaLowerCase: return 3
      case .punctuation: return 4
      case .whitespace: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Privacy_Dlp_V2_CharsToIgnore.CommonCharsToIgnore: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Privacy_Dlp_V2_CharsToIgnore.CommonCharsToIgnore] = [
    .unspecified,
    .numeric,
    .alphaUpperCase,
    .alphaLowerCase,
    .punctuation,
    .whitespace,
  ]
}

#endif  // swift(>=4.2)

/// Partially mask a string by replacing a given number of characters with a
/// fixed character. Masking can start from the beginning or end of the string.
/// This can be used on data of any type (numbers, longs, and so on) and when
/// de-identifying structured data we'll attempt to preserve the original data's
/// type. (This allows you to take a long like 123 and modify it to a string like
/// **3.
public struct Google_Privacy_Dlp_V2_CharacterMaskConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Character to use to mask the sensitive values&mdash;for example, `*` for an
  /// alphabetic string such as a name, or `0` for a numeric string such as ZIP
  /// code or credit card number. This string must have a length of 1. If not
  /// supplied, this value defaults to `*` for strings, and `0` for digits.
  public var maskingCharacter: String = String()

  /// Number of characters to mask. If not set, all matching chars will be
  /// masked. Skipped characters do not count towards this tally.
  public var numberToMask: Int32 = 0

  /// Mask characters in reverse order. For example, if `masking_character` is
  /// `0`, `number_to_mask` is `14`, and `reverse_order` is `false`, then the
  /// input string `1234-5678-9012-3456` is masked as `00000000000000-3456`.
  /// If `masking_character` is `*`, `number_to_mask` is `3`, and `reverse_order`
  /// is `true`, then the string `12345` is masked as `12***`.
  public var reverseOrder: Bool = false

  /// When masking a string, items in this list will be skipped when replacing
  /// characters. For example, if the input string is `555-555-5555` and you
  /// instruct Cloud DLP to skip `-` and mask 5 characters with `*`, Cloud DLP
  /// returns `***-**5-5555`.
  public var charactersToIgnore: [Google_Privacy_Dlp_V2_CharsToIgnore] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Buckets values based on fixed size ranges. The
/// Bucketing transformation can provide all of this functionality,
/// but requires more configuration. This message is provided as a convenience to
/// the user for simple bucketing strategies.
///
/// The transformed value will be a hyphenated string of
/// {lower_bound}-{upper_bound}, i.e if lower_bound = 10 and upper_bound = 20
/// all values that are within this bucket will be replaced with "10-20".
///
/// This can be used on data of type: double, long.
///
/// If the bound Value type differs from the type of data
/// being transformed, we will first attempt converting the type of the data to
/// be transformed to match the type of the bound before comparing.
///
/// See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
public struct Google_Privacy_Dlp_V2_FixedSizeBucketingConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Lower bound value of buckets. All values less than `lower_bound` are
  /// grouped together into a single bucket; for example if `lower_bound` = 10,
  /// then all values less than 10 are replaced with the value "-10".
  public var lowerBound: Google_Privacy_Dlp_V2_Value {
    get {return _lowerBound ?? Google_Privacy_Dlp_V2_Value()}
    set {_lowerBound = newValue}
  }
  /// Returns true if `lowerBound` has been explicitly set.
  public var hasLowerBound: Bool {return self._lowerBound != nil}
  /// Clears the value of `lowerBound`. Subsequent reads from it will return its default value.
  public mutating func clearLowerBound() {self._lowerBound = nil}

  /// Required. Upper bound value of buckets. All values greater than upper_bound are
  /// grouped together into a single bucket; for example if `upper_bound` = 89,
  /// then all values greater than 89 are replaced with the value "89+".
  public var upperBound: Google_Privacy_Dlp_V2_Value {
    get {return _upperBound ?? Google_Privacy_Dlp_V2_Value()}
    set {_upperBound = newValue}
  }
  /// Returns true if `upperBound` has been explicitly set.
  public var hasUpperBound: Bool {return self._upperBound != nil}
  /// Clears the value of `upperBound`. Subsequent reads from it will return its default value.
  public mutating func clearUpperBound() {self._upperBound = nil}

  /// Required. Size of each bucket (except for minimum and maximum buckets). So if
  /// `lower_bound` = 10, `upper_bound` = 89, and `bucket_size` = 10, then the
  /// following buckets would be used: -10, 10-20, 20-30, 30-40, 40-50, 50-60,
  /// 60-70, 70-80, 80-89, 89+. Precision up to 2 decimals works.
  public var bucketSize: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _lowerBound: Google_Privacy_Dlp_V2_Value? = nil
  fileprivate var _upperBound: Google_Privacy_Dlp_V2_Value? = nil
}

/// Generalization function that buckets values based on ranges. The ranges and
/// replacement values are dynamically provided by the user for custom behavior,
/// such as 1-30 -> LOW 31-65 -> MEDIUM 66-100 -> HIGH
/// This can be used on
/// data of type: number, long, string, timestamp.
/// If the bound `Value` type differs from the type of data being transformed, we
/// will first attempt converting the type of the data to be transformed to match
/// the type of the bound before comparing.
/// See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
public struct Google_Privacy_Dlp_V2_BucketingConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Set of buckets. Ranges must be non-overlapping.
  public var buckets: [Google_Privacy_Dlp_V2_BucketingConfig.Bucket] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Bucket is represented as a range, along with replacement values.
  public struct Bucket {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Lower bound of the range, inclusive. Type should be the same as max if
    /// used.
    public var min: Google_Privacy_Dlp_V2_Value {
      get {return _min ?? Google_Privacy_Dlp_V2_Value()}
      set {_min = newValue}
    }
    /// Returns true if `min` has been explicitly set.
    public var hasMin: Bool {return self._min != nil}
    /// Clears the value of `min`. Subsequent reads from it will return its default value.
    public mutating func clearMin() {self._min = nil}

    /// Upper bound of the range, exclusive; type must match min.
    public var max: Google_Privacy_Dlp_V2_Value {
      get {return _max ?? Google_Privacy_Dlp_V2_Value()}
      set {_max = newValue}
    }
    /// Returns true if `max` has been explicitly set.
    public var hasMax: Bool {return self._max != nil}
    /// Clears the value of `max`. Subsequent reads from it will return its default value.
    public mutating func clearMax() {self._max = nil}

    /// Required. Replacement value for this bucket.
    public var replacementValue: Google_Privacy_Dlp_V2_Value {
      get {return _replacementValue ?? Google_Privacy_Dlp_V2_Value()}
      set {_replacementValue = newValue}
    }
    /// Returns true if `replacementValue` has been explicitly set.
    public var hasReplacementValue: Bool {return self._replacementValue != nil}
    /// Clears the value of `replacementValue`. Subsequent reads from it will return its default value.
    public mutating func clearReplacementValue() {self._replacementValue = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _min: Google_Privacy_Dlp_V2_Value? = nil
    fileprivate var _max: Google_Privacy_Dlp_V2_Value? = nil
    fileprivate var _replacementValue: Google_Privacy_Dlp_V2_Value? = nil
  }

  public init() {}
}

/// Replaces an identifier with a surrogate using Format Preserving Encryption
/// (FPE) with the FFX mode of operation; however when used in the
/// `ReidentifyContent` API method, it serves the opposite function by reversing
/// the surrogate back into the original identifier. The identifier must be
/// encoded as ASCII. For a given crypto key and context, the same identifier
/// will be replaced with the same surrogate. Identifiers must be at least two
/// characters long. In the case that the identifier is the empty string, it will
/// be skipped. See https://cloud.google.com/dlp/docs/pseudonymization to learn
/// more.
///
/// Note: We recommend using  CryptoDeterministicConfig for all use cases which
/// do not require preserving the input alphabet space and size, plus warrant
/// referential integrity.
public struct Google_Privacy_Dlp_V2_CryptoReplaceFfxFpeConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The key used by the encryption algorithm.
  public var cryptoKey: Google_Privacy_Dlp_V2_CryptoKey {
    get {return _cryptoKey ?? Google_Privacy_Dlp_V2_CryptoKey()}
    set {_cryptoKey = newValue}
  }
  /// Returns true if `cryptoKey` has been explicitly set.
  public var hasCryptoKey: Bool {return self._cryptoKey != nil}
  /// Clears the value of `cryptoKey`. Subsequent reads from it will return its default value.
  public mutating func clearCryptoKey() {self._cryptoKey = nil}

  /// The 'tweak', a context may be used for higher security since the same
  /// identifier in two different contexts won't be given the same surrogate. If
  /// the context is not set, a default tweak will be used.
  ///
  /// If the context is set but:
  ///
  /// 1. there is no record present when transforming a given value or
  /// 1. the field is not present when transforming a given value,
  ///
  /// a default tweak will be used.
  ///
  /// Note that case (1) is expected when an `InfoTypeTransformation` is
  /// applied to both structured and non-structured `ContentItem`s.
  /// Currently, the referenced field may be of value type integer or string.
  ///
  /// The tweak is constructed as a sequence of bytes in big endian byte order
  /// such that:
  ///
  /// - a 64 bit integer is encoded followed by a single byte of value 1
  /// - a string is encoded in UTF-8 format followed by a single byte of value 2
  public var context: Google_Privacy_Dlp_V2_FieldId {
    get {return _context ?? Google_Privacy_Dlp_V2_FieldId()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {self._context = nil}

  /// Choose an alphabet which the data being transformed will be made up of.
  public var alphabet: Google_Privacy_Dlp_V2_CryptoReplaceFfxFpeConfig.OneOf_Alphabet? = nil

  /// Common alphabets.
  public var commonAlphabet: Google_Privacy_Dlp_V2_CryptoReplaceFfxFpeConfig.FfxCommonNativeAlphabet {
    get {
      if case .commonAlphabet(let v)? = alphabet {return v}
      return .unspecified
    }
    set {alphabet = .commonAlphabet(newValue)}
  }

  /// This is supported by mapping these to the alphanumeric characters
  /// that the FFX mode natively supports. This happens before/after
  /// encryption/decryption.
  /// Each character listed must appear only once.
  /// Number of characters must be in the range [2, 95].
  /// This must be encoded as ASCII.
  /// The order of characters does not matter.
  /// The full list of allowed characters is:
  /// <code>0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
  /// ~`!@#$%^&*()_-+={[}]|\:;"'<,>.?/</code>
  public var customAlphabet: String {
    get {
      if case .customAlphabet(let v)? = alphabet {return v}
      return String()
    }
    set {alphabet = .customAlphabet(newValue)}
  }

  /// The native way to select the alphabet. Must be in the range [2, 95].
  public var radix: Int32 {
    get {
      if case .radix(let v)? = alphabet {return v}
      return 0
    }
    set {alphabet = .radix(newValue)}
  }

  /// The custom infoType to annotate the surrogate with.
  /// This annotation will be applied to the surrogate by prefixing it with
  /// the name of the custom infoType followed by the number of
  /// characters comprising the surrogate. The following scheme defines the
  /// format: info_type_name(surrogate_character_count):surrogate
  ///
  /// For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and
  /// the surrogate is 'abc', the full replacement value
  /// will be: 'MY_TOKEN_INFO_TYPE(3):abc'
  ///
  /// This annotation identifies the surrogate when inspecting content using the
  /// custom infoType
  /// [`SurrogateType`](https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#surrogatetype).
  /// This facilitates reversal of the surrogate when it occurs in free text.
  ///
  /// In order for inspection to work properly, the name of this infoType must
  /// not occur naturally anywhere in your data; otherwise, inspection may
  /// find a surrogate that does not correspond to an actual identifier.
  /// Therefore, choose your custom infoType name carefully after considering
  /// what your data looks like. One way to select a name that has a high chance
  /// of yielding reliable detection is to include one or more unicode characters
  /// that are highly improbable to exist in your data.
  /// For example, assuming your data is entered from a regular ASCII keyboard,
  /// the symbol with the hex code point 29DD might be used like so:
  /// ⧝MY_TOKEN_TYPE
  public var surrogateInfoType: Google_Privacy_Dlp_V2_InfoType {
    get {return _surrogateInfoType ?? Google_Privacy_Dlp_V2_InfoType()}
    set {_surrogateInfoType = newValue}
  }
  /// Returns true if `surrogateInfoType` has been explicitly set.
  public var hasSurrogateInfoType: Bool {return self._surrogateInfoType != nil}
  /// Clears the value of `surrogateInfoType`. Subsequent reads from it will return its default value.
  public mutating func clearSurrogateInfoType() {self._surrogateInfoType = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Choose an alphabet which the data being transformed will be made up of.
  public enum OneOf_Alphabet: Equatable {
    /// Common alphabets.
    case commonAlphabet(Google_Privacy_Dlp_V2_CryptoReplaceFfxFpeConfig.FfxCommonNativeAlphabet)
    /// This is supported by mapping these to the alphanumeric characters
    /// that the FFX mode natively supports. This happens before/after
    /// encryption/decryption.
    /// Each character listed must appear only once.
    /// Number of characters must be in the range [2, 95].
    /// This must be encoded as ASCII.
    /// The order of characters does not matter.
    /// The full list of allowed characters is:
    /// <code>0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
    /// ~`!@#$%^&*()_-+={[}]|\:;"'<,>.?/</code>
    case customAlphabet(String)
    /// The native way to select the alphabet. Must be in the range [2, 95].
    case radix(Int32)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Privacy_Dlp_V2_CryptoReplaceFfxFpeConfig.OneOf_Alphabet, rhs: Google_Privacy_Dlp_V2_CryptoReplaceFfxFpeConfig.OneOf_Alphabet) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.commonAlphabet, .commonAlphabet): return {
        guard case .commonAlphabet(let l) = lhs, case .commonAlphabet(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.customAlphabet, .customAlphabet): return {
        guard case .customAlphabet(let l) = lhs, case .customAlphabet(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.radix, .radix): return {
        guard case .radix(let l) = lhs, case .radix(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// These are commonly used subsets of the alphabet that the FFX mode
  /// natively supports. In the algorithm, the alphabet is selected using
  /// the "radix". Therefore each corresponds to particular radix.
  public enum FfxCommonNativeAlphabet: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unused.
    case unspecified // = 0

    /// `[0-9]` (radix of 10)
    case numeric // = 1

    /// `[0-9A-F]` (radix of 16)
    case hexadecimal // = 2

    /// `[0-9A-Z]` (radix of 36)
    case upperCaseAlphaNumeric // = 3

    /// `[0-9A-Za-z]` (radix of 62)
    case alphaNumeric // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .numeric
      case 2: self = .hexadecimal
      case 3: self = .upperCaseAlphaNumeric
      case 4: self = .alphaNumeric
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .numeric: return 1
      case .hexadecimal: return 2
      case .upperCaseAlphaNumeric: return 3
      case .alphaNumeric: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _cryptoKey: Google_Privacy_Dlp_V2_CryptoKey? = nil
  fileprivate var _context: Google_Privacy_Dlp_V2_FieldId? = nil
  fileprivate var _surrogateInfoType: Google_Privacy_Dlp_V2_InfoType? = nil
}

#if swift(>=4.2)

extension Google_Privacy_Dlp_V2_CryptoReplaceFfxFpeConfig.FfxCommonNativeAlphabet: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Privacy_Dlp_V2_CryptoReplaceFfxFpeConfig.FfxCommonNativeAlphabet] = [
    .unspecified,
    .numeric,
    .hexadecimal,
    .upperCaseAlphaNumeric,
    .alphaNumeric,
  ]
}

#endif  // swift(>=4.2)

/// This is a data encryption key (DEK) (as opposed to
/// a key encryption key (KEK) stored by KMS).
/// When using KMS to wrap/unwrap DEKs, be sure to set an appropriate
/// IAM policy on the KMS CryptoKey (KEK) to ensure an attacker cannot
/// unwrap the data crypto key.
public struct Google_Privacy_Dlp_V2_CryptoKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sources of crypto keys.
  public var source: Google_Privacy_Dlp_V2_CryptoKey.OneOf_Source? = nil

  /// Transient crypto key
  public var transient: Google_Privacy_Dlp_V2_TransientCryptoKey {
    get {
      if case .transient(let v)? = source {return v}
      return Google_Privacy_Dlp_V2_TransientCryptoKey()
    }
    set {source = .transient(newValue)}
  }

  /// Unwrapped crypto key
  public var unwrapped: Google_Privacy_Dlp_V2_UnwrappedCryptoKey {
    get {
      if case .unwrapped(let v)? = source {return v}
      return Google_Privacy_Dlp_V2_UnwrappedCryptoKey()
    }
    set {source = .unwrapped(newValue)}
  }

  /// Kms wrapped key
  public var kmsWrapped: Google_Privacy_Dlp_V2_KmsWrappedCryptoKey {
    get {
      if case .kmsWrapped(let v)? = source {return v}
      return Google_Privacy_Dlp_V2_KmsWrappedCryptoKey()
    }
    set {source = .kmsWrapped(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Sources of crypto keys.
  public enum OneOf_Source: Equatable {
    /// Transient crypto key
    case transient(Google_Privacy_Dlp_V2_TransientCryptoKey)
    /// Unwrapped crypto key
    case unwrapped(Google_Privacy_Dlp_V2_UnwrappedCryptoKey)
    /// Kms wrapped key
    case kmsWrapped(Google_Privacy_Dlp_V2_KmsWrappedCryptoKey)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Privacy_Dlp_V2_CryptoKey.OneOf_Source, rhs: Google_Privacy_Dlp_V2_CryptoKey.OneOf_Source) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.transient, .transient): return {
        guard case .transient(let l) = lhs, case .transient(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unwrapped, .unwrapped): return {
        guard case .unwrapped(let l) = lhs, case .unwrapped(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.kmsWrapped, .kmsWrapped): return {
        guard case .kmsWrapped(let l) = lhs, case .kmsWrapped(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Use this to have a random data crypto key generated.
/// It will be discarded after the request finishes.
public struct Google_Privacy_Dlp_V2_TransientCryptoKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Name of the key.
  /// This is an arbitrary string used to differentiate different keys.
  /// A unique key is generated per name: two separate `TransientCryptoKey`
  /// protos share the same generated key if their names are the same.
  /// When the data crypto key is generated, this name is not used in any way
  /// (repeating the api call will result in a different key being generated).
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Using raw keys is prone to security risks due to accidentally
/// leaking the key. Choose another type of key if possible.
public struct Google_Privacy_Dlp_V2_UnwrappedCryptoKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. A 128/192/256 bit key.
  public var key: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Include to use an existing data crypto key wrapped by KMS.
/// The wrapped key must be a 128/192/256 bit key.
/// Authorization requires the following IAM permissions when sending a request
/// to perform a crypto transformation using a kms-wrapped crypto key:
/// dlp.kms.encrypt
public struct Google_Privacy_Dlp_V2_KmsWrappedCryptoKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The wrapped data crypto key.
  public var wrappedKey: Data = Data()

  /// Required. The resource name of the KMS CryptoKey to use for unwrapping.
  public var cryptoKeyName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Shifts dates by random number of days, with option to be consistent for the
/// same context. See https://cloud.google.com/dlp/docs/concepts-date-shifting
/// to learn more.
public struct Google_Privacy_Dlp_V2_DateShiftConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Range of shift in days. Actual shift will be selected at random within this
  /// range (inclusive ends). Negative means shift to earlier in time. Must not
  /// be more than 365250 days (1000 years) each direction.
  ///
  /// For example, 3 means shift date to at most 3 days into the future.
  public var upperBoundDays: Int32 = 0

  /// Required. For example, -5 means shift date to at most 5 days back in the past.
  public var lowerBoundDays: Int32 = 0

  /// Points to the field that contains the context, for example, an entity id.
  /// If set, must also set cryptoKey. If set, shift will be consistent for the
  /// given context.
  public var context: Google_Privacy_Dlp_V2_FieldId {
    get {return _context ?? Google_Privacy_Dlp_V2_FieldId()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {self._context = nil}

  /// Method for calculating shift that takes context into consideration. If
  /// set, must also set context. Can only be applied to table items.
  public var method: Google_Privacy_Dlp_V2_DateShiftConfig.OneOf_Method? = nil

  /// Causes the shift to be computed based on this key and the context. This
  /// results in the same shift for the same context and crypto_key. If
  /// set, must also set context. Can only be applied to table items.
  public var cryptoKey: Google_Privacy_Dlp_V2_CryptoKey {
    get {
      if case .cryptoKey(let v)? = method {return v}
      return Google_Privacy_Dlp_V2_CryptoKey()
    }
    set {method = .cryptoKey(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Method for calculating shift that takes context into consideration. If
  /// set, must also set context. Can only be applied to table items.
  public enum OneOf_Method: Equatable {
    /// Causes the shift to be computed based on this key and the context. This
    /// results in the same shift for the same context and crypto_key. If
    /// set, must also set context. Can only be applied to table items.
    case cryptoKey(Google_Privacy_Dlp_V2_CryptoKey)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Privacy_Dlp_V2_DateShiftConfig.OneOf_Method, rhs: Google_Privacy_Dlp_V2_DateShiftConfig.OneOf_Method) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.cryptoKey, .cryptoKey): return {
        guard case .cryptoKey(let l) = lhs, case .cryptoKey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _context: Google_Privacy_Dlp_V2_FieldId? = nil
}

/// A type of transformation that will scan unstructured text and
/// apply various `PrimitiveTransformation`s to each finding, where the
/// transformation is applied to only values that were identified as a specific
/// info_type.
public struct Google_Privacy_Dlp_V2_InfoTypeTransformations {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Transformation for each infoType. Cannot specify more than one
  /// for a given infoType.
  public var transformations: [Google_Privacy_Dlp_V2_InfoTypeTransformations.InfoTypeTransformation] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A transformation to apply to text that is identified as a specific
  /// info_type.
  public struct InfoTypeTransformation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// InfoTypes to apply the transformation to. An empty list will cause
    /// this transformation to apply to all findings that correspond to
    /// infoTypes that were requested in `InspectConfig`.
    public var infoTypes: [Google_Privacy_Dlp_V2_InfoType] = []

    /// Required. Primitive transformation to apply to the infoType.
    public var primitiveTransformation: Google_Privacy_Dlp_V2_PrimitiveTransformation {
      get {return _primitiveTransformation ?? Google_Privacy_Dlp_V2_PrimitiveTransformation()}
      set {_primitiveTransformation = newValue}
    }
    /// Returns true if `primitiveTransformation` has been explicitly set.
    public var hasPrimitiveTransformation: Bool {return self._primitiveTransformation != nil}
    /// Clears the value of `primitiveTransformation`. Subsequent reads from it will return its default value.
    public mutating func clearPrimitiveTransformation() {self._primitiveTransformation = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _primitiveTransformation: Google_Privacy_Dlp_V2_PrimitiveTransformation? = nil
  }

  public init() {}
}

/// The transformation to apply to the field.
public struct Google_Privacy_Dlp_V2_FieldTransformation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Input field(s) to apply the transformation to.
  public var fields: [Google_Privacy_Dlp_V2_FieldId] = []

  /// Only apply the transformation if the condition evaluates to true for the
  /// given `RecordCondition`. The conditions are allowed to reference fields
  /// that are not used in the actual transformation.
  ///
  /// Example Use Cases:
  ///
  /// - Apply a different bucket transformation to an age column if the zip code
  /// column for the same record is within a specific range.
  /// - Redact a field if the date of birth field is greater than 85.
  public var condition: Google_Privacy_Dlp_V2_RecordCondition {
    get {return _condition ?? Google_Privacy_Dlp_V2_RecordCondition()}
    set {_condition = newValue}
  }
  /// Returns true if `condition` has been explicitly set.
  public var hasCondition: Bool {return self._condition != nil}
  /// Clears the value of `condition`. Subsequent reads from it will return its default value.
  public mutating func clearCondition() {self._condition = nil}

  /// Transformation to apply. [required]
  public var transformation: Google_Privacy_Dlp_V2_FieldTransformation.OneOf_Transformation? = nil

  /// Apply the transformation to the entire field.
  public var primitiveTransformation: Google_Privacy_Dlp_V2_PrimitiveTransformation {
    get {
      if case .primitiveTransformation(let v)? = transformation {return v}
      return Google_Privacy_Dlp_V2_PrimitiveTransformation()
    }
    set {transformation = .primitiveTransformation(newValue)}
  }

  /// Treat the contents of the field as free text, and selectively
  /// transform content that matches an `InfoType`.
  public var infoTypeTransformations: Google_Privacy_Dlp_V2_InfoTypeTransformations {
    get {
      if case .infoTypeTransformations(let v)? = transformation {return v}
      return Google_Privacy_Dlp_V2_InfoTypeTransformations()
    }
    set {transformation = .infoTypeTransformations(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Transformation to apply. [required]
  public enum OneOf_Transformation: Equatable {
    /// Apply the transformation to the entire field.
    case primitiveTransformation(Google_Privacy_Dlp_V2_PrimitiveTransformation)
    /// Treat the contents of the field as free text, and selectively
    /// transform content that matches an `InfoType`.
    case infoTypeTransformations(Google_Privacy_Dlp_V2_InfoTypeTransformations)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Privacy_Dlp_V2_FieldTransformation.OneOf_Transformation, rhs: Google_Privacy_Dlp_V2_FieldTransformation.OneOf_Transformation) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.primitiveTransformation, .primitiveTransformation): return {
        guard case .primitiveTransformation(let l) = lhs, case .primitiveTransformation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.infoTypeTransformations, .infoTypeTransformations): return {
        guard case .infoTypeTransformations(let l) = lhs, case .infoTypeTransformations(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _condition: Google_Privacy_Dlp_V2_RecordCondition? = nil
}

/// A type of transformation that is applied over structured data such as a
/// table.
public struct Google_Privacy_Dlp_V2_RecordTransformations {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Transform the record by applying various field transformations.
  public var fieldTransformations: [Google_Privacy_Dlp_V2_FieldTransformation] = []

  /// Configuration defining which records get suppressed entirely. Records that
  /// match any suppression rule are omitted from the output.
  public var recordSuppressions: [Google_Privacy_Dlp_V2_RecordSuppression] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Configuration to suppress records whose suppression conditions evaluate to
/// true.
public struct Google_Privacy_Dlp_V2_RecordSuppression {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A condition that when it evaluates to true will result in the record being
  /// evaluated to be suppressed from the transformed content.
  public var condition: Google_Privacy_Dlp_V2_RecordCondition {
    get {return _condition ?? Google_Privacy_Dlp_V2_RecordCondition()}
    set {_condition = newValue}
  }
  /// Returns true if `condition` has been explicitly set.
  public var hasCondition: Bool {return self._condition != nil}
  /// Clears the value of `condition`. Subsequent reads from it will return its default value.
  public mutating func clearCondition() {self._condition = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _condition: Google_Privacy_Dlp_V2_RecordCondition? = nil
}

/// A condition for determining whether a transformation should be applied to
/// a field.
public struct Google_Privacy_Dlp_V2_RecordCondition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An expression.
  public var expressions: Google_Privacy_Dlp_V2_RecordCondition.Expressions {
    get {return _expressions ?? Google_Privacy_Dlp_V2_RecordCondition.Expressions()}
    set {_expressions = newValue}
  }
  /// Returns true if `expressions` has been explicitly set.
  public var hasExpressions: Bool {return self._expressions != nil}
  /// Clears the value of `expressions`. Subsequent reads from it will return its default value.
  public mutating func clearExpressions() {self._expressions = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The field type of `value` and `field` do not need to match to be
  /// considered equal, but not all comparisons are possible.
  /// EQUAL_TO and NOT_EQUAL_TO attempt to compare even with incompatible types,
  /// but all other comparisons are invalid with incompatible types.
  /// A `value` of type:
  ///
  /// - `string` can be compared against all other types
  /// - `boolean` can only be compared against other booleans
  /// - `integer` can be compared against doubles or a string if the string value
  /// can be parsed as an integer.
  /// - `double` can be compared against integers or a string if the string can
  /// be parsed as a double.
  /// - `Timestamp` can be compared against strings in RFC 3339 date string
  /// format.
  /// - `TimeOfDay` can be compared against timestamps and strings in the format
  /// of 'HH:mm:ss'.
  ///
  /// If we fail to compare do to type mismatch, a warning will be given and
  /// the condition will evaluate to false.
  public struct Condition {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. Field within the record this condition is evaluated against.
    public var field: Google_Privacy_Dlp_V2_FieldId {
      get {return _field ?? Google_Privacy_Dlp_V2_FieldId()}
      set {_field = newValue}
    }
    /// Returns true if `field` has been explicitly set.
    public var hasField: Bool {return self._field != nil}
    /// Clears the value of `field`. Subsequent reads from it will return its default value.
    public mutating func clearField() {self._field = nil}

    /// Required. Operator used to compare the field or infoType to the value.
    public var `operator`: Google_Privacy_Dlp_V2_RelationalOperator = .unspecified

    /// Value to compare against. [Mandatory, except for `EXISTS` tests.]
    public var value: Google_Privacy_Dlp_V2_Value {
      get {return _value ?? Google_Privacy_Dlp_V2_Value()}
      set {_value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    public var hasValue: Bool {return self._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    public mutating func clearValue() {self._value = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _field: Google_Privacy_Dlp_V2_FieldId? = nil
    fileprivate var _value: Google_Privacy_Dlp_V2_Value? = nil
  }

  /// A collection of conditions.
  public struct Conditions {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A collection of conditions.
    public var conditions: [Google_Privacy_Dlp_V2_RecordCondition.Condition] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// An expression, consisting or an operator and conditions.
  public struct Expressions {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The operator to apply to the result of conditions. Default and currently
    /// only supported value is `AND`.
    public var logicalOperator: Google_Privacy_Dlp_V2_RecordCondition.Expressions.LogicalOperator = .unspecified

    /// Expression types.
    public var type: Google_Privacy_Dlp_V2_RecordCondition.Expressions.OneOf_Type? = nil

    /// Conditions to apply to the expression.
    public var conditions: Google_Privacy_Dlp_V2_RecordCondition.Conditions {
      get {
        if case .conditions(let v)? = type {return v}
        return Google_Privacy_Dlp_V2_RecordCondition.Conditions()
      }
      set {type = .conditions(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Expression types.
    public enum OneOf_Type: Equatable {
      /// Conditions to apply to the expression.
      case conditions(Google_Privacy_Dlp_V2_RecordCondition.Conditions)

    #if !swift(>=4.1)
      public static func ==(lhs: Google_Privacy_Dlp_V2_RecordCondition.Expressions.OneOf_Type, rhs: Google_Privacy_Dlp_V2_RecordCondition.Expressions.OneOf_Type) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.conditions, .conditions): return {
          guard case .conditions(let l) = lhs, case .conditions(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        }
      }
    #endif
    }

    /// Logical operators for conditional checks.
    public enum LogicalOperator: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// Unused
      case unspecified // = 0

      /// Conditional AND
      case and // = 1
      case UNRECOGNIZED(Int)

      public init() {
        self = .unspecified
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .and
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .and: return 1
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public init() {}

  fileprivate var _expressions: Google_Privacy_Dlp_V2_RecordCondition.Expressions? = nil
}

#if swift(>=4.2)

extension Google_Privacy_Dlp_V2_RecordCondition.Expressions.LogicalOperator: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Privacy_Dlp_V2_RecordCondition.Expressions.LogicalOperator] = [
    .unspecified,
    .and,
  ]
}

#endif  // swift(>=4.2)

/// Overview of the modifications that occurred.
public struct Google_Privacy_Dlp_V2_TransformationOverview {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Total size in bytes that were transformed in some way.
  public var transformedBytes: Int64 = 0

  /// Transformations applied to the dataset.
  public var transformationSummaries: [Google_Privacy_Dlp_V2_TransformationSummary] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Summary of a single transformation.
/// Only one of 'transformation', 'field_transformation', or 'record_suppress'
/// will be set.
public struct Google_Privacy_Dlp_V2_TransformationSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Set if the transformation was limited to a specific InfoType.
  public var infoType: Google_Privacy_Dlp_V2_InfoType {
    get {return _infoType ?? Google_Privacy_Dlp_V2_InfoType()}
    set {_infoType = newValue}
  }
  /// Returns true if `infoType` has been explicitly set.
  public var hasInfoType: Bool {return self._infoType != nil}
  /// Clears the value of `infoType`. Subsequent reads from it will return its default value.
  public mutating func clearInfoType() {self._infoType = nil}

  /// Set if the transformation was limited to a specific FieldId.
  public var field: Google_Privacy_Dlp_V2_FieldId {
    get {return _field ?? Google_Privacy_Dlp_V2_FieldId()}
    set {_field = newValue}
  }
  /// Returns true if `field` has been explicitly set.
  public var hasField: Bool {return self._field != nil}
  /// Clears the value of `field`. Subsequent reads from it will return its default value.
  public mutating func clearField() {self._field = nil}

  /// The specific transformation these stats apply to.
  public var transformation: Google_Privacy_Dlp_V2_PrimitiveTransformation {
    get {return _transformation ?? Google_Privacy_Dlp_V2_PrimitiveTransformation()}
    set {_transformation = newValue}
  }
  /// Returns true if `transformation` has been explicitly set.
  public var hasTransformation: Bool {return self._transformation != nil}
  /// Clears the value of `transformation`. Subsequent reads from it will return its default value.
  public mutating func clearTransformation() {self._transformation = nil}

  /// The field transformation that was applied.
  /// If multiple field transformations are requested for a single field,
  /// this list will contain all of them; otherwise, only one is supplied.
  public var fieldTransformations: [Google_Privacy_Dlp_V2_FieldTransformation] = []

  /// The specific suppression option these stats apply to.
  public var recordSuppress: Google_Privacy_Dlp_V2_RecordSuppression {
    get {return _recordSuppress ?? Google_Privacy_Dlp_V2_RecordSuppression()}
    set {_recordSuppress = newValue}
  }
  /// Returns true if `recordSuppress` has been explicitly set.
  public var hasRecordSuppress: Bool {return self._recordSuppress != nil}
  /// Clears the value of `recordSuppress`. Subsequent reads from it will return its default value.
  public mutating func clearRecordSuppress() {self._recordSuppress = nil}

  /// Collection of all transformations that took place or had an error.
  public var results: [Google_Privacy_Dlp_V2_TransformationSummary.SummaryResult] = []

  /// Total size in bytes that were transformed in some way.
  public var transformedBytes: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Possible outcomes of transformations.
  public enum TransformationResultCode: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unused
    case unspecified // = 0

    /// Transformation completed without an error.
    case success // = 1

    /// Transformation had an error.
    case error // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .success
      case 2: self = .error
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .success: return 1
      case .error: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// A collection that informs the user the number of times a particular
  /// `TransformationResultCode` and error details occurred.
  public struct SummaryResult {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Number of transformations counted by this result.
    public var count: Int64 = 0

    /// Outcome of the transformation.
    public var code: Google_Privacy_Dlp_V2_TransformationSummary.TransformationResultCode = .unspecified

    /// A place for warnings or errors to show up if a transformation didn't
    /// work as expected.
    public var details: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _infoType: Google_Privacy_Dlp_V2_InfoType? = nil
  fileprivate var _field: Google_Privacy_Dlp_V2_FieldId? = nil
  fileprivate var _transformation: Google_Privacy_Dlp_V2_PrimitiveTransformation? = nil
  fileprivate var _recordSuppress: Google_Privacy_Dlp_V2_RecordSuppression? = nil
}

#if swift(>=4.2)

extension Google_Privacy_Dlp_V2_TransformationSummary.TransformationResultCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Privacy_Dlp_V2_TransformationSummary.TransformationResultCode] = [
    .unspecified,
    .success,
    .error,
  ]
}

#endif  // swift(>=4.2)

/// Schedule for triggeredJobs.
public struct Google_Privacy_Dlp_V2_Schedule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var option: Google_Privacy_Dlp_V2_Schedule.OneOf_Option? = nil

  /// With this option a job is started a regular periodic basis. For
  /// example: every day (86400 seconds).
  ///
  /// A scheduled start time will be skipped if the previous
  /// execution has not ended when its scheduled time occurs.
  ///
  /// This value must be set to a time duration greater than or equal
  /// to 1 day and can be no longer than 60 days.
  public var recurrencePeriodDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {
      if case .recurrencePeriodDuration(let v)? = option {return v}
      return SwiftProtobuf.Google_Protobuf_Duration()
    }
    set {option = .recurrencePeriodDuration(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Option: Equatable {
    /// With this option a job is started a regular periodic basis. For
    /// example: every day (86400 seconds).
    ///
    /// A scheduled start time will be skipped if the previous
    /// execution has not ended when its scheduled time occurs.
    ///
    /// This value must be set to a time duration greater than or equal
    /// to 1 day and can be no longer than 60 days.
    case recurrencePeriodDuration(SwiftProtobuf.Google_Protobuf_Duration)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Privacy_Dlp_V2_Schedule.OneOf_Option, rhs: Google_Privacy_Dlp_V2_Schedule.OneOf_Option) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.recurrencePeriodDuration, .recurrencePeriodDuration): return {
        guard case .recurrencePeriodDuration(let l) = lhs, case .recurrencePeriodDuration(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

/// Job trigger option for hybrid jobs. Jobs must be manually created
/// and finished.
public struct Google_Privacy_Dlp_V2_Manual {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The inspectTemplate contains a configuration (set of types of sensitive data
/// to be detected) to be used anywhere you otherwise would normally specify
/// InspectConfig. See https://cloud.google.com/dlp/docs/concepts-templates
/// to learn more.
public struct Google_Privacy_Dlp_V2_InspectTemplate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The template name.
  ///
  /// The template will have one of the following formats:
  /// `projects/PROJECT_ID/inspectTemplates/TEMPLATE_ID` OR
  /// `organizations/ORGANIZATION_ID/inspectTemplates/TEMPLATE_ID`;
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Display name (max 256 chars).
  public var displayName: String {
    get {return _storage._displayName}
    set {_uniqueStorage()._displayName = newValue}
  }

  /// Short description (max 256 chars).
  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// Output only. The creation timestamp of an inspectTemplate.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return _storage._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {_uniqueStorage()._createTime = nil}

  /// Output only. The last update timestamp of an inspectTemplate.
  public var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  public var hasUpdateTime: Bool {return _storage._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateTime() {_uniqueStorage()._updateTime = nil}

  /// The core content of the template. Configuration of the scanning process.
  public var inspectConfig: Google_Privacy_Dlp_V2_InspectConfig {
    get {return _storage._inspectConfig ?? Google_Privacy_Dlp_V2_InspectConfig()}
    set {_uniqueStorage()._inspectConfig = newValue}
  }
  /// Returns true if `inspectConfig` has been explicitly set.
  public var hasInspectConfig: Bool {return _storage._inspectConfig != nil}
  /// Clears the value of `inspectConfig`. Subsequent reads from it will return its default value.
  public mutating func clearInspectConfig() {_uniqueStorage()._inspectConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DeidentifyTemplates contains instructions on how to de-identify content.
/// See https://cloud.google.com/dlp/docs/concepts-templates to learn more.
public struct Google_Privacy_Dlp_V2_DeidentifyTemplate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The template name.
  ///
  /// The template will have one of the following formats:
  /// `projects/PROJECT_ID/deidentifyTemplates/TEMPLATE_ID` OR
  /// `organizations/ORGANIZATION_ID/deidentifyTemplates/TEMPLATE_ID`
  public var name: String = String()

  /// Display name (max 256 chars).
  public var displayName: String = String()

  /// Short description (max 256 chars).
  public var description_p: String = String()

  /// Output only. The creation timestamp of an inspectTemplate.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {self._createTime = nil}

  /// Output only. The last update timestamp of an inspectTemplate.
  public var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  public var hasUpdateTime: Bool {return self._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateTime() {self._updateTime = nil}

  /// ///////////// // The core content of the template  // ///////////////
  public var deidentifyConfig: Google_Privacy_Dlp_V2_DeidentifyConfig {
    get {return _deidentifyConfig ?? Google_Privacy_Dlp_V2_DeidentifyConfig()}
    set {_deidentifyConfig = newValue}
  }
  /// Returns true if `deidentifyConfig` has been explicitly set.
  public var hasDeidentifyConfig: Bool {return self._deidentifyConfig != nil}
  /// Clears the value of `deidentifyConfig`. Subsequent reads from it will return its default value.
  public mutating func clearDeidentifyConfig() {self._deidentifyConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _deidentifyConfig: Google_Privacy_Dlp_V2_DeidentifyConfig? = nil
}

/// Details information about an error encountered during job execution or
/// the results of an unsuccessful activation of the JobTrigger.
public struct Google_Privacy_Dlp_V2_Error {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Detailed error codes and messages.
  public var details: Google_Rpc_Status {
    get {return _details ?? Google_Rpc_Status()}
    set {_details = newValue}
  }
  /// Returns true if `details` has been explicitly set.
  public var hasDetails: Bool {return self._details != nil}
  /// Clears the value of `details`. Subsequent reads from it will return its default value.
  public mutating func clearDetails() {self._details = nil}

  /// The times the error occurred.
  public var timestamps: [SwiftProtobuf.Google_Protobuf_Timestamp] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _details: Google_Rpc_Status? = nil
}

/// Contains a configuration to make dlp api calls on a repeating basis.
/// See https://cloud.google.com/dlp/docs/concepts-job-triggers to learn more.
public struct Google_Privacy_Dlp_V2_JobTrigger {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique resource name for the triggeredJob, assigned by the service when the
  /// triggeredJob is created, for example
  /// `projects/dlp-test-project/jobTriggers/53234423`.
  public var name: String = String()

  /// Display name (max 100 chars)
  public var displayName: String = String()

  /// User provided description (max 256 chars)
  public var description_p: String = String()

  /// The configuration details for the specific type of job to run.
  public var job: Google_Privacy_Dlp_V2_JobTrigger.OneOf_Job? = nil

  /// For inspect jobs, a snapshot of the configuration.
  public var inspectJob: Google_Privacy_Dlp_V2_InspectJobConfig {
    get {
      if case .inspectJob(let v)? = job {return v}
      return Google_Privacy_Dlp_V2_InspectJobConfig()
    }
    set {job = .inspectJob(newValue)}
  }

  /// A list of triggers which will be OR'ed together. Only one in the list
  /// needs to trigger for a job to be started. The list may contain only
  /// a single Schedule trigger and must have at least one object.
  public var triggers: [Google_Privacy_Dlp_V2_JobTrigger.Trigger] = []

  /// Output only. A stream of errors encountered when the trigger was activated. Repeated
  /// errors may result in the JobTrigger automatically being paused.
  /// Will return the last 100 errors. Whenever the JobTrigger is modified
  /// this list will be cleared.
  public var errors: [Google_Privacy_Dlp_V2_Error] = []

  /// Output only. The creation timestamp of a triggeredJob.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {self._createTime = nil}

  /// Output only. The last update timestamp of a triggeredJob.
  public var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  public var hasUpdateTime: Bool {return self._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateTime() {self._updateTime = nil}

  /// Output only. The timestamp of the last time this trigger executed.
  public var lastRunTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lastRunTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastRunTime = newValue}
  }
  /// Returns true if `lastRunTime` has been explicitly set.
  public var hasLastRunTime: Bool {return self._lastRunTime != nil}
  /// Clears the value of `lastRunTime`. Subsequent reads from it will return its default value.
  public mutating func clearLastRunTime() {self._lastRunTime = nil}

  /// Required. A status for this trigger.
  public var status: Google_Privacy_Dlp_V2_JobTrigger.Status = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The configuration details for the specific type of job to run.
  public enum OneOf_Job: Equatable {
    /// For inspect jobs, a snapshot of the configuration.
    case inspectJob(Google_Privacy_Dlp_V2_InspectJobConfig)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Privacy_Dlp_V2_JobTrigger.OneOf_Job, rhs: Google_Privacy_Dlp_V2_JobTrigger.OneOf_Job) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.inspectJob, .inspectJob): return {
        guard case .inspectJob(let l) = lhs, case .inspectJob(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  /// Whether the trigger is currently active. If PAUSED or CANCELLED, no jobs
  /// will be created with this configuration. The service may automatically
  /// pause triggers experiencing frequent errors. To restart a job, set the
  /// status to HEALTHY after correcting user errors.
  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unused.
    case unspecified // = 0

    /// Trigger is healthy.
    case healthy // = 1

    /// Trigger is temporarily paused.
    case paused // = 2

    /// Trigger is cancelled and can not be resumed.
    case cancelled // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .healthy
      case 2: self = .paused
      case 3: self = .cancelled
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .healthy: return 1
      case .paused: return 2
      case .cancelled: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// What event needs to occur for a new job to be started.
  public struct Trigger {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var trigger: Google_Privacy_Dlp_V2_JobTrigger.Trigger.OneOf_Trigger? = nil

    /// Create a job on a repeating basis based on the elapse of time.
    public var schedule: Google_Privacy_Dlp_V2_Schedule {
      get {
        if case .schedule(let v)? = trigger {return v}
        return Google_Privacy_Dlp_V2_Schedule()
      }
      set {trigger = .schedule(newValue)}
    }

    /// For use with hybrid jobs. Jobs must be manually created and finished.
    /// Early access feature is in a pre-release state and might change or have
    /// limited support. For more information, see
    /// https://cloud.google.com/products#product-launch-stages.
    public var manual: Google_Privacy_Dlp_V2_Manual {
      get {
        if case .manual(let v)? = trigger {return v}
        return Google_Privacy_Dlp_V2_Manual()
      }
      set {trigger = .manual(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Trigger: Equatable {
      /// Create a job on a repeating basis based on the elapse of time.
      case schedule(Google_Privacy_Dlp_V2_Schedule)
      /// For use with hybrid jobs. Jobs must be manually created and finished.
      /// Early access feature is in a pre-release state and might change or have
      /// limited support. For more information, see
      /// https://cloud.google.com/products#product-launch-stages.
      case manual(Google_Privacy_Dlp_V2_Manual)

    #if !swift(>=4.1)
      public static func ==(lhs: Google_Privacy_Dlp_V2_JobTrigger.Trigger.OneOf_Trigger, rhs: Google_Privacy_Dlp_V2_JobTrigger.Trigger.OneOf_Trigger) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.schedule, .schedule): return {
          guard case .schedule(let l) = lhs, case .schedule(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.manual, .manual): return {
          guard case .manual(let l) = lhs, case .manual(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  public init() {}

  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _lastRunTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

#if swift(>=4.2)

extension Google_Privacy_Dlp_V2_JobTrigger.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Privacy_Dlp_V2_JobTrigger.Status] = [
    .unspecified,
    .healthy,
    .paused,
    .cancelled,
  ]
}

#endif  // swift(>=4.2)

/// A task to execute on the completion of a job.
/// See https://cloud.google.com/dlp/docs/concepts-actions to learn more.
public struct Google_Privacy_Dlp_V2_Action {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Google_Privacy_Dlp_V2_Action.OneOf_Action? = nil

  /// Save resulting findings in a provided location.
  public var saveFindings: Google_Privacy_Dlp_V2_Action.SaveFindings {
    get {
      if case .saveFindings(let v)? = action {return v}
      return Google_Privacy_Dlp_V2_Action.SaveFindings()
    }
    set {action = .saveFindings(newValue)}
  }

  /// Publish a notification to a pubsub topic.
  public var pubSub: Google_Privacy_Dlp_V2_Action.PublishToPubSub {
    get {
      if case .pubSub(let v)? = action {return v}
      return Google_Privacy_Dlp_V2_Action.PublishToPubSub()
    }
    set {action = .pubSub(newValue)}
  }

  /// Publish summary to Cloud Security Command Center (Alpha).
  public var publishSummaryToCscc: Google_Privacy_Dlp_V2_Action.PublishSummaryToCscc {
    get {
      if case .publishSummaryToCscc(let v)? = action {return v}
      return Google_Privacy_Dlp_V2_Action.PublishSummaryToCscc()
    }
    set {action = .publishSummaryToCscc(newValue)}
  }

  /// Publish findings to Cloud Datahub.
  public var publishFindingsToCloudDataCatalog: Google_Privacy_Dlp_V2_Action.PublishFindingsToCloudDataCatalog {
    get {
      if case .publishFindingsToCloudDataCatalog(let v)? = action {return v}
      return Google_Privacy_Dlp_V2_Action.PublishFindingsToCloudDataCatalog()
    }
    set {action = .publishFindingsToCloudDataCatalog(newValue)}
  }

  /// Enable email notification for project owners and editors on job's
  /// completion/failure.
  public var jobNotificationEmails: Google_Privacy_Dlp_V2_Action.JobNotificationEmails {
    get {
      if case .jobNotificationEmails(let v)? = action {return v}
      return Google_Privacy_Dlp_V2_Action.JobNotificationEmails()
    }
    set {action = .jobNotificationEmails(newValue)}
  }

  /// Enable Stackdriver metric dlp.googleapis.com/finding_count.
  public var publishToStackdriver: Google_Privacy_Dlp_V2_Action.PublishToStackdriver {
    get {
      if case .publishToStackdriver(let v)? = action {return v}
      return Google_Privacy_Dlp_V2_Action.PublishToStackdriver()
    }
    set {action = .publishToStackdriver(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Action: Equatable {
    /// Save resulting findings in a provided location.
    case saveFindings(Google_Privacy_Dlp_V2_Action.SaveFindings)
    /// Publish a notification to a pubsub topic.
    case pubSub(Google_Privacy_Dlp_V2_Action.PublishToPubSub)
    /// Publish summary to Cloud Security Command Center (Alpha).
    case publishSummaryToCscc(Google_Privacy_Dlp_V2_Action.PublishSummaryToCscc)
    /// Publish findings to Cloud Datahub.
    case publishFindingsToCloudDataCatalog(Google_Privacy_Dlp_V2_Action.PublishFindingsToCloudDataCatalog)
    /// Enable email notification for project owners and editors on job's
    /// completion/failure.
    case jobNotificationEmails(Google_Privacy_Dlp_V2_Action.JobNotificationEmails)
    /// Enable Stackdriver metric dlp.googleapis.com/finding_count.
    case publishToStackdriver(Google_Privacy_Dlp_V2_Action.PublishToStackdriver)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Privacy_Dlp_V2_Action.OneOf_Action, rhs: Google_Privacy_Dlp_V2_Action.OneOf_Action) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.saveFindings, .saveFindings): return {
        guard case .saveFindings(let l) = lhs, case .saveFindings(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pubSub, .pubSub): return {
        guard case .pubSub(let l) = lhs, case .pubSub(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.publishSummaryToCscc, .publishSummaryToCscc): return {
        guard case .publishSummaryToCscc(let l) = lhs, case .publishSummaryToCscc(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.publishFindingsToCloudDataCatalog, .publishFindingsToCloudDataCatalog): return {
        guard case .publishFindingsToCloudDataCatalog(let l) = lhs, case .publishFindingsToCloudDataCatalog(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.jobNotificationEmails, .jobNotificationEmails): return {
        guard case .jobNotificationEmails(let l) = lhs, case .jobNotificationEmails(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.publishToStackdriver, .publishToStackdriver): return {
        guard case .publishToStackdriver(let l) = lhs, case .publishToStackdriver(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// If set, the detailed findings will be persisted to the specified
  /// OutputStorageConfig. Only a single instance of this action can be
  /// specified.
  /// Compatible with: Inspect, Risk
  public struct SaveFindings {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Location to store findings outside of DLP.
    public var outputConfig: Google_Privacy_Dlp_V2_OutputStorageConfig {
      get {return _outputConfig ?? Google_Privacy_Dlp_V2_OutputStorageConfig()}
      set {_outputConfig = newValue}
    }
    /// Returns true if `outputConfig` has been explicitly set.
    public var hasOutputConfig: Bool {return self._outputConfig != nil}
    /// Clears the value of `outputConfig`. Subsequent reads from it will return its default value.
    public mutating func clearOutputConfig() {self._outputConfig = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _outputConfig: Google_Privacy_Dlp_V2_OutputStorageConfig? = nil
  }

  /// Publish a message into given Pub/Sub topic when DlpJob has completed. The
  /// message contains a single field, `DlpJobName`, which is equal to the
  /// finished job's
  /// [`DlpJob.name`](https://cloud.google.com/dlp/docs/reference/rest/v2/projects.dlpJobs#DlpJob).
  /// Compatible with: Inspect, Risk
  public struct PublishToPubSub {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Cloud Pub/Sub topic to send notifications to. The topic must have given
    /// publishing access rights to the DLP API service account executing
    /// the long running DlpJob sending the notifications.
    /// Format is projects/{project}/topics/{topic}.
    public var topic: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Publish the result summary of a DlpJob to the Cloud Security
  /// Command Center (CSCC Alpha).
  /// This action is only available for projects which are parts of
  /// an organization and whitelisted for the alpha Cloud Security Command
  /// Center.
  /// The action will publish count of finding instances and their info types.
  /// The summary of findings will be persisted in CSCC and are governed by CSCC
  /// service-specific policy, see https://cloud.google.com/terms/service-terms
  /// Only a single instance of this action can be specified.
  /// Compatible with: Inspect
  public struct PublishSummaryToCscc {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Publish findings of a DlpJob to Cloud Data Catalog. Labels summarizing the
  /// results of the DlpJob will be applied to the entry for the resource scanned
  /// in Cloud Data Catalog. Any labels previously written by another DlpJob will
  /// be deleted. InfoType naming patterns are strictly enforced when using this
  /// feature. Note that the findings will be persisted in Cloud Data Catalog
  /// storage and are governed by Data Catalog service-specific policy, see
  /// https://cloud.google.com/terms/service-terms
  /// Only a single instance of this action can be specified and only allowed if
  /// all resources being scanned are BigQuery tables.
  /// Compatible with: Inspect
  public struct PublishFindingsToCloudDataCatalog {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Enable email notification to project owners and editors on jobs's
  /// completion/failure.
  public struct JobNotificationEmails {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Enable Stackdriver metric dlp.googleapis.com/finding_count. This
  /// will publish a metric to stack driver on each infotype requested and
  /// how many findings were found for it. CustomDetectors will be bucketed
  /// as 'Custom' under the Stackdriver label 'info_type'.
  public struct PublishToStackdriver {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Request message for CreateInspectTemplate.
public struct Google_Privacy_Dlp_V2_CreateInspectTemplateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Parent resource name.
  ///
  /// The format of this value varies depending on the scope of the request
  /// (project or organization) and whether you have [specified a processing
  /// location](https://cloud.google.com/dlp/docs/specifying-location):
  ///
  /// + Projects scope, location specified:<br/>
  ///   `projects/`<var>PROJECT_ID</var>`/locations/`<var>LOCATION_ID</var>
  /// + Projects scope, no location specified (defaults to global):<br/>
  ///   `projects/`<var>PROJECT_ID</var>
  /// + Organizations scope, location specified:<br/>
  ///   `organizations/`<var>ORG_ID</var>`/locations/`<var>LOCATION_ID</var>
  /// + Organizations scope, no location specified (defaults to global):<br/>
  ///   `organizations/`<var>ORG_ID</var>
  ///
  /// The following example `parent` string specifies a parent project with the
  /// identifier `example-project`, and specifies the `europe-west3` location
  /// for processing data:
  ///
  ///     parent=projects/example-project/locations/europe-west3
  public var parent: String = String()

  /// Required. The InspectTemplate to create.
  public var inspectTemplate: Google_Privacy_Dlp_V2_InspectTemplate {
    get {return _inspectTemplate ?? Google_Privacy_Dlp_V2_InspectTemplate()}
    set {_inspectTemplate = newValue}
  }
  /// Returns true if `inspectTemplate` has been explicitly set.
  public var hasInspectTemplate: Bool {return self._inspectTemplate != nil}
  /// Clears the value of `inspectTemplate`. Subsequent reads from it will return its default value.
  public mutating func clearInspectTemplate() {self._inspectTemplate = nil}

  /// The template id can contain uppercase and lowercase letters,
  /// numbers, and hyphens; that is, it must match the regular
  /// expression: `[a-zA-Z\d-_]+`. The maximum length is 100
  /// characters. Can be empty to allow the system to generate one.
  public var templateID: String = String()

  /// Deprecated. This field has no effect.
  public var locationID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _inspectTemplate: Google_Privacy_Dlp_V2_InspectTemplate? = nil
}

/// Request message for UpdateInspectTemplate.
public struct Google_Privacy_Dlp_V2_UpdateInspectTemplateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Resource name of organization and inspectTemplate to be updated, for
  /// example `organizations/433245324/inspectTemplates/432452342` or
  /// projects/project-id/inspectTemplates/432452342.
  public var name: String = String()

  /// New InspectTemplate value.
  public var inspectTemplate: Google_Privacy_Dlp_V2_InspectTemplate {
    get {return _inspectTemplate ?? Google_Privacy_Dlp_V2_InspectTemplate()}
    set {_inspectTemplate = newValue}
  }
  /// Returns true if `inspectTemplate` has been explicitly set.
  public var hasInspectTemplate: Bool {return self._inspectTemplate != nil}
  /// Clears the value of `inspectTemplate`. Subsequent reads from it will return its default value.
  public mutating func clearInspectTemplate() {self._inspectTemplate = nil}

  /// Mask to control which fields get updated.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _inspectTemplate: Google_Privacy_Dlp_V2_InspectTemplate? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Request message for GetInspectTemplate.
public struct Google_Privacy_Dlp_V2_GetInspectTemplateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Resource name of the organization and inspectTemplate to be read, for
  /// example `organizations/433245324/inspectTemplates/432452342` or
  /// projects/project-id/inspectTemplates/432452342.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for ListInspectTemplates.
public struct Google_Privacy_Dlp_V2_ListInspectTemplatesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Parent resource name.
  ///
  /// The format of this value varies depending on the scope of the request
  /// (project or organization) and whether you have [specified a processing
  /// location](https://cloud.google.com/dlp/docs/specifying-location):
  ///
  /// + Projects scope, location specified:<br/>
  ///   `projects/`<var>PROJECT_ID</var>`/locations/`<var>LOCATION_ID</var>
  /// + Projects scope, no location specified (defaults to global):<br/>
  ///   `projects/`<var>PROJECT_ID</var>
  /// + Organizations scope, location specified:<br/>
  ///   `organizations/`<var>ORG_ID</var>`/locations/`<var>LOCATION_ID</var>
  /// + Organizations scope, no location specified (defaults to global):<br/>
  ///   `organizations/`<var>ORG_ID</var>
  ///
  /// The following example `parent` string specifies a parent project with the
  /// identifier `example-project`, and specifies the `europe-west3` location
  /// for processing data:
  ///
  ///     parent=projects/example-project/locations/europe-west3
  public var parent: String = String()

  /// Page token to continue retrieval. Comes from previous call
  /// to `ListInspectTemplates`.
  public var pageToken: String = String()

  /// Size of the page, can be limited by server. If zero server returns
  /// a page of max size 100.
  public var pageSize: Int32 = 0

  /// Comma separated list of fields to order by,
  /// followed by `asc` or `desc` postfix. This list is case-insensitive,
  /// default sorting order is ascending, redundant space characters are
  /// insignificant.
  ///
  /// Example: `name asc,update_time, create_time desc`
  ///
  /// Supported fields are:
  ///
  /// - `create_time`: corresponds to time the template was created.
  /// - `update_time`: corresponds to time the template was last updated.
  /// - `name`: corresponds to template's name.
  /// - `display_name`: corresponds to template's display name.
  public var orderBy: String = String()

  /// Deprecated. This field has no effect.
  public var locationID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response message for ListInspectTemplates.
public struct Google_Privacy_Dlp_V2_ListInspectTemplatesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of inspectTemplates, up to page_size in ListInspectTemplatesRequest.
  public var inspectTemplates: [Google_Privacy_Dlp_V2_InspectTemplate] = []

  /// If the next page is available then the next page token to be used
  /// in following ListInspectTemplates request.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for DeleteInspectTemplate.
public struct Google_Privacy_Dlp_V2_DeleteInspectTemplateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Resource name of the organization and inspectTemplate to be deleted, for
  /// example `organizations/433245324/inspectTemplates/432452342` or
  /// projects/project-id/inspectTemplates/432452342.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for CreateJobTrigger.
public struct Google_Privacy_Dlp_V2_CreateJobTriggerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Parent resource name.
  ///
  /// The format of this value varies depending on whether you have [specified a
  /// processing
  /// location](https://cloud.google.com/dlp/docs/specifying-location):
  ///
  /// + Projects scope, location specified:<br/>
  ///   `projects/`<var>PROJECT_ID</var>`/locations/`<var>LOCATION_ID</var>
  /// + Projects scope, no location specified (defaults to global):<br/>
  ///   `projects/`<var>PROJECT_ID</var>
  ///
  /// The following example `parent` string specifies a parent project with the
  /// identifier `example-project`, and specifies the `europe-west3` location
  /// for processing data:
  ///
  ///     parent=projects/example-project/locations/europe-west3
  public var parent: String = String()

  /// Required. The JobTrigger to create.
  public var jobTrigger: Google_Privacy_Dlp_V2_JobTrigger {
    get {return _jobTrigger ?? Google_Privacy_Dlp_V2_JobTrigger()}
    set {_jobTrigger = newValue}
  }
  /// Returns true if `jobTrigger` has been explicitly set.
  public var hasJobTrigger: Bool {return self._jobTrigger != nil}
  /// Clears the value of `jobTrigger`. Subsequent reads from it will return its default value.
  public mutating func clearJobTrigger() {self._jobTrigger = nil}

  /// The trigger id can contain uppercase and lowercase letters,
  /// numbers, and hyphens; that is, it must match the regular
  /// expression: `[a-zA-Z\d-_]+`. The maximum length is 100
  /// characters. Can be empty to allow the system to generate one.
  public var triggerID: String = String()

  /// Deprecated. This field has no effect.
  public var locationID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _jobTrigger: Google_Privacy_Dlp_V2_JobTrigger? = nil
}

/// Request message for ActivateJobTrigger.
public struct Google_Privacy_Dlp_V2_ActivateJobTriggerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Resource name of the trigger to activate, for example
  /// `projects/dlp-test-project/jobTriggers/53234423`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for UpdateJobTrigger.
public struct Google_Privacy_Dlp_V2_UpdateJobTriggerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Resource name of the project and the triggeredJob, for example
  /// `projects/dlp-test-project/jobTriggers/53234423`.
  public var name: String = String()

  /// New JobTrigger value.
  public var jobTrigger: Google_Privacy_Dlp_V2_JobTrigger {
    get {return _jobTrigger ?? Google_Privacy_Dlp_V2_JobTrigger()}
    set {_jobTrigger = newValue}
  }
  /// Returns true if `jobTrigger` has been explicitly set.
  public var hasJobTrigger: Bool {return self._jobTrigger != nil}
  /// Clears the value of `jobTrigger`. Subsequent reads from it will return its default value.
  public mutating func clearJobTrigger() {self._jobTrigger = nil}

  /// Mask to control which fields get updated.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _jobTrigger: Google_Privacy_Dlp_V2_JobTrigger? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Request message for GetJobTrigger.
public struct Google_Privacy_Dlp_V2_GetJobTriggerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Resource name of the project and the triggeredJob, for example
  /// `projects/dlp-test-project/jobTriggers/53234423`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for CreateDlpJobRequest. Used to initiate long running
/// jobs such as calculating risk metrics or inspecting Google Cloud
/// Storage.
public struct Google_Privacy_Dlp_V2_CreateDlpJobRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Parent resource name.
  ///
  /// The format of this value varies depending on whether you have [specified a
  /// processing
  /// location](https://cloud.google.com/dlp/docs/specifying-location):
  ///
  /// + Projects scope, location specified:<br/>
  ///   `projects/`<var>PROJECT_ID</var>`/locations/`<var>LOCATION_ID</var>
  /// + Projects scope, no location specified (defaults to global):<br/>
  ///   `projects/`<var>PROJECT_ID</var>
  ///
  /// The following example `parent` string specifies a parent project with the
  /// identifier `example-project`, and specifies the `europe-west3` location
  /// for processing data:
  ///
  ///     parent=projects/example-project/locations/europe-west3
  public var parent: String = String()

  /// The configuration details for the specific type of job to run.
  public var job: Google_Privacy_Dlp_V2_CreateDlpJobRequest.OneOf_Job? = nil

  /// Set to control what and how to inspect.
  public var inspectJob: Google_Privacy_Dlp_V2_InspectJobConfig {
    get {
      if case .inspectJob(let v)? = job {return v}
      return Google_Privacy_Dlp_V2_InspectJobConfig()
    }
    set {job = .inspectJob(newValue)}
  }

  /// Set to choose what metric to calculate.
  public var riskJob: Google_Privacy_Dlp_V2_RiskAnalysisJobConfig {
    get {
      if case .riskJob(let v)? = job {return v}
      return Google_Privacy_Dlp_V2_RiskAnalysisJobConfig()
    }
    set {job = .riskJob(newValue)}
  }

  /// The job id can contain uppercase and lowercase letters,
  /// numbers, and hyphens; that is, it must match the regular
  /// expression: `[a-zA-Z\d-_]+`. The maximum length is 100
  /// characters. Can be empty to allow the system to generate one.
  public var jobID: String = String()

  /// Deprecated. This field has no effect.
  public var locationID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The configuration details for the specific type of job to run.
  public enum OneOf_Job: Equatable {
    /// Set to control what and how to inspect.
    case inspectJob(Google_Privacy_Dlp_V2_InspectJobConfig)
    /// Set to choose what metric to calculate.
    case riskJob(Google_Privacy_Dlp_V2_RiskAnalysisJobConfig)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Privacy_Dlp_V2_CreateDlpJobRequest.OneOf_Job, rhs: Google_Privacy_Dlp_V2_CreateDlpJobRequest.OneOf_Job) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.inspectJob, .inspectJob): return {
        guard case .inspectJob(let l) = lhs, case .inspectJob(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.riskJob, .riskJob): return {
        guard case .riskJob(let l) = lhs, case .riskJob(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Request message for ListJobTriggers.
public struct Google_Privacy_Dlp_V2_ListJobTriggersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Parent resource name.
  ///
  /// The format of this value varies depending on whether you have [specified a
  /// processing
  /// location](https://cloud.google.com/dlp/docs/specifying-location):
  ///
  /// + Projects scope, location specified:<br/>
  ///   `projects/`<var>PROJECT_ID</var>`/locations/`<var>LOCATION_ID</var>
  /// + Projects scope, no location specified (defaults to global):<br/>
  ///   `projects/`<var>PROJECT_ID</var>
  ///
  /// The following example `parent` string specifies a parent project with the
  /// identifier `example-project`, and specifies the `europe-west3` location
  /// for processing data:
  ///
  ///     parent=projects/example-project/locations/europe-west3
  public var parent: String = String()

  /// Page token to continue retrieval. Comes from previous call
  /// to ListJobTriggers. `order_by` field must not
  /// change for subsequent calls.
  public var pageToken: String = String()

  /// Size of the page, can be limited by a server.
  public var pageSize: Int32 = 0

  /// Comma separated list of triggeredJob fields to order by,
  /// followed by `asc` or `desc` postfix. This list is case-insensitive,
  /// default sorting order is ascending, redundant space characters are
  /// insignificant.
  ///
  /// Example: `name asc,update_time, create_time desc`
  ///
  /// Supported fields are:
  ///
  /// - `create_time`: corresponds to time the JobTrigger was created.
  /// - `update_time`: corresponds to time the JobTrigger was last updated.
  /// - `last_run_time`: corresponds to the last time the JobTrigger ran.
  /// - `name`: corresponds to JobTrigger's name.
  /// - `display_name`: corresponds to JobTrigger's display name.
  /// - `status`: corresponds to JobTrigger's status.
  public var orderBy: String = String()

  /// Allows filtering.
  ///
  /// Supported syntax:
  ///
  /// * Filter expressions are made up of one or more restrictions.
  /// * Restrictions can be combined by `AND` or `OR` logical operators. A
  /// sequence of restrictions implicitly uses `AND`.
  /// * A restriction has the form of `{field} {operator} {value}`.
  /// * Supported fields/values for inspect jobs:
  ///     - `status` - HEALTHY|PAUSED|CANCELLED
  ///     - `inspected_storage` - DATASTORE|CLOUD_STORAGE|BIGQUERY
  ///     - 'last_run_time` - RFC 3339 formatted timestamp, surrounded by
  ///     quotation marks. Nanoseconds are ignored.
  ///     - 'error_count' - Number of errors that have occurred while running.
  /// * The operator must be `=` or `!=` for status and inspected_storage.
  ///
  /// Examples:
  ///
  /// * inspected_storage = cloud_storage AND status = HEALTHY
  /// * inspected_storage = cloud_storage OR inspected_storage = bigquery
  /// * inspected_storage = cloud_storage AND (state = PAUSED OR state = HEALTHY)
  /// * last_run_time > \"2017-12-12T00:00:00+00:00\"
  ///
  /// The length of this field should be no more than 500 characters.
  public var filter: String = String()

  /// Deprecated. This field has no effect.
  public var locationID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response message for ListJobTriggers.
public struct Google_Privacy_Dlp_V2_ListJobTriggersResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of triggeredJobs, up to page_size in ListJobTriggersRequest.
  public var jobTriggers: [Google_Privacy_Dlp_V2_JobTrigger] = []

  /// If the next page is available then the next page token to be used
  /// in following ListJobTriggers request.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for DeleteJobTrigger.
public struct Google_Privacy_Dlp_V2_DeleteJobTriggerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Resource name of the project and the triggeredJob, for example
  /// `projects/dlp-test-project/jobTriggers/53234423`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Controls what and how to inspect for findings.
public struct Google_Privacy_Dlp_V2_InspectJobConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The data to scan.
  public var storageConfig: Google_Privacy_Dlp_V2_StorageConfig {
    get {return _storage._storageConfig ?? Google_Privacy_Dlp_V2_StorageConfig()}
    set {_uniqueStorage()._storageConfig = newValue}
  }
  /// Returns true if `storageConfig` has been explicitly set.
  public var hasStorageConfig: Bool {return _storage._storageConfig != nil}
  /// Clears the value of `storageConfig`. Subsequent reads from it will return its default value.
  public mutating func clearStorageConfig() {_uniqueStorage()._storageConfig = nil}

  /// How and what to scan for.
  public var inspectConfig: Google_Privacy_Dlp_V2_InspectConfig {
    get {return _storage._inspectConfig ?? Google_Privacy_Dlp_V2_InspectConfig()}
    set {_uniqueStorage()._inspectConfig = newValue}
  }
  /// Returns true if `inspectConfig` has been explicitly set.
  public var hasInspectConfig: Bool {return _storage._inspectConfig != nil}
  /// Clears the value of `inspectConfig`. Subsequent reads from it will return its default value.
  public mutating func clearInspectConfig() {_uniqueStorage()._inspectConfig = nil}

  /// If provided, will be used as the default for all values in InspectConfig.
  /// `inspect_config` will be merged into the values persisted as part of the
  /// template.
  public var inspectTemplateName: String {
    get {return _storage._inspectTemplateName}
    set {_uniqueStorage()._inspectTemplateName = newValue}
  }

  /// Actions to execute at the completion of the job.
  public var actions: [Google_Privacy_Dlp_V2_Action] {
    get {return _storage._actions}
    set {_uniqueStorage()._actions = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Combines all of the information about a DLP job.
public struct Google_Privacy_Dlp_V2_DlpJob {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The server-assigned name.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// The type of job.
  public var type: Google_Privacy_Dlp_V2_DlpJobType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  /// State of a job.
  public var state: Google_Privacy_Dlp_V2_DlpJob.JobState {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  public var details: OneOf_Details? {
    get {return _storage._details}
    set {_uniqueStorage()._details = newValue}
  }

  /// Results from analyzing risk of a data source.
  public var riskDetails: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails {
    get {
      if case .riskDetails(let v)? = _storage._details {return v}
      return Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails()
    }
    set {_uniqueStorage()._details = .riskDetails(newValue)}
  }

  /// Results from inspecting a data source.
  public var inspectDetails: Google_Privacy_Dlp_V2_InspectDataSourceDetails {
    get {
      if case .inspectDetails(let v)? = _storage._details {return v}
      return Google_Privacy_Dlp_V2_InspectDataSourceDetails()
    }
    set {_uniqueStorage()._details = .inspectDetails(newValue)}
  }

  /// Time when the job was created.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return _storage._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {_uniqueStorage()._createTime = nil}

  /// Time when the job started.
  public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return _storage._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {_uniqueStorage()._startTime = nil}

  /// Time when the job finished.
  public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return _storage._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {_uniqueStorage()._endTime = nil}

  /// If created by a job trigger, the resource name of the trigger that
  /// instantiated the job.
  public var jobTriggerName: String {
    get {return _storage._jobTriggerName}
    set {_uniqueStorage()._jobTriggerName = newValue}
  }

  /// A stream of errors encountered running the job.
  public var errors: [Google_Privacy_Dlp_V2_Error] {
    get {return _storage._errors}
    set {_uniqueStorage()._errors = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Details: Equatable {
    /// Results from analyzing risk of a data source.
    case riskDetails(Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails)
    /// Results from inspecting a data source.
    case inspectDetails(Google_Privacy_Dlp_V2_InspectDataSourceDetails)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Privacy_Dlp_V2_DlpJob.OneOf_Details, rhs: Google_Privacy_Dlp_V2_DlpJob.OneOf_Details) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.riskDetails, .riskDetails): return {
        guard case .riskDetails(let l) = lhs, case .riskDetails(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.inspectDetails, .inspectDetails): return {
        guard case .inspectDetails(let l) = lhs, case .inspectDetails(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Possible states of a job. New items may be added.
  public enum JobState: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unused.
    case unspecified // = 0

    /// The job has not yet started.
    case pending // = 1

    /// The job is currently running. Once a job has finished it will transition
    /// to FAILED or DONE.
    case running // = 2

    /// The job is no longer running.
    case done // = 3

    /// The job was canceled before it could complete.
    case canceled // = 4

    /// The job had an error and did not complete.
    case failed // = 5

    /// The job is currently accepting findings via hybridInspect.
    /// A hybrid job in ACTIVE state may continue to have findings added to it
    /// through calling of hybridInspect. After the job has finished no more
    /// calls to hybridInspect may be made. ACTIVE jobs can transition to DONE.
    case active // = 6
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .pending
      case 2: self = .running
      case 3: self = .done
      case 4: self = .canceled
      case 5: self = .failed
      case 6: self = .active
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .pending: return 1
      case .running: return 2
      case .done: return 3
      case .canceled: return 4
      case .failed: return 5
      case .active: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Google_Privacy_Dlp_V2_DlpJob.JobState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Privacy_Dlp_V2_DlpJob.JobState] = [
    .unspecified,
    .pending,
    .running,
    .done,
    .canceled,
    .failed,
    .active,
  ]
}

#endif  // swift(>=4.2)

/// The request message for [DlpJobs.GetDlpJob][].
public struct Google_Privacy_Dlp_V2_GetDlpJobRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the DlpJob resource.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request message for listing DLP jobs.
public struct Google_Privacy_Dlp_V2_ListDlpJobsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Parent resource name.
  ///
  /// The format of this value varies depending on whether you have [specified a
  /// processing
  /// location](https://cloud.google.com/dlp/docs/specifying-location):
  ///
  /// + Projects scope, location specified:<br/>
  ///   `projects/`<var>PROJECT_ID</var>`/locations/`<var>LOCATION_ID</var>
  /// + Projects scope, no location specified (defaults to global):<br/>
  ///   `projects/`<var>PROJECT_ID</var>
  ///
  /// The following example `parent` string specifies a parent project with the
  /// identifier `example-project`, and specifies the `europe-west3` location
  /// for processing data:
  ///
  ///     parent=projects/example-project/locations/europe-west3
  public var parent: String = String()

  /// Allows filtering.
  ///
  /// Supported syntax:
  ///
  /// * Filter expressions are made up of one or more restrictions.
  /// * Restrictions can be combined by `AND` or `OR` logical operators. A
  /// sequence of restrictions implicitly uses `AND`.
  /// * A restriction has the form of `{field} {operator} {value}`.
  /// * Supported fields/values for inspect jobs:
  ///     - `state` - PENDING|RUNNING|CANCELED|FINISHED|FAILED
  ///     - `inspected_storage` - DATASTORE|CLOUD_STORAGE|BIGQUERY
  ///     - `trigger_name` - The resource name of the trigger that created job.
  ///     - 'end_time` - Corresponds to time the job finished.
  ///     - 'start_time` - Corresponds to time the job finished.
  /// * Supported fields for risk analysis jobs:
  ///     - `state` - RUNNING|CANCELED|FINISHED|FAILED
  ///     - 'end_time` - Corresponds to time the job finished.
  ///     - 'start_time` - Corresponds to time the job finished.
  /// * The operator must be `=` or `!=`.
  ///
  /// Examples:
  ///
  /// * inspected_storage = cloud_storage AND state = done
  /// * inspected_storage = cloud_storage OR inspected_storage = bigquery
  /// * inspected_storage = cloud_storage AND (state = done OR state = canceled)
  /// * end_time > \"2017-12-12T00:00:00+00:00\"
  ///
  /// The length of this field should be no more than 500 characters.
  public var filter: String = String()

  /// The standard list page size.
  public var pageSize: Int32 = 0

  /// The standard list page token.
  public var pageToken: String = String()

  /// The type of job. Defaults to `DlpJobType.INSPECT`
  public var type: Google_Privacy_Dlp_V2_DlpJobType = .unspecified

  /// Comma separated list of fields to order by,
  /// followed by `asc` or `desc` postfix. This list is case-insensitive,
  /// default sorting order is ascending, redundant space characters are
  /// insignificant.
  ///
  /// Example: `name asc, end_time asc, create_time desc`
  ///
  /// Supported fields are:
  ///
  /// - `create_time`: corresponds to time the job was created.
  /// - `end_time`: corresponds to time the job ended.
  /// - `name`: corresponds to job's name.
  /// - `state`: corresponds to `state`
  public var orderBy: String = String()

  /// Deprecated. This field has no effect.
  public var locationID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The response message for listing DLP jobs.
public struct Google_Privacy_Dlp_V2_ListDlpJobsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of DlpJobs that matches the specified filter in the request.
  public var jobs: [Google_Privacy_Dlp_V2_DlpJob] = []

  /// The standard List next-page token.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request message for canceling a DLP job.
public struct Google_Privacy_Dlp_V2_CancelDlpJobRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the DlpJob resource to be cancelled.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request message for finishing a DLP hybrid job.
public struct Google_Privacy_Dlp_V2_FinishDlpJobRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the DlpJob resource to be cancelled.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request message for deleting a DLP job.
public struct Google_Privacy_Dlp_V2_DeleteDlpJobRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the DlpJob resource to be deleted.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for CreateDeidentifyTemplate.
public struct Google_Privacy_Dlp_V2_CreateDeidentifyTemplateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Parent resource name.
  ///
  /// The format of this value varies depending on the scope of the request
  /// (project or organization) and whether you have [specified a processing
  /// location](https://cloud.google.com/dlp/docs/specifying-location):
  ///
  /// + Projects scope, location specified:<br/>
  ///   `projects/`<var>PROJECT_ID</var>`/locations/`<var>LOCATION_ID</var>
  /// + Projects scope, no location specified (defaults to global):<br/>
  ///   `projects/`<var>PROJECT_ID</var>
  /// + Organizations scope, location specified:<br/>
  ///   `organizations/`<var>ORG_ID</var>`/locations/`<var>LOCATION_ID</var>
  /// + Organizations scope, no location specified (defaults to global):<br/>
  ///   `organizations/`<var>ORG_ID</var>
  ///
  /// The following example `parent` string specifies a parent project with the
  /// identifier `example-project`, and specifies the `europe-west3` location
  /// for processing data:
  ///
  ///     parent=projects/example-project/locations/europe-west3
  public var parent: String = String()

  /// Required. The DeidentifyTemplate to create.
  public var deidentifyTemplate: Google_Privacy_Dlp_V2_DeidentifyTemplate {
    get {return _deidentifyTemplate ?? Google_Privacy_Dlp_V2_DeidentifyTemplate()}
    set {_deidentifyTemplate = newValue}
  }
  /// Returns true if `deidentifyTemplate` has been explicitly set.
  public var hasDeidentifyTemplate: Bool {return self._deidentifyTemplate != nil}
  /// Clears the value of `deidentifyTemplate`. Subsequent reads from it will return its default value.
  public mutating func clearDeidentifyTemplate() {self._deidentifyTemplate = nil}

  /// The template id can contain uppercase and lowercase letters,
  /// numbers, and hyphens; that is, it must match the regular
  /// expression: `[a-zA-Z\d-_]+`. The maximum length is 100
  /// characters. Can be empty to allow the system to generate one.
  public var templateID: String = String()

  /// Deprecated. This field has no effect.
  public var locationID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _deidentifyTemplate: Google_Privacy_Dlp_V2_DeidentifyTemplate? = nil
}

/// Request message for UpdateDeidentifyTemplate.
public struct Google_Privacy_Dlp_V2_UpdateDeidentifyTemplateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Resource name of organization and deidentify template to be updated, for
  /// example `organizations/433245324/deidentifyTemplates/432452342` or
  /// projects/project-id/deidentifyTemplates/432452342.
  public var name: String = String()

  /// New DeidentifyTemplate value.
  public var deidentifyTemplate: Google_Privacy_Dlp_V2_DeidentifyTemplate {
    get {return _deidentifyTemplate ?? Google_Privacy_Dlp_V2_DeidentifyTemplate()}
    set {_deidentifyTemplate = newValue}
  }
  /// Returns true if `deidentifyTemplate` has been explicitly set.
  public var hasDeidentifyTemplate: Bool {return self._deidentifyTemplate != nil}
  /// Clears the value of `deidentifyTemplate`. Subsequent reads from it will return its default value.
  public mutating func clearDeidentifyTemplate() {self._deidentifyTemplate = nil}

  /// Mask to control which fields get updated.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _deidentifyTemplate: Google_Privacy_Dlp_V2_DeidentifyTemplate? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Request message for GetDeidentifyTemplate.
public struct Google_Privacy_Dlp_V2_GetDeidentifyTemplateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Resource name of the organization and deidentify template to be read, for
  /// example `organizations/433245324/deidentifyTemplates/432452342` or
  /// projects/project-id/deidentifyTemplates/432452342.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for ListDeidentifyTemplates.
public struct Google_Privacy_Dlp_V2_ListDeidentifyTemplatesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Parent resource name.
  ///
  /// The format of this value varies depending on the scope of the request
  /// (project or organization) and whether you have [specified a processing
  /// location](https://cloud.google.com/dlp/docs/specifying-location):
  ///
  /// + Projects scope, location specified:<br/>
  ///   `projects/`<var>PROJECT_ID</var>`/locations/`<var>LOCATION_ID</var>
  /// + Projects scope, no location specified (defaults to global):<br/>
  ///   `projects/`<var>PROJECT_ID</var>
  /// + Organizations scope, location specified:<br/>
  ///   `organizations/`<var>ORG_ID</var>`/locations/`<var>LOCATION_ID</var>
  /// + Organizations scope, no location specified (defaults to global):<br/>
  ///   `organizations/`<var>ORG_ID</var>
  ///
  /// The following example `parent` string specifies a parent project with the
  /// identifier `example-project`, and specifies the `europe-west3` location
  /// for processing data:
  ///
  ///     parent=projects/example-project/locations/europe-west3
  public var parent: String = String()

  /// Page token to continue retrieval. Comes from previous call
  /// to `ListDeidentifyTemplates`.
  public var pageToken: String = String()

  /// Size of the page, can be limited by server. If zero server returns
  /// a page of max size 100.
  public var pageSize: Int32 = 0

  /// Comma separated list of fields to order by,
  /// followed by `asc` or `desc` postfix. This list is case-insensitive,
  /// default sorting order is ascending, redundant space characters are
  /// insignificant.
  ///
  /// Example: `name asc,update_time, create_time desc`
  ///
  /// Supported fields are:
  ///
  /// - `create_time`: corresponds to time the template was created.
  /// - `update_time`: corresponds to time the template was last updated.
  /// - `name`: corresponds to template's name.
  /// - `display_name`: corresponds to template's display name.
  public var orderBy: String = String()

  /// Deprecated. This field has no effect.
  public var locationID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response message for ListDeidentifyTemplates.
public struct Google_Privacy_Dlp_V2_ListDeidentifyTemplatesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of deidentify templates, up to page_size in
  /// ListDeidentifyTemplatesRequest.
  public var deidentifyTemplates: [Google_Privacy_Dlp_V2_DeidentifyTemplate] = []

  /// If the next page is available then the next page token to be used
  /// in following ListDeidentifyTemplates request.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for DeleteDeidentifyTemplate.
public struct Google_Privacy_Dlp_V2_DeleteDeidentifyTemplateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Resource name of the organization and deidentify template to be deleted,
  /// for example `organizations/433245324/deidentifyTemplates/432452342` or
  /// projects/project-id/deidentifyTemplates/432452342.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Configuration for a custom dictionary created from a data source of any size
/// up to the maximum size defined in the
/// [limits](https://cloud.google.com/dlp/limits) page. The artifacts of
/// dictionary creation are stored in the specified Google Cloud Storage
/// location. Consider using `CustomInfoType.Dictionary` for smaller dictionaries
/// that satisfy the size requirements.
public struct Google_Privacy_Dlp_V2_LargeCustomDictionaryConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Location to store dictionary artifacts in Google Cloud Storage. These files
  /// will only be accessible by project owners and the DLP API. If any of these
  /// artifacts are modified, the dictionary is considered invalid and can no
  /// longer be used.
  public var outputPath: Google_Privacy_Dlp_V2_CloudStoragePath {
    get {return _outputPath ?? Google_Privacy_Dlp_V2_CloudStoragePath()}
    set {_outputPath = newValue}
  }
  /// Returns true if `outputPath` has been explicitly set.
  public var hasOutputPath: Bool {return self._outputPath != nil}
  /// Clears the value of `outputPath`. Subsequent reads from it will return its default value.
  public mutating func clearOutputPath() {self._outputPath = nil}

  public var source: Google_Privacy_Dlp_V2_LargeCustomDictionaryConfig.OneOf_Source? = nil

  /// Set of files containing newline-delimited lists of dictionary phrases.
  public var cloudStorageFileSet: Google_Privacy_Dlp_V2_CloudStorageFileSet {
    get {
      if case .cloudStorageFileSet(let v)? = source {return v}
      return Google_Privacy_Dlp_V2_CloudStorageFileSet()
    }
    set {source = .cloudStorageFileSet(newValue)}
  }

  /// Field in a BigQuery table where each cell represents a dictionary phrase.
  public var bigQueryField: Google_Privacy_Dlp_V2_BigQueryField {
    get {
      if case .bigQueryField(let v)? = source {return v}
      return Google_Privacy_Dlp_V2_BigQueryField()
    }
    set {source = .bigQueryField(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Source: Equatable {
    /// Set of files containing newline-delimited lists of dictionary phrases.
    case cloudStorageFileSet(Google_Privacy_Dlp_V2_CloudStorageFileSet)
    /// Field in a BigQuery table where each cell represents a dictionary phrase.
    case bigQueryField(Google_Privacy_Dlp_V2_BigQueryField)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Privacy_Dlp_V2_LargeCustomDictionaryConfig.OneOf_Source, rhs: Google_Privacy_Dlp_V2_LargeCustomDictionaryConfig.OneOf_Source) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.cloudStorageFileSet, .cloudStorageFileSet): return {
        guard case .cloudStorageFileSet(let l) = lhs, case .cloudStorageFileSet(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bigQueryField, .bigQueryField): return {
        guard case .bigQueryField(let l) = lhs, case .bigQueryField(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _outputPath: Google_Privacy_Dlp_V2_CloudStoragePath? = nil
}

/// Summary statistics of a custom dictionary.
public struct Google_Privacy_Dlp_V2_LargeCustomDictionaryStats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Approximate number of distinct phrases in the dictionary.
  public var approxNumPhrases: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Configuration for stored infoTypes. All fields and subfield are provided
/// by the user. For more information, see
/// https://cloud.google.com/dlp/docs/creating-custom-infotypes.
public struct Google_Privacy_Dlp_V2_StoredInfoTypeConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Display name of the StoredInfoType (max 256 characters).
  public var displayName: String = String()

  /// Description of the StoredInfoType (max 256 characters).
  public var description_p: String = String()

  /// Stored infotype types.
  public var type: Google_Privacy_Dlp_V2_StoredInfoTypeConfig.OneOf_Type? = nil

  /// StoredInfoType where findings are defined by a dictionary of phrases.
  public var largeCustomDictionary: Google_Privacy_Dlp_V2_LargeCustomDictionaryConfig {
    get {
      if case .largeCustomDictionary(let v)? = type {return v}
      return Google_Privacy_Dlp_V2_LargeCustomDictionaryConfig()
    }
    set {type = .largeCustomDictionary(newValue)}
  }

  /// Store dictionary-based CustomInfoType.
  public var dictionary: Google_Privacy_Dlp_V2_CustomInfoType.Dictionary {
    get {
      if case .dictionary(let v)? = type {return v}
      return Google_Privacy_Dlp_V2_CustomInfoType.Dictionary()
    }
    set {type = .dictionary(newValue)}
  }

  /// Store regular expression-based StoredInfoType.
  public var regex: Google_Privacy_Dlp_V2_CustomInfoType.Regex {
    get {
      if case .regex(let v)? = type {return v}
      return Google_Privacy_Dlp_V2_CustomInfoType.Regex()
    }
    set {type = .regex(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Stored infotype types.
  public enum OneOf_Type: Equatable {
    /// StoredInfoType where findings are defined by a dictionary of phrases.
    case largeCustomDictionary(Google_Privacy_Dlp_V2_LargeCustomDictionaryConfig)
    /// Store dictionary-based CustomInfoType.
    case dictionary(Google_Privacy_Dlp_V2_CustomInfoType.Dictionary)
    /// Store regular expression-based StoredInfoType.
    case regex(Google_Privacy_Dlp_V2_CustomInfoType.Regex)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Privacy_Dlp_V2_StoredInfoTypeConfig.OneOf_Type, rhs: Google_Privacy_Dlp_V2_StoredInfoTypeConfig.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.largeCustomDictionary, .largeCustomDictionary): return {
        guard case .largeCustomDictionary(let l) = lhs, case .largeCustomDictionary(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dictionary, .dictionary): return {
        guard case .dictionary(let l) = lhs, case .dictionary(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.regex, .regex): return {
        guard case .regex(let l) = lhs, case .regex(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Statistics for a StoredInfoType.
public struct Google_Privacy_Dlp_V2_StoredInfoTypeStats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Stat types
  public var type: Google_Privacy_Dlp_V2_StoredInfoTypeStats.OneOf_Type? = nil

  /// StoredInfoType where findings are defined by a dictionary of phrases.
  public var largeCustomDictionary: Google_Privacy_Dlp_V2_LargeCustomDictionaryStats {
    get {
      if case .largeCustomDictionary(let v)? = type {return v}
      return Google_Privacy_Dlp_V2_LargeCustomDictionaryStats()
    }
    set {type = .largeCustomDictionary(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Stat types
  public enum OneOf_Type: Equatable {
    /// StoredInfoType where findings are defined by a dictionary of phrases.
    case largeCustomDictionary(Google_Privacy_Dlp_V2_LargeCustomDictionaryStats)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Privacy_Dlp_V2_StoredInfoTypeStats.OneOf_Type, rhs: Google_Privacy_Dlp_V2_StoredInfoTypeStats.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.largeCustomDictionary, .largeCustomDictionary): return {
        guard case .largeCustomDictionary(let l) = lhs, case .largeCustomDictionary(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

/// Version of a StoredInfoType, including the configuration used to build it,
/// create timestamp, and current state.
public struct Google_Privacy_Dlp_V2_StoredInfoTypeVersion {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// StoredInfoType configuration.
  public var config: Google_Privacy_Dlp_V2_StoredInfoTypeConfig {
    get {return _config ?? Google_Privacy_Dlp_V2_StoredInfoTypeConfig()}
    set {_config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  public var hasConfig: Bool {return self._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  public mutating func clearConfig() {self._config = nil}

  /// Create timestamp of the version. Read-only, determined by the system
  /// when the version is created.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {self._createTime = nil}

  /// Stored info type version state. Read-only, updated by the system
  /// during dictionary creation.
  public var state: Google_Privacy_Dlp_V2_StoredInfoTypeState = .unspecified

  /// Errors that occurred when creating this storedInfoType version, or
  /// anomalies detected in the storedInfoType data that render it unusable. Only
  /// the five most recent errors will be displayed, with the most recent error
  /// appearing first.
  ///
  /// For example, some of the data for stored custom dictionaries is put in
  /// the user's Google Cloud Storage bucket, and if this data is modified or
  /// deleted by the user or another system, the dictionary becomes invalid.
  ///
  /// If any errors occur, fix the problem indicated by the error message and
  /// use the UpdateStoredInfoType API method to create another version of the
  /// storedInfoType to continue using it, reusing the same `config` if it was
  /// not the source of the error.
  public var errors: [Google_Privacy_Dlp_V2_Error] = []

  /// Statistics about this storedInfoType version.
  public var stats: Google_Privacy_Dlp_V2_StoredInfoTypeStats {
    get {return _stats ?? Google_Privacy_Dlp_V2_StoredInfoTypeStats()}
    set {_stats = newValue}
  }
  /// Returns true if `stats` has been explicitly set.
  public var hasStats: Bool {return self._stats != nil}
  /// Clears the value of `stats`. Subsequent reads from it will return its default value.
  public mutating func clearStats() {self._stats = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _config: Google_Privacy_Dlp_V2_StoredInfoTypeConfig? = nil
  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _stats: Google_Privacy_Dlp_V2_StoredInfoTypeStats? = nil
}

/// StoredInfoType resource message that contains information about the current
/// version and any pending updates.
public struct Google_Privacy_Dlp_V2_StoredInfoType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Resource name.
  public var name: String = String()

  /// Current version of the stored info type.
  public var currentVersion: Google_Privacy_Dlp_V2_StoredInfoTypeVersion {
    get {return _currentVersion ?? Google_Privacy_Dlp_V2_StoredInfoTypeVersion()}
    set {_currentVersion = newValue}
  }
  /// Returns true if `currentVersion` has been explicitly set.
  public var hasCurrentVersion: Bool {return self._currentVersion != nil}
  /// Clears the value of `currentVersion`. Subsequent reads from it will return its default value.
  public mutating func clearCurrentVersion() {self._currentVersion = nil}

  /// Pending versions of the stored info type. Empty if no versions are
  /// pending.
  public var pendingVersions: [Google_Privacy_Dlp_V2_StoredInfoTypeVersion] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _currentVersion: Google_Privacy_Dlp_V2_StoredInfoTypeVersion? = nil
}

/// Request message for CreateStoredInfoType.
public struct Google_Privacy_Dlp_V2_CreateStoredInfoTypeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Parent resource name.
  ///
  /// The format of this value varies depending on the scope of the request
  /// (project or organization) and whether you have [specified a processing
  /// location](https://cloud.google.com/dlp/docs/specifying-location):
  ///
  /// + Projects scope, location specified:<br/>
  ///   `projects/`<var>PROJECT_ID</var>`/locations/`<var>LOCATION_ID</var>
  /// + Projects scope, no location specified (defaults to global):<br/>
  ///   `projects/`<var>PROJECT_ID</var>
  /// + Organizations scope, location specified:<br/>
  ///   `organizations/`<var>ORG_ID</var>`/locations/`<var>LOCATION_ID</var>
  /// + Organizations scope, no location specified (defaults to global):<br/>
  ///   `organizations/`<var>ORG_ID</var>
  ///
  /// The following example `parent` string specifies a parent project with the
  /// identifier `example-project`, and specifies the `europe-west3` location
  /// for processing data:
  ///
  ///     parent=projects/example-project/locations/europe-west3
  public var parent: String = String()

  /// Required. Configuration of the storedInfoType to create.
  public var config: Google_Privacy_Dlp_V2_StoredInfoTypeConfig {
    get {return _config ?? Google_Privacy_Dlp_V2_StoredInfoTypeConfig()}
    set {_config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  public var hasConfig: Bool {return self._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  public mutating func clearConfig() {self._config = nil}

  /// The storedInfoType ID can contain uppercase and lowercase letters,
  /// numbers, and hyphens; that is, it must match the regular
  /// expression: `[a-zA-Z\d-_]+`. The maximum length is 100
  /// characters. Can be empty to allow the system to generate one.
  public var storedInfoTypeID: String = String()

  /// Deprecated. This field has no effect.
  public var locationID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _config: Google_Privacy_Dlp_V2_StoredInfoTypeConfig? = nil
}

/// Request message for UpdateStoredInfoType.
public struct Google_Privacy_Dlp_V2_UpdateStoredInfoTypeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Resource name of organization and storedInfoType to be updated, for
  /// example `organizations/433245324/storedInfoTypes/432452342` or
  /// projects/project-id/storedInfoTypes/432452342.
  public var name: String = String()

  /// Updated configuration for the storedInfoType. If not provided, a new
  /// version of the storedInfoType will be created with the existing
  /// configuration.
  public var config: Google_Privacy_Dlp_V2_StoredInfoTypeConfig {
    get {return _config ?? Google_Privacy_Dlp_V2_StoredInfoTypeConfig()}
    set {_config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  public var hasConfig: Bool {return self._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  public mutating func clearConfig() {self._config = nil}

  /// Mask to control which fields get updated.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _config: Google_Privacy_Dlp_V2_StoredInfoTypeConfig? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Request message for GetStoredInfoType.
public struct Google_Privacy_Dlp_V2_GetStoredInfoTypeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Resource name of the organization and storedInfoType to be read, for
  /// example `organizations/433245324/storedInfoTypes/432452342` or
  /// projects/project-id/storedInfoTypes/432452342.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for ListStoredInfoTypes.
public struct Google_Privacy_Dlp_V2_ListStoredInfoTypesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Parent resource name.
  ///
  /// The format of this value varies depending on the scope of the request
  /// (project or organization) and whether you have [specified a processing
  /// location](https://cloud.google.com/dlp/docs/specifying-location):
  ///
  /// + Projects scope, location specified:<br/>
  ///   `projects/`<var>PROJECT_ID</var>`/locations/`<var>LOCATION_ID</var>
  /// + Projects scope, no location specified (defaults to global):<br/>
  ///   `projects/`<var>PROJECT_ID</var>
  /// + Organizations scope, location specified:<br/>
  ///   `organizations/`<var>ORG_ID</var>`/locations/`<var>LOCATION_ID</var>
  /// + Organizations scope, no location specified (defaults to global):<br/>
  ///   `organizations/`<var>ORG_ID</var>
  ///
  /// The following example `parent` string specifies a parent project with the
  /// identifier `example-project`, and specifies the `europe-west3` location
  /// for processing data:
  ///
  ///     parent=projects/example-project/locations/europe-west3
  public var parent: String = String()

  /// Page token to continue retrieval. Comes from previous call
  /// to `ListStoredInfoTypes`.
  public var pageToken: String = String()

  /// Size of the page, can be limited by server. If zero server returns
  /// a page of max size 100.
  public var pageSize: Int32 = 0

  /// Comma separated list of fields to order by,
  /// followed by `asc` or `desc` postfix. This list is case-insensitive,
  /// default sorting order is ascending, redundant space characters are
  /// insignificant.
  ///
  /// Example: `name asc, display_name, create_time desc`
  ///
  /// Supported fields are:
  ///
  /// - `create_time`: corresponds to time the most recent version of the
  /// resource was created.
  /// - `state`: corresponds to the state of the resource.
  /// - `name`: corresponds to resource name.
  /// - `display_name`: corresponds to info type's display name.
  public var orderBy: String = String()

  /// Deprecated. This field has no effect.
  public var locationID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response message for ListStoredInfoTypes.
public struct Google_Privacy_Dlp_V2_ListStoredInfoTypesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of storedInfoTypes, up to page_size in ListStoredInfoTypesRequest.
  public var storedInfoTypes: [Google_Privacy_Dlp_V2_StoredInfoType] = []

  /// If the next page is available then the next page token to be used
  /// in following ListStoredInfoTypes request.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for DeleteStoredInfoType.
public struct Google_Privacy_Dlp_V2_DeleteStoredInfoTypeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Resource name of the organization and storedInfoType to be deleted, for
  /// example `organizations/433245324/storedInfoTypes/432452342` or
  /// projects/project-id/storedInfoTypes/432452342.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to search for potentially sensitive info in a custom location.
public struct Google_Privacy_Dlp_V2_HybridInspectJobTriggerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Resource name of the trigger to execute a hybrid inspect on, for example
  /// `projects/dlp-test-project/jobTriggers/53234423`.
  public var name: String = String()

  /// The item to inspect.
  public var hybridItem: Google_Privacy_Dlp_V2_HybridContentItem {
    get {return _hybridItem ?? Google_Privacy_Dlp_V2_HybridContentItem()}
    set {_hybridItem = newValue}
  }
  /// Returns true if `hybridItem` has been explicitly set.
  public var hasHybridItem: Bool {return self._hybridItem != nil}
  /// Clears the value of `hybridItem`. Subsequent reads from it will return its default value.
  public mutating func clearHybridItem() {self._hybridItem = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _hybridItem: Google_Privacy_Dlp_V2_HybridContentItem? = nil
}

/// Request to search for potentially sensitive info in a custom location.
public struct Google_Privacy_Dlp_V2_HybridInspectDlpJobRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Resource name of the job to execute a hybrid inspect on, for example
  /// `projects/dlp-test-project/dlpJob/53234423`.
  public var name: String = String()

  /// The item to inspect.
  public var hybridItem: Google_Privacy_Dlp_V2_HybridContentItem {
    get {return _hybridItem ?? Google_Privacy_Dlp_V2_HybridContentItem()}
    set {_hybridItem = newValue}
  }
  /// Returns true if `hybridItem` has been explicitly set.
  public var hasHybridItem: Bool {return self._hybridItem != nil}
  /// Clears the value of `hybridItem`. Subsequent reads from it will return its default value.
  public mutating func clearHybridItem() {self._hybridItem = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _hybridItem: Google_Privacy_Dlp_V2_HybridContentItem? = nil
}

/// An individual hybrid item to inspect. Will be stored temporarily during
/// processing.
public struct Google_Privacy_Dlp_V2_HybridContentItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The item to inspect.
  public var item: Google_Privacy_Dlp_V2_ContentItem {
    get {return _item ?? Google_Privacy_Dlp_V2_ContentItem()}
    set {_item = newValue}
  }
  /// Returns true if `item` has been explicitly set.
  public var hasItem: Bool {return self._item != nil}
  /// Clears the value of `item`. Subsequent reads from it will return its default value.
  public mutating func clearItem() {self._item = nil}

  /// Supplementary information that will be added to each finding.
  public var findingDetails: Google_Privacy_Dlp_V2_HybridFindingDetails {
    get {return _findingDetails ?? Google_Privacy_Dlp_V2_HybridFindingDetails()}
    set {_findingDetails = newValue}
  }
  /// Returns true if `findingDetails` has been explicitly set.
  public var hasFindingDetails: Bool {return self._findingDetails != nil}
  /// Clears the value of `findingDetails`. Subsequent reads from it will return its default value.
  public mutating func clearFindingDetails() {self._findingDetails = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _item: Google_Privacy_Dlp_V2_ContentItem? = nil
  fileprivate var _findingDetails: Google_Privacy_Dlp_V2_HybridFindingDetails? = nil
}

/// Populate to associate additional data with each finding.
public struct Google_Privacy_Dlp_V2_HybridFindingDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Details about the container where the content being inspected is from.
  public var containerDetails: Google_Privacy_Dlp_V2_Container {
    get {return _containerDetails ?? Google_Privacy_Dlp_V2_Container()}
    set {_containerDetails = newValue}
  }
  /// Returns true if `containerDetails` has been explicitly set.
  public var hasContainerDetails: Bool {return self._containerDetails != nil}
  /// Clears the value of `containerDetails`. Subsequent reads from it will return its default value.
  public mutating func clearContainerDetails() {self._containerDetails = nil}

  /// Offset in bytes of the line, from the beginning of the file, where the
  /// finding  is located. Populate if the item being scanned is only part of a
  /// bigger item, such as a shard of a file and you want to track the absolute
  /// position of the finding.
  public var fileOffset: Int64 = 0

  /// Offset of the row for tables. Populate if the row(s) being scanned are
  /// part of a bigger dataset and you want to keep track of their absolute
  /// position.
  public var rowOffset: Int64 = 0

  /// If the container is a table, additional information to make findings
  /// meaningful such as the columns that are primary keys. If not known ahead
  /// of time, can also be set within each inspect hybrid call and the two
  /// will be merged. Note that identifying_fields will only be stored to
  /// BigQuery, and only if the BigQuery action has been included.
  public var tableOptions: Google_Privacy_Dlp_V2_TableOptions {
    get {return _tableOptions ?? Google_Privacy_Dlp_V2_TableOptions()}
    set {_tableOptions = newValue}
  }
  /// Returns true if `tableOptions` has been explicitly set.
  public var hasTableOptions: Bool {return self._tableOptions != nil}
  /// Clears the value of `tableOptions`. Subsequent reads from it will return its default value.
  public mutating func clearTableOptions() {self._tableOptions = nil}

  /// Labels to represent user provided metadata about the data being inspected.
  /// If configured by the job, some key values may be required.
  /// The labels associated with `Finding`'s produced by hybrid
  /// inspection.
  ///
  /// Label keys must be between 1 and 63 characters long and must conform
  /// to the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`.
  ///
  /// Label values must be between 0 and 63 characters long and must conform
  /// to the regular expression `([a-z]([-a-z0-9]*[a-z0-9])?)?`.
  ///
  /// No more than 10 labels can be associated with a given finding.
  ///
  /// Examples:
  /// * `"environment" : "production"`
  /// * `"pipeline" : "etl"`
  public var labels: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _containerDetails: Google_Privacy_Dlp_V2_Container? = nil
  fileprivate var _tableOptions: Google_Privacy_Dlp_V2_TableOptions? = nil
}

/// Quota exceeded errors will be thrown once quota has been met.
public struct Google_Privacy_Dlp_V2_HybridInspectResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.privacy.dlp.v2"

extension Google_Privacy_Dlp_V2_RelationalOperator: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RELATIONAL_OPERATOR_UNSPECIFIED"),
    1: .same(proto: "EQUAL_TO"),
    2: .same(proto: "NOT_EQUAL_TO"),
    3: .same(proto: "GREATER_THAN"),
    4: .same(proto: "LESS_THAN"),
    5: .same(proto: "GREATER_THAN_OR_EQUALS"),
    6: .same(proto: "LESS_THAN_OR_EQUALS"),
    7: .same(proto: "EXISTS"),
  ]
}

extension Google_Privacy_Dlp_V2_MatchingType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MATCHING_TYPE_UNSPECIFIED"),
    1: .same(proto: "MATCHING_TYPE_FULL_MATCH"),
    2: .same(proto: "MATCHING_TYPE_PARTIAL_MATCH"),
    3: .same(proto: "MATCHING_TYPE_INVERSE_MATCH"),
  ]
}

extension Google_Privacy_Dlp_V2_ContentOption: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONTENT_UNSPECIFIED"),
    1: .same(proto: "CONTENT_TEXT"),
    2: .same(proto: "CONTENT_IMAGE"),
  ]
}

extension Google_Privacy_Dlp_V2_MetadataType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "METADATATYPE_UNSPECIFIED"),
    2: .same(proto: "STORAGE_METADATA"),
  ]
}

extension Google_Privacy_Dlp_V2_InfoTypeSupportedBy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ENUM_TYPE_UNSPECIFIED"),
    1: .same(proto: "INSPECT"),
    2: .same(proto: "RISK_ANALYSIS"),
  ]
}

extension Google_Privacy_Dlp_V2_DlpJobType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DLP_JOB_TYPE_UNSPECIFIED"),
    1: .same(proto: "INSPECT_JOB"),
    2: .same(proto: "RISK_ANALYSIS_JOB"),
  ]
}

extension Google_Privacy_Dlp_V2_StoredInfoTypeState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STORED_INFO_TYPE_STATE_UNSPECIFIED"),
    1: .same(proto: "PENDING"),
    2: .same(proto: "READY"),
    3: .same(proto: "FAILED"),
    4: .same(proto: "INVALID"),
  ]
}

extension Google_Privacy_Dlp_V2_ExcludeInfoTypes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExcludeInfoTypes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "info_types"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.infoTypes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.infoTypes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.infoTypes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_ExcludeInfoTypes, rhs: Google_Privacy_Dlp_V2_ExcludeInfoTypes) -> Bool {
    if lhs.infoTypes != rhs.infoTypes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_ExclusionRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExclusionRule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dictionary"),
    2: .same(proto: "regex"),
    3: .standard(proto: "exclude_info_types"),
    4: .standard(proto: "matching_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Privacy_Dlp_V2_CustomInfoType.Dictionary?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .dictionary(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .dictionary(v)}
      }()
      case 2: try {
        var v: Google_Privacy_Dlp_V2_CustomInfoType.Regex?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .regex(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .regex(v)}
      }()
      case 3: try {
        var v: Google_Privacy_Dlp_V2_ExcludeInfoTypes?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .excludeInfoTypes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .excludeInfoTypes(v)}
      }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.matchingType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.type {
    case .dictionary?: try {
      guard case .dictionary(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .regex?: try {
      guard case .regex(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .excludeInfoTypes?: try {
      guard case .excludeInfoTypes(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if self.matchingType != .unspecified {
      try visitor.visitSingularEnumField(value: self.matchingType, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_ExclusionRule, rhs: Google_Privacy_Dlp_V2_ExclusionRule) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.matchingType != rhs.matchingType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_InspectionRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InspectionRule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "hotword_rule"),
    2: .standard(proto: "exclusion_rule"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Privacy_Dlp_V2_CustomInfoType.DetectionRule.HotwordRule?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .hotwordRule(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .hotwordRule(v)}
      }()
      case 2: try {
        var v: Google_Privacy_Dlp_V2_ExclusionRule?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .exclusionRule(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .exclusionRule(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.type {
    case .hotwordRule?: try {
      guard case .hotwordRule(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .exclusionRule?: try {
      guard case .exclusionRule(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_InspectionRule, rhs: Google_Privacy_Dlp_V2_InspectionRule) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_InspectionRuleSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InspectionRuleSet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "info_types"),
    2: .same(proto: "rules"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.infoTypes) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.rules) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.infoTypes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.infoTypes, fieldNumber: 1)
    }
    if !self.rules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rules, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_InspectionRuleSet, rhs: Google_Privacy_Dlp_V2_InspectionRuleSet) -> Bool {
    if lhs.infoTypes != rhs.infoTypes {return false}
    if lhs.rules != rhs.rules {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_InspectConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InspectConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "info_types"),
    2: .standard(proto: "min_likelihood"),
    3: .same(proto: "limits"),
    4: .standard(proto: "include_quote"),
    5: .standard(proto: "exclude_info_types"),
    6: .standard(proto: "custom_info_types"),
    8: .standard(proto: "content_options"),
    10: .standard(proto: "rule_set"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.infoTypes) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.minLikelihood) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._limits) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.includeQuote) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.excludeInfoTypes) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.customInfoTypes) }()
      case 8: try { try decoder.decodeRepeatedEnumField(value: &self.contentOptions) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.ruleSet) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.infoTypes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.infoTypes, fieldNumber: 1)
    }
    if self.minLikelihood != .unspecified {
      try visitor.visitSingularEnumField(value: self.minLikelihood, fieldNumber: 2)
    }
    if let v = self._limits {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.includeQuote != false {
      try visitor.visitSingularBoolField(value: self.includeQuote, fieldNumber: 4)
    }
    if self.excludeInfoTypes != false {
      try visitor.visitSingularBoolField(value: self.excludeInfoTypes, fieldNumber: 5)
    }
    if !self.customInfoTypes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.customInfoTypes, fieldNumber: 6)
    }
    if !self.contentOptions.isEmpty {
      try visitor.visitPackedEnumField(value: self.contentOptions, fieldNumber: 8)
    }
    if !self.ruleSet.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ruleSet, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_InspectConfig, rhs: Google_Privacy_Dlp_V2_InspectConfig) -> Bool {
    if lhs.infoTypes != rhs.infoTypes {return false}
    if lhs.minLikelihood != rhs.minLikelihood {return false}
    if lhs._limits != rhs._limits {return false}
    if lhs.includeQuote != rhs.includeQuote {return false}
    if lhs.excludeInfoTypes != rhs.excludeInfoTypes {return false}
    if lhs.customInfoTypes != rhs.customInfoTypes {return false}
    if lhs.contentOptions != rhs.contentOptions {return false}
    if lhs.ruleSet != rhs.ruleSet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_InspectConfig.FindingLimits: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_InspectConfig.protoMessageName + ".FindingLimits"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_findings_per_item"),
    2: .standard(proto: "max_findings_per_request"),
    3: .standard(proto: "max_findings_per_info_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.maxFindingsPerItem) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.maxFindingsPerRequest) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.maxFindingsPerInfoType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxFindingsPerItem != 0 {
      try visitor.visitSingularInt32Field(value: self.maxFindingsPerItem, fieldNumber: 1)
    }
    if self.maxFindingsPerRequest != 0 {
      try visitor.visitSingularInt32Field(value: self.maxFindingsPerRequest, fieldNumber: 2)
    }
    if !self.maxFindingsPerInfoType.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.maxFindingsPerInfoType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_InspectConfig.FindingLimits, rhs: Google_Privacy_Dlp_V2_InspectConfig.FindingLimits) -> Bool {
    if lhs.maxFindingsPerItem != rhs.maxFindingsPerItem {return false}
    if lhs.maxFindingsPerRequest != rhs.maxFindingsPerRequest {return false}
    if lhs.maxFindingsPerInfoType != rhs.maxFindingsPerInfoType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_InspectConfig.FindingLimits.InfoTypeLimit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_InspectConfig.FindingLimits.protoMessageName + ".InfoTypeLimit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "info_type"),
    2: .standard(proto: "max_findings"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._infoType) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.maxFindings) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._infoType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.maxFindings != 0 {
      try visitor.visitSingularInt32Field(value: self.maxFindings, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_InspectConfig.FindingLimits.InfoTypeLimit, rhs: Google_Privacy_Dlp_V2_InspectConfig.FindingLimits.InfoTypeLimit) -> Bool {
    if lhs._infoType != rhs._infoType {return false}
    if lhs.maxFindings != rhs.maxFindings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_ByteContentItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ByteContentItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_ByteContentItem, rhs: Google_Privacy_Dlp_V2_ByteContentItem) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_ByteContentItem.BytesType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BYTES_TYPE_UNSPECIFIED"),
    1: .same(proto: "IMAGE_JPEG"),
    2: .same(proto: "IMAGE_BMP"),
    3: .same(proto: "IMAGE_PNG"),
    4: .same(proto: "IMAGE_SVG"),
    5: .same(proto: "TEXT_UTF8"),
    6: .same(proto: "IMAGE"),
    7: .same(proto: "WORD_DOCUMENT"),
    8: .same(proto: "PDF"),
    11: .same(proto: "AVRO"),
    12: .same(proto: "CSV"),
    13: .same(proto: "TSV"),
  ]
}

extension Google_Privacy_Dlp_V2_ContentItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ContentItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "value"),
    4: .same(proto: "table"),
    5: .standard(proto: "byte_item"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try {
        if self.dataItem != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.dataItem = .value(v)}
      }()
      case 4: try {
        var v: Google_Privacy_Dlp_V2_Table?
        if let current = self.dataItem {
          try decoder.handleConflictingOneOf()
          if case .table(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.dataItem = .table(v)}
      }()
      case 5: try {
        var v: Google_Privacy_Dlp_V2_ByteContentItem?
        if let current = self.dataItem {
          try decoder.handleConflictingOneOf()
          if case .byteItem(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.dataItem = .byteItem(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.dataItem {
    case .value?: try {
      guard case .value(let v)? = self.dataItem else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case .table?: try {
      guard case .table(let v)? = self.dataItem else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .byteItem?: try {
      guard case .byteItem(let v)? = self.dataItem else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_ContentItem, rhs: Google_Privacy_Dlp_V2_ContentItem) -> Bool {
    if lhs.dataItem != rhs.dataItem {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_Table: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Table"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "headers"),
    2: .same(proto: "rows"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.headers) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.rows) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.headers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.headers, fieldNumber: 1)
    }
    if !self.rows.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rows, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_Table, rhs: Google_Privacy_Dlp_V2_Table) -> Bool {
    if lhs.headers != rhs.headers {return false}
    if lhs.rows != rhs.rows {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_Table.Row: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_Table.protoMessageName + ".Row"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.values) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.values, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_Table.Row, rhs: Google_Privacy_Dlp_V2_Table.Row) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_InspectResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InspectResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "findings"),
    2: .standard(proto: "findings_truncated"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.findings) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.findingsTruncated) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.findings.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.findings, fieldNumber: 1)
    }
    if self.findingsTruncated != false {
      try visitor.visitSingularBoolField(value: self.findingsTruncated, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_InspectResult, rhs: Google_Privacy_Dlp_V2_InspectResult) -> Bool {
    if lhs.findings != rhs.findings {return false}
    if lhs.findingsTruncated != rhs.findingsTruncated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_Finding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Finding"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    14: .same(proto: "name"),
    1: .same(proto: "quote"),
    2: .standard(proto: "info_type"),
    3: .same(proto: "likelihood"),
    4: .same(proto: "location"),
    6: .standard(proto: "create_time"),
    7: .standard(proto: "quote_info"),
    8: .standard(proto: "resource_name"),
    9: .standard(proto: "trigger_name"),
    10: .same(proto: "labels"),
    11: .standard(proto: "job_create_time"),
    13: .standard(proto: "job_name"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _quote: String = String()
    var _infoType: Google_Privacy_Dlp_V2_InfoType? = nil
    var _likelihood: Google_Privacy_Dlp_V2_Likelihood = .unspecified
    var _location: Google_Privacy_Dlp_V2_Location? = nil
    var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _quoteInfo: Google_Privacy_Dlp_V2_QuoteInfo? = nil
    var _resourceName: String = String()
    var _triggerName: String = String()
    var _labels: Dictionary<String,String> = [:]
    var _jobCreateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _jobName: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _quote = source._quote
      _infoType = source._infoType
      _likelihood = source._likelihood
      _location = source._location
      _createTime = source._createTime
      _quoteInfo = source._quoteInfo
      _resourceName = source._resourceName
      _triggerName = source._triggerName
      _labels = source._labels
      _jobCreateTime = source._jobCreateTime
      _jobName = source._jobName
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._quote) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._infoType) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._likelihood) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._location) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._createTime) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._quoteInfo) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._resourceName) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._triggerName) }()
        case 10: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._labels) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._jobCreateTime) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._jobName) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._quote.isEmpty {
        try visitor.visitSingularStringField(value: _storage._quote, fieldNumber: 1)
      }
      if let v = _storage._infoType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if _storage._likelihood != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._likelihood, fieldNumber: 3)
      }
      if let v = _storage._location {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._createTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._quoteInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if !_storage._resourceName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._resourceName, fieldNumber: 8)
      }
      if !_storage._triggerName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._triggerName, fieldNumber: 9)
      }
      if !_storage._labels.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._labels, fieldNumber: 10)
      }
      if let v = _storage._jobCreateTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if !_storage._jobName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._jobName, fieldNumber: 13)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 14)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_Finding, rhs: Google_Privacy_Dlp_V2_Finding) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._quote != rhs_storage._quote {return false}
        if _storage._infoType != rhs_storage._infoType {return false}
        if _storage._likelihood != rhs_storage._likelihood {return false}
        if _storage._location != rhs_storage._location {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._quoteInfo != rhs_storage._quoteInfo {return false}
        if _storage._resourceName != rhs_storage._resourceName {return false}
        if _storage._triggerName != rhs_storage._triggerName {return false}
        if _storage._labels != rhs_storage._labels {return false}
        if _storage._jobCreateTime != rhs_storage._jobCreateTime {return false}
        if _storage._jobName != rhs_storage._jobName {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_Location: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Location"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "byte_range"),
    2: .standard(proto: "codepoint_range"),
    7: .standard(proto: "content_locations"),
    8: .same(proto: "container"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._byteRange) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._codepointRange) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.contentLocations) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._container) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._byteRange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._codepointRange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.contentLocations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.contentLocations, fieldNumber: 7)
    }
    if let v = self._container {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_Location, rhs: Google_Privacy_Dlp_V2_Location) -> Bool {
    if lhs._byteRange != rhs._byteRange {return false}
    if lhs._codepointRange != rhs._codepointRange {return false}
    if lhs.contentLocations != rhs.contentLocations {return false}
    if lhs._container != rhs._container {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_ContentLocation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ContentLocation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "container_name"),
    2: .standard(proto: "record_location"),
    3: .standard(proto: "image_location"),
    5: .standard(proto: "document_location"),
    8: .standard(proto: "metadata_location"),
    6: .standard(proto: "container_timestamp"),
    7: .standard(proto: "container_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.containerName) }()
      case 2: try {
        var v: Google_Privacy_Dlp_V2_RecordLocation?
        if let current = self.location {
          try decoder.handleConflictingOneOf()
          if case .recordLocation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.location = .recordLocation(v)}
      }()
      case 3: try {
        var v: Google_Privacy_Dlp_V2_ImageLocation?
        if let current = self.location {
          try decoder.handleConflictingOneOf()
          if case .imageLocation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.location = .imageLocation(v)}
      }()
      case 5: try {
        var v: Google_Privacy_Dlp_V2_DocumentLocation?
        if let current = self.location {
          try decoder.handleConflictingOneOf()
          if case .documentLocation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.location = .documentLocation(v)}
      }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._containerTimestamp) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.containerVersion) }()
      case 8: try {
        var v: Google_Privacy_Dlp_V2_MetadataLocation?
        if let current = self.location {
          try decoder.handleConflictingOneOf()
          if case .metadataLocation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.location = .metadataLocation(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.containerName.isEmpty {
      try visitor.visitSingularStringField(value: self.containerName, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.location {
    case .recordLocation?: try {
      guard case .recordLocation(let v)? = self.location else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .imageLocation?: try {
      guard case .imageLocation(let v)? = self.location else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .documentLocation?: try {
      guard case .documentLocation(let v)? = self.location else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    default: break
    }
    if let v = self._containerTimestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if !self.containerVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.containerVersion, fieldNumber: 7)
    }
    if case .metadataLocation(let v)? = self.location {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_ContentLocation, rhs: Google_Privacy_Dlp_V2_ContentLocation) -> Bool {
    if lhs.containerName != rhs.containerName {return false}
    if lhs.location != rhs.location {return false}
    if lhs._containerTimestamp != rhs._containerTimestamp {return false}
    if lhs.containerVersion != rhs.containerVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_MetadataLocation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MetadataLocation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    3: .standard(proto: "storage_label"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try {
        var v: Google_Privacy_Dlp_V2_StorageMetadataLabel?
        if let current = self.label {
          try decoder.handleConflictingOneOf()
          if case .storageLabel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.label = .storageLabel(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if case .storageLabel(let v)? = self.label {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_MetadataLocation, rhs: Google_Privacy_Dlp_V2_MetadataLocation) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.label != rhs.label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_StorageMetadataLabel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StorageMetadataLabel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_StorageMetadataLabel, rhs: Google_Privacy_Dlp_V2_StorageMetadataLabel) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_DocumentLocation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DocumentLocation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "file_offset"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.fileOffset) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.fileOffset != 0 {
      try visitor.visitSingularInt64Field(value: self.fileOffset, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_DocumentLocation, rhs: Google_Privacy_Dlp_V2_DocumentLocation) -> Bool {
    if lhs.fileOffset != rhs.fileOffset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_RecordLocation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecordLocation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "record_key"),
    2: .standard(proto: "field_id"),
    3: .standard(proto: "table_location"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._recordKey) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._fieldID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._tableLocation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._recordKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._fieldID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._tableLocation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_RecordLocation, rhs: Google_Privacy_Dlp_V2_RecordLocation) -> Bool {
    if lhs._recordKey != rhs._recordKey {return false}
    if lhs._fieldID != rhs._fieldID {return false}
    if lhs._tableLocation != rhs._tableLocation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_TableLocation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TableLocation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "row_index"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.rowIndex) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rowIndex != 0 {
      try visitor.visitSingularInt64Field(value: self.rowIndex, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_TableLocation, rhs: Google_Privacy_Dlp_V2_TableLocation) -> Bool {
    if lhs.rowIndex != rhs.rowIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_Container: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Container"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "project_id"),
    3: .standard(proto: "full_path"),
    4: .standard(proto: "root_path"),
    5: .standard(proto: "relative_path"),
    6: .standard(proto: "update_time"),
    7: .same(proto: "version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.fullPath) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.rootPath) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.relativePath) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._updateTime) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.version) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 2)
    }
    if !self.fullPath.isEmpty {
      try visitor.visitSingularStringField(value: self.fullPath, fieldNumber: 3)
    }
    if !self.rootPath.isEmpty {
      try visitor.visitSingularStringField(value: self.rootPath, fieldNumber: 4)
    }
    if !self.relativePath.isEmpty {
      try visitor.visitSingularStringField(value: self.relativePath, fieldNumber: 5)
    }
    if let v = self._updateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_Container, rhs: Google_Privacy_Dlp_V2_Container) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.projectID != rhs.projectID {return false}
    if lhs.fullPath != rhs.fullPath {return false}
    if lhs.rootPath != rhs.rootPath {return false}
    if lhs.relativePath != rhs.relativePath {return false}
    if lhs._updateTime != rhs._updateTime {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_Range: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Range"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "end"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.start) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.end) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.start != 0 {
      try visitor.visitSingularInt64Field(value: self.start, fieldNumber: 1)
    }
    if self.end != 0 {
      try visitor.visitSingularInt64Field(value: self.end, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_Range, rhs: Google_Privacy_Dlp_V2_Range) -> Bool {
    if lhs.start != rhs.start {return false}
    if lhs.end != rhs.end {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_ImageLocation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ImageLocation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bounding_boxes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.boundingBoxes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.boundingBoxes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.boundingBoxes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_ImageLocation, rhs: Google_Privacy_Dlp_V2_ImageLocation) -> Bool {
    if lhs.boundingBoxes != rhs.boundingBoxes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_BoundingBox: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BoundingBox"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "top"),
    2: .same(proto: "left"),
    3: .same(proto: "width"),
    4: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.top) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.left) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.width) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.height) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.top != 0 {
      try visitor.visitSingularInt32Field(value: self.top, fieldNumber: 1)
    }
    if self.left != 0 {
      try visitor.visitSingularInt32Field(value: self.left, fieldNumber: 2)
    }
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 3)
    }
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_BoundingBox, rhs: Google_Privacy_Dlp_V2_BoundingBox) -> Bool {
    if lhs.top != rhs.top {return false}
    if lhs.left != rhs.left {return false}
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_RedactImageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RedactImageRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    8: .standard(proto: "location_id"),
    2: .standard(proto: "inspect_config"),
    5: .standard(proto: "image_redaction_configs"),
    6: .standard(proto: "include_findings"),
    7: .standard(proto: "byte_item"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._inspectConfig) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.imageRedactionConfigs) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.includeFindings) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._byteItem) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.locationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if let v = self._inspectConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.imageRedactionConfigs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.imageRedactionConfigs, fieldNumber: 5)
    }
    if self.includeFindings != false {
      try visitor.visitSingularBoolField(value: self.includeFindings, fieldNumber: 6)
    }
    if let v = self._byteItem {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if !self.locationID.isEmpty {
      try visitor.visitSingularStringField(value: self.locationID, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_RedactImageRequest, rhs: Google_Privacy_Dlp_V2_RedactImageRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.locationID != rhs.locationID {return false}
    if lhs._inspectConfig != rhs._inspectConfig {return false}
    if lhs.imageRedactionConfigs != rhs.imageRedactionConfigs {return false}
    if lhs.includeFindings != rhs.includeFindings {return false}
    if lhs._byteItem != rhs._byteItem {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_RedactImageRequest.ImageRedactionConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_RedactImageRequest.protoMessageName + ".ImageRedactionConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "info_type"),
    2: .standard(proto: "redact_all_text"),
    3: .standard(proto: "redaction_color"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Privacy_Dlp_V2_InfoType?
        if let current = self.target {
          try decoder.handleConflictingOneOf()
          if case .infoType(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.target = .infoType(v)}
      }()
      case 2: try {
        if self.target != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.target = .redactAllText(v)}
      }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._redactionColor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.target {
    case .infoType?: try {
      guard case .infoType(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .redactAllText?: try {
      guard case .redactAllText(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if let v = self._redactionColor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_RedactImageRequest.ImageRedactionConfig, rhs: Google_Privacy_Dlp_V2_RedactImageRequest.ImageRedactionConfig) -> Bool {
    if lhs.target != rhs.target {return false}
    if lhs._redactionColor != rhs._redactionColor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_Color: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Color"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "red"),
    2: .same(proto: "green"),
    3: .same(proto: "blue"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.red) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.green) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.blue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.red != 0 {
      try visitor.visitSingularFloatField(value: self.red, fieldNumber: 1)
    }
    if self.green != 0 {
      try visitor.visitSingularFloatField(value: self.green, fieldNumber: 2)
    }
    if self.blue != 0 {
      try visitor.visitSingularFloatField(value: self.blue, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_Color, rhs: Google_Privacy_Dlp_V2_Color) -> Bool {
    if lhs.red != rhs.red {return false}
    if lhs.green != rhs.green {return false}
    if lhs.blue != rhs.blue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_RedactImageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RedactImageResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "redacted_image"),
    2: .standard(proto: "extracted_text"),
    3: .standard(proto: "inspect_result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.redactedImage) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.extractedText) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._inspectResult) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.redactedImage.isEmpty {
      try visitor.visitSingularBytesField(value: self.redactedImage, fieldNumber: 1)
    }
    if !self.extractedText.isEmpty {
      try visitor.visitSingularStringField(value: self.extractedText, fieldNumber: 2)
    }
    if let v = self._inspectResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_RedactImageResponse, rhs: Google_Privacy_Dlp_V2_RedactImageResponse) -> Bool {
    if lhs.redactedImage != rhs.redactedImage {return false}
    if lhs.extractedText != rhs.extractedText {return false}
    if lhs._inspectResult != rhs._inspectResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_DeidentifyContentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeidentifyContentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "deidentify_config"),
    3: .standard(proto: "inspect_config"),
    4: .same(proto: "item"),
    5: .standard(proto: "inspect_template_name"),
    6: .standard(proto: "deidentify_template_name"),
    7: .standard(proto: "location_id"),
  ]

  fileprivate class _StorageClass {
    var _parent: String = String()
    var _deidentifyConfig: Google_Privacy_Dlp_V2_DeidentifyConfig? = nil
    var _inspectConfig: Google_Privacy_Dlp_V2_InspectConfig? = nil
    var _item: Google_Privacy_Dlp_V2_ContentItem? = nil
    var _inspectTemplateName: String = String()
    var _deidentifyTemplateName: String = String()
    var _locationID: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _parent = source._parent
      _deidentifyConfig = source._deidentifyConfig
      _inspectConfig = source._inspectConfig
      _item = source._item
      _inspectTemplateName = source._inspectTemplateName
      _deidentifyTemplateName = source._deidentifyTemplateName
      _locationID = source._locationID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._parent) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._deidentifyConfig) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._inspectConfig) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._item) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._inspectTemplateName) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._deidentifyTemplateName) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._locationID) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._parent.isEmpty {
        try visitor.visitSingularStringField(value: _storage._parent, fieldNumber: 1)
      }
      if let v = _storage._deidentifyConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._inspectConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._item {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._inspectTemplateName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._inspectTemplateName, fieldNumber: 5)
      }
      if !_storage._deidentifyTemplateName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._deidentifyTemplateName, fieldNumber: 6)
      }
      if !_storage._locationID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._locationID, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_DeidentifyContentRequest, rhs: Google_Privacy_Dlp_V2_DeidentifyContentRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._parent != rhs_storage._parent {return false}
        if _storage._deidentifyConfig != rhs_storage._deidentifyConfig {return false}
        if _storage._inspectConfig != rhs_storage._inspectConfig {return false}
        if _storage._item != rhs_storage._item {return false}
        if _storage._inspectTemplateName != rhs_storage._inspectTemplateName {return false}
        if _storage._deidentifyTemplateName != rhs_storage._deidentifyTemplateName {return false}
        if _storage._locationID != rhs_storage._locationID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_DeidentifyContentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeidentifyContentResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "item"),
    2: .same(proto: "overview"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._item) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._overview) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._item {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._overview {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_DeidentifyContentResponse, rhs: Google_Privacy_Dlp_V2_DeidentifyContentResponse) -> Bool {
    if lhs._item != rhs._item {return false}
    if lhs._overview != rhs._overview {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_ReidentifyContentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReidentifyContentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "reidentify_config"),
    3: .standard(proto: "inspect_config"),
    4: .same(proto: "item"),
    5: .standard(proto: "inspect_template_name"),
    6: .standard(proto: "reidentify_template_name"),
    7: .standard(proto: "location_id"),
  ]

  fileprivate class _StorageClass {
    var _parent: String = String()
    var _reidentifyConfig: Google_Privacy_Dlp_V2_DeidentifyConfig? = nil
    var _inspectConfig: Google_Privacy_Dlp_V2_InspectConfig? = nil
    var _item: Google_Privacy_Dlp_V2_ContentItem? = nil
    var _inspectTemplateName: String = String()
    var _reidentifyTemplateName: String = String()
    var _locationID: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _parent = source._parent
      _reidentifyConfig = source._reidentifyConfig
      _inspectConfig = source._inspectConfig
      _item = source._item
      _inspectTemplateName = source._inspectTemplateName
      _reidentifyTemplateName = source._reidentifyTemplateName
      _locationID = source._locationID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._parent) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._reidentifyConfig) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._inspectConfig) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._item) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._inspectTemplateName) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._reidentifyTemplateName) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._locationID) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._parent.isEmpty {
        try visitor.visitSingularStringField(value: _storage._parent, fieldNumber: 1)
      }
      if let v = _storage._reidentifyConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._inspectConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._item {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._inspectTemplateName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._inspectTemplateName, fieldNumber: 5)
      }
      if !_storage._reidentifyTemplateName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._reidentifyTemplateName, fieldNumber: 6)
      }
      if !_storage._locationID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._locationID, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_ReidentifyContentRequest, rhs: Google_Privacy_Dlp_V2_ReidentifyContentRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._parent != rhs_storage._parent {return false}
        if _storage._reidentifyConfig != rhs_storage._reidentifyConfig {return false}
        if _storage._inspectConfig != rhs_storage._inspectConfig {return false}
        if _storage._item != rhs_storage._item {return false}
        if _storage._inspectTemplateName != rhs_storage._inspectTemplateName {return false}
        if _storage._reidentifyTemplateName != rhs_storage._reidentifyTemplateName {return false}
        if _storage._locationID != rhs_storage._locationID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_ReidentifyContentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReidentifyContentResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "item"),
    2: .same(proto: "overview"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._item) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._overview) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._item {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._overview {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_ReidentifyContentResponse, rhs: Google_Privacy_Dlp_V2_ReidentifyContentResponse) -> Bool {
    if lhs._item != rhs._item {return false}
    if lhs._overview != rhs._overview {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_InspectContentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InspectContentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "inspect_config"),
    3: .same(proto: "item"),
    4: .standard(proto: "inspect_template_name"),
    5: .standard(proto: "location_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._inspectConfig) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._item) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.inspectTemplateName) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.locationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if let v = self._inspectConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._item {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.inspectTemplateName.isEmpty {
      try visitor.visitSingularStringField(value: self.inspectTemplateName, fieldNumber: 4)
    }
    if !self.locationID.isEmpty {
      try visitor.visitSingularStringField(value: self.locationID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_InspectContentRequest, rhs: Google_Privacy_Dlp_V2_InspectContentRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs._inspectConfig != rhs._inspectConfig {return false}
    if lhs._item != rhs._item {return false}
    if lhs.inspectTemplateName != rhs.inspectTemplateName {return false}
    if lhs.locationID != rhs.locationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_InspectContentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InspectContentResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_InspectContentResponse, rhs: Google_Privacy_Dlp_V2_InspectContentResponse) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_OutputStorageConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OutputStorageConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "table"),
    3: .standard(proto: "output_schema"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Privacy_Dlp_V2_BigQueryTable?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .table(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .table(v)}
      }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.outputSchema) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .table(let v)? = self.type {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.outputSchema != .unspecified {
      try visitor.visitSingularEnumField(value: self.outputSchema, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_OutputStorageConfig, rhs: Google_Privacy_Dlp_V2_OutputStorageConfig) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.outputSchema != rhs.outputSchema {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_OutputStorageConfig.OutputSchema: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OUTPUT_SCHEMA_UNSPECIFIED"),
    1: .same(proto: "BASIC_COLUMNS"),
    2: .same(proto: "GCS_COLUMNS"),
    3: .same(proto: "DATASTORE_COLUMNS"),
    4: .same(proto: "BIG_QUERY_COLUMNS"),
    5: .same(proto: "ALL_COLUMNS"),
  ]
}

extension Google_Privacy_Dlp_V2_InfoTypeStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InfoTypeStats"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "info_type"),
    2: .same(proto: "count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._infoType) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.count) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._infoType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.count != 0 {
      try visitor.visitSingularInt64Field(value: self.count, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_InfoTypeStats, rhs: Google_Privacy_Dlp_V2_InfoTypeStats) -> Bool {
    if lhs._infoType != rhs._infoType {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_InspectDataSourceDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InspectDataSourceDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "requested_options"),
    3: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._requestedOptions) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._requestedOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_InspectDataSourceDetails, rhs: Google_Privacy_Dlp_V2_InspectDataSourceDetails) -> Bool {
    if lhs._requestedOptions != rhs._requestedOptions {return false}
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_InspectDataSourceDetails.RequestedOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_InspectDataSourceDetails.protoMessageName + ".RequestedOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "snapshot_inspect_template"),
    3: .standard(proto: "job_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._snapshotInspectTemplate) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._jobConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._snapshotInspectTemplate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._jobConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_InspectDataSourceDetails.RequestedOptions, rhs: Google_Privacy_Dlp_V2_InspectDataSourceDetails.RequestedOptions) -> Bool {
    if lhs._snapshotInspectTemplate != rhs._snapshotInspectTemplate {return false}
    if lhs._jobConfig != rhs._jobConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_InspectDataSourceDetails.Result: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_InspectDataSourceDetails.protoMessageName + ".Result"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "processed_bytes"),
    2: .standard(proto: "total_estimated_bytes"),
    3: .standard(proto: "info_type_stats"),
    7: .standard(proto: "hybrid_stats"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.processedBytes) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.totalEstimatedBytes) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.infoTypeStats) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._hybridStats) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.processedBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.processedBytes, fieldNumber: 1)
    }
    if self.totalEstimatedBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.totalEstimatedBytes, fieldNumber: 2)
    }
    if !self.infoTypeStats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.infoTypeStats, fieldNumber: 3)
    }
    if let v = self._hybridStats {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_InspectDataSourceDetails.Result, rhs: Google_Privacy_Dlp_V2_InspectDataSourceDetails.Result) -> Bool {
    if lhs.processedBytes != rhs.processedBytes {return false}
    if lhs.totalEstimatedBytes != rhs.totalEstimatedBytes {return false}
    if lhs.infoTypeStats != rhs.infoTypeStats {return false}
    if lhs._hybridStats != rhs._hybridStats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_HybridInspectStatistics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HybridInspectStatistics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "processed_count"),
    2: .standard(proto: "aborted_count"),
    3: .standard(proto: "pending_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.processedCount) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.abortedCount) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.pendingCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.processedCount != 0 {
      try visitor.visitSingularInt64Field(value: self.processedCount, fieldNumber: 1)
    }
    if self.abortedCount != 0 {
      try visitor.visitSingularInt64Field(value: self.abortedCount, fieldNumber: 2)
    }
    if self.pendingCount != 0 {
      try visitor.visitSingularInt64Field(value: self.pendingCount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_HybridInspectStatistics, rhs: Google_Privacy_Dlp_V2_HybridInspectStatistics) -> Bool {
    if lhs.processedCount != rhs.processedCount {return false}
    if lhs.abortedCount != rhs.abortedCount {return false}
    if lhs.pendingCount != rhs.pendingCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_InfoTypeDescription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InfoTypeDescription"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "display_name"),
    3: .standard(proto: "supported_by"),
    4: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 3: try { try decoder.decodeRepeatedEnumField(value: &self.supportedBy) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 2)
    }
    if !self.supportedBy.isEmpty {
      try visitor.visitPackedEnumField(value: self.supportedBy, fieldNumber: 3)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_InfoTypeDescription, rhs: Google_Privacy_Dlp_V2_InfoTypeDescription) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.supportedBy != rhs.supportedBy {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_ListInfoTypesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListInfoTypesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .same(proto: "parent"),
    1: .standard(proto: "language_code"),
    2: .same(proto: "filter"),
    3: .standard(proto: "location_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.languageCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.locationID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.languageCode.isEmpty {
      try visitor.visitSingularStringField(value: self.languageCode, fieldNumber: 1)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 2)
    }
    if !self.locationID.isEmpty {
      try visitor.visitSingularStringField(value: self.locationID, fieldNumber: 3)
    }
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_ListInfoTypesRequest, rhs: Google_Privacy_Dlp_V2_ListInfoTypesRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.languageCode != rhs.languageCode {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.locationID != rhs.locationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_ListInfoTypesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListInfoTypesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "info_types"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.infoTypes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.infoTypes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.infoTypes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_ListInfoTypesResponse, rhs: Google_Privacy_Dlp_V2_ListInfoTypesResponse) -> Bool {
    if lhs.infoTypes != rhs.infoTypes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_RiskAnalysisJobConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RiskAnalysisJobConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "privacy_metric"),
    2: .standard(proto: "source_table"),
    3: .same(proto: "actions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._privacyMetric) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._sourceTable) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.actions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._privacyMetric {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._sourceTable {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.actions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.actions, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_RiskAnalysisJobConfig, rhs: Google_Privacy_Dlp_V2_RiskAnalysisJobConfig) -> Bool {
    if lhs._privacyMetric != rhs._privacyMetric {return false}
    if lhs._sourceTable != rhs._sourceTable {return false}
    if lhs.actions != rhs.actions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_QuasiId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QuasiId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "field"),
    2: .standard(proto: "info_type"),
    3: .standard(proto: "custom_tag"),
    4: .same(proto: "inferred"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._field) }()
      case 2: try {
        var v: Google_Privacy_Dlp_V2_InfoType?
        if let current = self.tag {
          try decoder.handleConflictingOneOf()
          if case .infoType(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.tag = .infoType(v)}
      }()
      case 3: try {
        if self.tag != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.tag = .customTag(v)}
      }()
      case 4: try {
        var v: SwiftProtobuf.Google_Protobuf_Empty?
        if let current = self.tag {
          try decoder.handleConflictingOneOf()
          if case .inferred(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.tag = .inferred(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._field {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.tag {
    case .infoType?: try {
      guard case .infoType(let v)? = self.tag else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .customTag?: try {
      guard case .customTag(let v)? = self.tag else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case .inferred?: try {
      guard case .inferred(let v)? = self.tag else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_QuasiId, rhs: Google_Privacy_Dlp_V2_QuasiId) -> Bool {
    if lhs._field != rhs._field {return false}
    if lhs.tag != rhs.tag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_StatisticalTable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StatisticalTable"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "table"),
    1: .standard(proto: "quasi_ids"),
    2: .standard(proto: "relative_frequency"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.quasiIds) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._relativeFrequency) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._table) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.quasiIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.quasiIds, fieldNumber: 1)
    }
    if let v = self._relativeFrequency {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._table {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_StatisticalTable, rhs: Google_Privacy_Dlp_V2_StatisticalTable) -> Bool {
    if lhs._table != rhs._table {return false}
    if lhs.quasiIds != rhs.quasiIds {return false}
    if lhs._relativeFrequency != rhs._relativeFrequency {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_StatisticalTable.QuasiIdentifierField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_StatisticalTable.protoMessageName + ".QuasiIdentifierField"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "field"),
    2: .standard(proto: "custom_tag"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._field) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.customTag) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._field {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.customTag.isEmpty {
      try visitor.visitSingularStringField(value: self.customTag, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_StatisticalTable.QuasiIdentifierField, rhs: Google_Privacy_Dlp_V2_StatisticalTable.QuasiIdentifierField) -> Bool {
    if lhs._field != rhs._field {return false}
    if lhs.customTag != rhs.customTag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_PrivacyMetric: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PrivacyMetric"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "numerical_stats_config"),
    2: .standard(proto: "categorical_stats_config"),
    3: .standard(proto: "k_anonymity_config"),
    4: .standard(proto: "l_diversity_config"),
    5: .standard(proto: "k_map_estimation_config"),
    6: .standard(proto: "delta_presence_estimation_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Privacy_Dlp_V2_PrivacyMetric.NumericalStatsConfig?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .numericalStatsConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .numericalStatsConfig(v)}
      }()
      case 2: try {
        var v: Google_Privacy_Dlp_V2_PrivacyMetric.CategoricalStatsConfig?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .categoricalStatsConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .categoricalStatsConfig(v)}
      }()
      case 3: try {
        var v: Google_Privacy_Dlp_V2_PrivacyMetric.KAnonymityConfig?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .kAnonymityConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .kAnonymityConfig(v)}
      }()
      case 4: try {
        var v: Google_Privacy_Dlp_V2_PrivacyMetric.LDiversityConfig?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .lDiversityConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .lDiversityConfig(v)}
      }()
      case 5: try {
        var v: Google_Privacy_Dlp_V2_PrivacyMetric.KMapEstimationConfig?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .kMapEstimationConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .kMapEstimationConfig(v)}
      }()
      case 6: try {
        var v: Google_Privacy_Dlp_V2_PrivacyMetric.DeltaPresenceEstimationConfig?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .deltaPresenceEstimationConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .deltaPresenceEstimationConfig(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.type {
    case .numericalStatsConfig?: try {
      guard case .numericalStatsConfig(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .categoricalStatsConfig?: try {
      guard case .categoricalStatsConfig(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .kAnonymityConfig?: try {
      guard case .kAnonymityConfig(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .lDiversityConfig?: try {
      guard case .lDiversityConfig(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .kMapEstimationConfig?: try {
      guard case .kMapEstimationConfig(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .deltaPresenceEstimationConfig?: try {
      guard case .deltaPresenceEstimationConfig(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_PrivacyMetric, rhs: Google_Privacy_Dlp_V2_PrivacyMetric) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_PrivacyMetric.NumericalStatsConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_PrivacyMetric.protoMessageName + ".NumericalStatsConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "field"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._field) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._field {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_PrivacyMetric.NumericalStatsConfig, rhs: Google_Privacy_Dlp_V2_PrivacyMetric.NumericalStatsConfig) -> Bool {
    if lhs._field != rhs._field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_PrivacyMetric.CategoricalStatsConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_PrivacyMetric.protoMessageName + ".CategoricalStatsConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "field"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._field) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._field {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_PrivacyMetric.CategoricalStatsConfig, rhs: Google_Privacy_Dlp_V2_PrivacyMetric.CategoricalStatsConfig) -> Bool {
    if lhs._field != rhs._field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_PrivacyMetric.KAnonymityConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_PrivacyMetric.protoMessageName + ".KAnonymityConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "quasi_ids"),
    2: .standard(proto: "entity_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.quasiIds) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._entityID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.quasiIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.quasiIds, fieldNumber: 1)
    }
    if let v = self._entityID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_PrivacyMetric.KAnonymityConfig, rhs: Google_Privacy_Dlp_V2_PrivacyMetric.KAnonymityConfig) -> Bool {
    if lhs.quasiIds != rhs.quasiIds {return false}
    if lhs._entityID != rhs._entityID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_PrivacyMetric.LDiversityConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_PrivacyMetric.protoMessageName + ".LDiversityConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "quasi_ids"),
    2: .standard(proto: "sensitive_attribute"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.quasiIds) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._sensitiveAttribute) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.quasiIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.quasiIds, fieldNumber: 1)
    }
    if let v = self._sensitiveAttribute {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_PrivacyMetric.LDiversityConfig, rhs: Google_Privacy_Dlp_V2_PrivacyMetric.LDiversityConfig) -> Bool {
    if lhs.quasiIds != rhs.quasiIds {return false}
    if lhs._sensitiveAttribute != rhs._sensitiveAttribute {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_PrivacyMetric.KMapEstimationConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_PrivacyMetric.protoMessageName + ".KMapEstimationConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "quasi_ids"),
    2: .standard(proto: "region_code"),
    3: .standard(proto: "auxiliary_tables"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.quasiIds) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.regionCode) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.auxiliaryTables) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.quasiIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.quasiIds, fieldNumber: 1)
    }
    if !self.regionCode.isEmpty {
      try visitor.visitSingularStringField(value: self.regionCode, fieldNumber: 2)
    }
    if !self.auxiliaryTables.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.auxiliaryTables, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_PrivacyMetric.KMapEstimationConfig, rhs: Google_Privacy_Dlp_V2_PrivacyMetric.KMapEstimationConfig) -> Bool {
    if lhs.quasiIds != rhs.quasiIds {return false}
    if lhs.regionCode != rhs.regionCode {return false}
    if lhs.auxiliaryTables != rhs.auxiliaryTables {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_PrivacyMetric.KMapEstimationConfig.TaggedField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_PrivacyMetric.KMapEstimationConfig.protoMessageName + ".TaggedField"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "field"),
    2: .standard(proto: "info_type"),
    3: .standard(proto: "custom_tag"),
    4: .same(proto: "inferred"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._field) }()
      case 2: try {
        var v: Google_Privacy_Dlp_V2_InfoType?
        if let current = self.tag {
          try decoder.handleConflictingOneOf()
          if case .infoType(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.tag = .infoType(v)}
      }()
      case 3: try {
        if self.tag != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.tag = .customTag(v)}
      }()
      case 4: try {
        var v: SwiftProtobuf.Google_Protobuf_Empty?
        if let current = self.tag {
          try decoder.handleConflictingOneOf()
          if case .inferred(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.tag = .inferred(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._field {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.tag {
    case .infoType?: try {
      guard case .infoType(let v)? = self.tag else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .customTag?: try {
      guard case .customTag(let v)? = self.tag else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case .inferred?: try {
      guard case .inferred(let v)? = self.tag else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_PrivacyMetric.KMapEstimationConfig.TaggedField, rhs: Google_Privacy_Dlp_V2_PrivacyMetric.KMapEstimationConfig.TaggedField) -> Bool {
    if lhs._field != rhs._field {return false}
    if lhs.tag != rhs.tag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_PrivacyMetric.KMapEstimationConfig.AuxiliaryTable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_PrivacyMetric.KMapEstimationConfig.protoMessageName + ".AuxiliaryTable"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "table"),
    1: .standard(proto: "quasi_ids"),
    2: .standard(proto: "relative_frequency"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.quasiIds) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._relativeFrequency) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._table) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.quasiIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.quasiIds, fieldNumber: 1)
    }
    if let v = self._relativeFrequency {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._table {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_PrivacyMetric.KMapEstimationConfig.AuxiliaryTable, rhs: Google_Privacy_Dlp_V2_PrivacyMetric.KMapEstimationConfig.AuxiliaryTable) -> Bool {
    if lhs._table != rhs._table {return false}
    if lhs.quasiIds != rhs.quasiIds {return false}
    if lhs._relativeFrequency != rhs._relativeFrequency {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_PrivacyMetric.KMapEstimationConfig.AuxiliaryTable.QuasiIdField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_PrivacyMetric.KMapEstimationConfig.AuxiliaryTable.protoMessageName + ".QuasiIdField"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "field"),
    2: .standard(proto: "custom_tag"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._field) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.customTag) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._field {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.customTag.isEmpty {
      try visitor.visitSingularStringField(value: self.customTag, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_PrivacyMetric.KMapEstimationConfig.AuxiliaryTable.QuasiIdField, rhs: Google_Privacy_Dlp_V2_PrivacyMetric.KMapEstimationConfig.AuxiliaryTable.QuasiIdField) -> Bool {
    if lhs._field != rhs._field {return false}
    if lhs.customTag != rhs.customTag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_PrivacyMetric.DeltaPresenceEstimationConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_PrivacyMetric.protoMessageName + ".DeltaPresenceEstimationConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "quasi_ids"),
    2: .standard(proto: "region_code"),
    3: .standard(proto: "auxiliary_tables"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.quasiIds) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.regionCode) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.auxiliaryTables) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.quasiIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.quasiIds, fieldNumber: 1)
    }
    if !self.regionCode.isEmpty {
      try visitor.visitSingularStringField(value: self.regionCode, fieldNumber: 2)
    }
    if !self.auxiliaryTables.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.auxiliaryTables, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_PrivacyMetric.DeltaPresenceEstimationConfig, rhs: Google_Privacy_Dlp_V2_PrivacyMetric.DeltaPresenceEstimationConfig) -> Bool {
    if lhs.quasiIds != rhs.quasiIds {return false}
    if lhs.regionCode != rhs.regionCode {return false}
    if lhs.auxiliaryTables != rhs.auxiliaryTables {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AnalyzeDataSourceRiskDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "requested_privacy_metric"),
    2: .standard(proto: "requested_source_table"),
    3: .standard(proto: "numerical_stats_result"),
    4: .standard(proto: "categorical_stats_result"),
    5: .standard(proto: "k_anonymity_result"),
    6: .standard(proto: "l_diversity_result"),
    7: .standard(proto: "k_map_estimation_result"),
    9: .standard(proto: "delta_presence_estimation_result"),
    10: .standard(proto: "requested_options"),
  ]

  fileprivate class _StorageClass {
    var _requestedPrivacyMetric: Google_Privacy_Dlp_V2_PrivacyMetric? = nil
    var _requestedSourceTable: Google_Privacy_Dlp_V2_BigQueryTable? = nil
    var _result: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.OneOf_Result?
    var _requestedOptions: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.RequestedRiskAnalysisOptions? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _requestedPrivacyMetric = source._requestedPrivacyMetric
      _requestedSourceTable = source._requestedSourceTable
      _result = source._result
      _requestedOptions = source._requestedOptions
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._requestedPrivacyMetric) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._requestedSourceTable) }()
        case 3: try {
          var v: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.NumericalStatsResult?
          if let current = _storage._result {
            try decoder.handleConflictingOneOf()
            if case .numericalStatsResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._result = .numericalStatsResult(v)}
        }()
        case 4: try {
          var v: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.CategoricalStatsResult?
          if let current = _storage._result {
            try decoder.handleConflictingOneOf()
            if case .categoricalStatsResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._result = .categoricalStatsResult(v)}
        }()
        case 5: try {
          var v: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.KAnonymityResult?
          if let current = _storage._result {
            try decoder.handleConflictingOneOf()
            if case .kAnonymityResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._result = .kAnonymityResult(v)}
        }()
        case 6: try {
          var v: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.LDiversityResult?
          if let current = _storage._result {
            try decoder.handleConflictingOneOf()
            if case .lDiversityResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._result = .lDiversityResult(v)}
        }()
        case 7: try {
          var v: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.KMapEstimationResult?
          if let current = _storage._result {
            try decoder.handleConflictingOneOf()
            if case .kMapEstimationResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._result = .kMapEstimationResult(v)}
        }()
        case 9: try {
          var v: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.DeltaPresenceEstimationResult?
          if let current = _storage._result {
            try decoder.handleConflictingOneOf()
            if case .deltaPresenceEstimationResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._result = .deltaPresenceEstimationResult(v)}
        }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._requestedOptions) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._requestedPrivacyMetric {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._requestedSourceTable {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._result {
      case .numericalStatsResult?: try {
        guard case .numericalStatsResult(let v)? = _storage._result else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case .categoricalStatsResult?: try {
        guard case .categoricalStatsResult(let v)? = _storage._result else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .kAnonymityResult?: try {
        guard case .kAnonymityResult(let v)? = _storage._result else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .lDiversityResult?: try {
        guard case .lDiversityResult(let v)? = _storage._result else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .kMapEstimationResult?: try {
        guard case .kMapEstimationResult(let v)? = _storage._result else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .deltaPresenceEstimationResult?: try {
        guard case .deltaPresenceEstimationResult(let v)? = _storage._result else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case nil: break
      }
      if let v = _storage._requestedOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails, rhs: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._requestedPrivacyMetric != rhs_storage._requestedPrivacyMetric {return false}
        if _storage._requestedSourceTable != rhs_storage._requestedSourceTable {return false}
        if _storage._result != rhs_storage._result {return false}
        if _storage._requestedOptions != rhs_storage._requestedOptions {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.NumericalStatsResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.protoMessageName + ".NumericalStatsResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "min_value"),
    2: .standard(proto: "max_value"),
    4: .standard(proto: "quantile_values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._minValue) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._maxValue) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.quantileValues) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._minValue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._maxValue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.quantileValues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.quantileValues, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.NumericalStatsResult, rhs: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.NumericalStatsResult) -> Bool {
    if lhs._minValue != rhs._minValue {return false}
    if lhs._maxValue != rhs._maxValue {return false}
    if lhs.quantileValues != rhs.quantileValues {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.CategoricalStatsResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.protoMessageName + ".CategoricalStatsResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .standard(proto: "value_frequency_histogram_buckets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.valueFrequencyHistogramBuckets) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.valueFrequencyHistogramBuckets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.valueFrequencyHistogramBuckets, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.CategoricalStatsResult, rhs: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.CategoricalStatsResult) -> Bool {
    if lhs.valueFrequencyHistogramBuckets != rhs.valueFrequencyHistogramBuckets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.CategoricalStatsResult.CategoricalStatsHistogramBucket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.CategoricalStatsResult.protoMessageName + ".CategoricalStatsHistogramBucket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "value_frequency_lower_bound"),
    2: .standard(proto: "value_frequency_upper_bound"),
    3: .standard(proto: "bucket_size"),
    4: .standard(proto: "bucket_values"),
    5: .standard(proto: "bucket_value_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.valueFrequencyLowerBound) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.valueFrequencyUpperBound) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.bucketSize) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.bucketValues) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.bucketValueCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.valueFrequencyLowerBound != 0 {
      try visitor.visitSingularInt64Field(value: self.valueFrequencyLowerBound, fieldNumber: 1)
    }
    if self.valueFrequencyUpperBound != 0 {
      try visitor.visitSingularInt64Field(value: self.valueFrequencyUpperBound, fieldNumber: 2)
    }
    if self.bucketSize != 0 {
      try visitor.visitSingularInt64Field(value: self.bucketSize, fieldNumber: 3)
    }
    if !self.bucketValues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bucketValues, fieldNumber: 4)
    }
    if self.bucketValueCount != 0 {
      try visitor.visitSingularInt64Field(value: self.bucketValueCount, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.CategoricalStatsResult.CategoricalStatsHistogramBucket, rhs: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.CategoricalStatsResult.CategoricalStatsHistogramBucket) -> Bool {
    if lhs.valueFrequencyLowerBound != rhs.valueFrequencyLowerBound {return false}
    if lhs.valueFrequencyUpperBound != rhs.valueFrequencyUpperBound {return false}
    if lhs.bucketSize != rhs.bucketSize {return false}
    if lhs.bucketValues != rhs.bucketValues {return false}
    if lhs.bucketValueCount != rhs.bucketValueCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.KAnonymityResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.protoMessageName + ".KAnonymityResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .standard(proto: "equivalence_class_histogram_buckets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.equivalenceClassHistogramBuckets) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.equivalenceClassHistogramBuckets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.equivalenceClassHistogramBuckets, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.KAnonymityResult, rhs: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.KAnonymityResult) -> Bool {
    if lhs.equivalenceClassHistogramBuckets != rhs.equivalenceClassHistogramBuckets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.KAnonymityResult.KAnonymityEquivalenceClass: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.KAnonymityResult.protoMessageName + ".KAnonymityEquivalenceClass"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "quasi_ids_values"),
    2: .standard(proto: "equivalence_class_size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.quasiIdsValues) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.equivalenceClassSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.quasiIdsValues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.quasiIdsValues, fieldNumber: 1)
    }
    if self.equivalenceClassSize != 0 {
      try visitor.visitSingularInt64Field(value: self.equivalenceClassSize, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.KAnonymityResult.KAnonymityEquivalenceClass, rhs: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.KAnonymityResult.KAnonymityEquivalenceClass) -> Bool {
    if lhs.quasiIdsValues != rhs.quasiIdsValues {return false}
    if lhs.equivalenceClassSize != rhs.equivalenceClassSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.KAnonymityResult.KAnonymityHistogramBucket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.KAnonymityResult.protoMessageName + ".KAnonymityHistogramBucket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "equivalence_class_size_lower_bound"),
    2: .standard(proto: "equivalence_class_size_upper_bound"),
    3: .standard(proto: "bucket_size"),
    4: .standard(proto: "bucket_values"),
    5: .standard(proto: "bucket_value_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.equivalenceClassSizeLowerBound) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.equivalenceClassSizeUpperBound) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.bucketSize) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.bucketValues) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.bucketValueCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.equivalenceClassSizeLowerBound != 0 {
      try visitor.visitSingularInt64Field(value: self.equivalenceClassSizeLowerBound, fieldNumber: 1)
    }
    if self.equivalenceClassSizeUpperBound != 0 {
      try visitor.visitSingularInt64Field(value: self.equivalenceClassSizeUpperBound, fieldNumber: 2)
    }
    if self.bucketSize != 0 {
      try visitor.visitSingularInt64Field(value: self.bucketSize, fieldNumber: 3)
    }
    if !self.bucketValues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bucketValues, fieldNumber: 4)
    }
    if self.bucketValueCount != 0 {
      try visitor.visitSingularInt64Field(value: self.bucketValueCount, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.KAnonymityResult.KAnonymityHistogramBucket, rhs: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.KAnonymityResult.KAnonymityHistogramBucket) -> Bool {
    if lhs.equivalenceClassSizeLowerBound != rhs.equivalenceClassSizeLowerBound {return false}
    if lhs.equivalenceClassSizeUpperBound != rhs.equivalenceClassSizeUpperBound {return false}
    if lhs.bucketSize != rhs.bucketSize {return false}
    if lhs.bucketValues != rhs.bucketValues {return false}
    if lhs.bucketValueCount != rhs.bucketValueCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.LDiversityResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.protoMessageName + ".LDiversityResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .standard(proto: "sensitive_value_frequency_histogram_buckets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.sensitiveValueFrequencyHistogramBuckets) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sensitiveValueFrequencyHistogramBuckets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sensitiveValueFrequencyHistogramBuckets, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.LDiversityResult, rhs: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.LDiversityResult) -> Bool {
    if lhs.sensitiveValueFrequencyHistogramBuckets != rhs.sensitiveValueFrequencyHistogramBuckets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.LDiversityResult.LDiversityEquivalenceClass: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.LDiversityResult.protoMessageName + ".LDiversityEquivalenceClass"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "quasi_ids_values"),
    2: .standard(proto: "equivalence_class_size"),
    3: .standard(proto: "num_distinct_sensitive_values"),
    4: .standard(proto: "top_sensitive_values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.quasiIdsValues) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.equivalenceClassSize) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.numDistinctSensitiveValues) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.topSensitiveValues) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.quasiIdsValues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.quasiIdsValues, fieldNumber: 1)
    }
    if self.equivalenceClassSize != 0 {
      try visitor.visitSingularInt64Field(value: self.equivalenceClassSize, fieldNumber: 2)
    }
    if self.numDistinctSensitiveValues != 0 {
      try visitor.visitSingularInt64Field(value: self.numDistinctSensitiveValues, fieldNumber: 3)
    }
    if !self.topSensitiveValues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.topSensitiveValues, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.LDiversityResult.LDiversityEquivalenceClass, rhs: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.LDiversityResult.LDiversityEquivalenceClass) -> Bool {
    if lhs.quasiIdsValues != rhs.quasiIdsValues {return false}
    if lhs.equivalenceClassSize != rhs.equivalenceClassSize {return false}
    if lhs.numDistinctSensitiveValues != rhs.numDistinctSensitiveValues {return false}
    if lhs.topSensitiveValues != rhs.topSensitiveValues {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.LDiversityResult.LDiversityHistogramBucket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.LDiversityResult.protoMessageName + ".LDiversityHistogramBucket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sensitive_value_frequency_lower_bound"),
    2: .standard(proto: "sensitive_value_frequency_upper_bound"),
    3: .standard(proto: "bucket_size"),
    4: .standard(proto: "bucket_values"),
    5: .standard(proto: "bucket_value_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.sensitiveValueFrequencyLowerBound) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.sensitiveValueFrequencyUpperBound) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.bucketSize) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.bucketValues) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.bucketValueCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sensitiveValueFrequencyLowerBound != 0 {
      try visitor.visitSingularInt64Field(value: self.sensitiveValueFrequencyLowerBound, fieldNumber: 1)
    }
    if self.sensitiveValueFrequencyUpperBound != 0 {
      try visitor.visitSingularInt64Field(value: self.sensitiveValueFrequencyUpperBound, fieldNumber: 2)
    }
    if self.bucketSize != 0 {
      try visitor.visitSingularInt64Field(value: self.bucketSize, fieldNumber: 3)
    }
    if !self.bucketValues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bucketValues, fieldNumber: 4)
    }
    if self.bucketValueCount != 0 {
      try visitor.visitSingularInt64Field(value: self.bucketValueCount, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.LDiversityResult.LDiversityHistogramBucket, rhs: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.LDiversityResult.LDiversityHistogramBucket) -> Bool {
    if lhs.sensitiveValueFrequencyLowerBound != rhs.sensitiveValueFrequencyLowerBound {return false}
    if lhs.sensitiveValueFrequencyUpperBound != rhs.sensitiveValueFrequencyUpperBound {return false}
    if lhs.bucketSize != rhs.bucketSize {return false}
    if lhs.bucketValues != rhs.bucketValues {return false}
    if lhs.bucketValueCount != rhs.bucketValueCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.KMapEstimationResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.protoMessageName + ".KMapEstimationResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "k_map_estimation_histogram"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.kMapEstimationHistogram) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.kMapEstimationHistogram.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.kMapEstimationHistogram, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.KMapEstimationResult, rhs: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.KMapEstimationResult) -> Bool {
    if lhs.kMapEstimationHistogram != rhs.kMapEstimationHistogram {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.KMapEstimationResult.KMapEstimationQuasiIdValues: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.KMapEstimationResult.protoMessageName + ".KMapEstimationQuasiIdValues"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "quasi_ids_values"),
    2: .standard(proto: "estimated_anonymity"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.quasiIdsValues) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.estimatedAnonymity) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.quasiIdsValues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.quasiIdsValues, fieldNumber: 1)
    }
    if self.estimatedAnonymity != 0 {
      try visitor.visitSingularInt64Field(value: self.estimatedAnonymity, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.KMapEstimationResult.KMapEstimationQuasiIdValues, rhs: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.KMapEstimationResult.KMapEstimationQuasiIdValues) -> Bool {
    if lhs.quasiIdsValues != rhs.quasiIdsValues {return false}
    if lhs.estimatedAnonymity != rhs.estimatedAnonymity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.KMapEstimationResult.KMapEstimationHistogramBucket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.KMapEstimationResult.protoMessageName + ".KMapEstimationHistogramBucket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "min_anonymity"),
    2: .standard(proto: "max_anonymity"),
    5: .standard(proto: "bucket_size"),
    6: .standard(proto: "bucket_values"),
    7: .standard(proto: "bucket_value_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.minAnonymity) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.maxAnonymity) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.bucketSize) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.bucketValues) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.bucketValueCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.minAnonymity != 0 {
      try visitor.visitSingularInt64Field(value: self.minAnonymity, fieldNumber: 1)
    }
    if self.maxAnonymity != 0 {
      try visitor.visitSingularInt64Field(value: self.maxAnonymity, fieldNumber: 2)
    }
    if self.bucketSize != 0 {
      try visitor.visitSingularInt64Field(value: self.bucketSize, fieldNumber: 5)
    }
    if !self.bucketValues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bucketValues, fieldNumber: 6)
    }
    if self.bucketValueCount != 0 {
      try visitor.visitSingularInt64Field(value: self.bucketValueCount, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.KMapEstimationResult.KMapEstimationHistogramBucket, rhs: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.KMapEstimationResult.KMapEstimationHistogramBucket) -> Bool {
    if lhs.minAnonymity != rhs.minAnonymity {return false}
    if lhs.maxAnonymity != rhs.maxAnonymity {return false}
    if lhs.bucketSize != rhs.bucketSize {return false}
    if lhs.bucketValues != rhs.bucketValues {return false}
    if lhs.bucketValueCount != rhs.bucketValueCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.DeltaPresenceEstimationResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.protoMessageName + ".DeltaPresenceEstimationResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "delta_presence_estimation_histogram"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.deltaPresenceEstimationHistogram) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deltaPresenceEstimationHistogram.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.deltaPresenceEstimationHistogram, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.DeltaPresenceEstimationResult, rhs: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.DeltaPresenceEstimationResult) -> Bool {
    if lhs.deltaPresenceEstimationHistogram != rhs.deltaPresenceEstimationHistogram {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.DeltaPresenceEstimationResult.DeltaPresenceEstimationQuasiIdValues: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.DeltaPresenceEstimationResult.protoMessageName + ".DeltaPresenceEstimationQuasiIdValues"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "quasi_ids_values"),
    2: .standard(proto: "estimated_probability"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.quasiIdsValues) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.estimatedProbability) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.quasiIdsValues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.quasiIdsValues, fieldNumber: 1)
    }
    if self.estimatedProbability != 0 {
      try visitor.visitSingularDoubleField(value: self.estimatedProbability, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.DeltaPresenceEstimationResult.DeltaPresenceEstimationQuasiIdValues, rhs: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.DeltaPresenceEstimationResult.DeltaPresenceEstimationQuasiIdValues) -> Bool {
    if lhs.quasiIdsValues != rhs.quasiIdsValues {return false}
    if lhs.estimatedProbability != rhs.estimatedProbability {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.DeltaPresenceEstimationResult.DeltaPresenceEstimationHistogramBucket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.DeltaPresenceEstimationResult.protoMessageName + ".DeltaPresenceEstimationHistogramBucket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "min_probability"),
    2: .standard(proto: "max_probability"),
    5: .standard(proto: "bucket_size"),
    6: .standard(proto: "bucket_values"),
    7: .standard(proto: "bucket_value_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.minProbability) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.maxProbability) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.bucketSize) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.bucketValues) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.bucketValueCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.minProbability != 0 {
      try visitor.visitSingularDoubleField(value: self.minProbability, fieldNumber: 1)
    }
    if self.maxProbability != 0 {
      try visitor.visitSingularDoubleField(value: self.maxProbability, fieldNumber: 2)
    }
    if self.bucketSize != 0 {
      try visitor.visitSingularInt64Field(value: self.bucketSize, fieldNumber: 5)
    }
    if !self.bucketValues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bucketValues, fieldNumber: 6)
    }
    if self.bucketValueCount != 0 {
      try visitor.visitSingularInt64Field(value: self.bucketValueCount, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.DeltaPresenceEstimationResult.DeltaPresenceEstimationHistogramBucket, rhs: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.DeltaPresenceEstimationResult.DeltaPresenceEstimationHistogramBucket) -> Bool {
    if lhs.minProbability != rhs.minProbability {return false}
    if lhs.maxProbability != rhs.maxProbability {return false}
    if lhs.bucketSize != rhs.bucketSize {return false}
    if lhs.bucketValues != rhs.bucketValues {return false}
    if lhs.bucketValueCount != rhs.bucketValueCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.RequestedRiskAnalysisOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.protoMessageName + ".RequestedRiskAnalysisOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "job_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._jobConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._jobConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.RequestedRiskAnalysisOptions, rhs: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails.RequestedRiskAnalysisOptions) -> Bool {
    if lhs._jobConfig != rhs._jobConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_ValueFrequency: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ValueFrequency"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.count) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.count != 0 {
      try visitor.visitSingularInt64Field(value: self.count, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_ValueFrequency, rhs: Google_Privacy_Dlp_V2_ValueFrequency) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_Value: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Value"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "integer_value"),
    2: .standard(proto: "float_value"),
    3: .standard(proto: "string_value"),
    4: .standard(proto: "boolean_value"),
    5: .standard(proto: "timestamp_value"),
    6: .standard(proto: "time_value"),
    7: .standard(proto: "date_value"),
    8: .standard(proto: "day_of_week_value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.type != nil {try decoder.handleConflictingOneOf()}
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {self.type = .integerValue(v)}
      }()
      case 2: try {
        if self.type != nil {try decoder.handleConflictingOneOf()}
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {self.type = .floatValue(v)}
      }()
      case 3: try {
        if self.type != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.type = .stringValue(v)}
      }()
      case 4: try {
        if self.type != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.type = .booleanValue(v)}
      }()
      case 5: try {
        var v: SwiftProtobuf.Google_Protobuf_Timestamp?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .timestampValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .timestampValue(v)}
      }()
      case 6: try {
        var v: Google_Type_TimeOfDay?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .timeValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .timeValue(v)}
      }()
      case 7: try {
        var v: Google_Type_Date?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .dateValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .dateValue(v)}
      }()
      case 8: try {
        if self.type != nil {try decoder.handleConflictingOneOf()}
        var v: Google_Type_DayOfWeek?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {self.type = .dayOfWeekValue(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.type {
    case .integerValue?: try {
      guard case .integerValue(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    }()
    case .floatValue?: try {
      guard case .floatValue(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
    }()
    case .stringValue?: try {
      guard case .stringValue(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case .booleanValue?: try {
      guard case .booleanValue(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }()
    case .timestampValue?: try {
      guard case .timestampValue(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .timeValue?: try {
      guard case .timeValue(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .dateValue?: try {
      guard case .dateValue(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .dayOfWeekValue?: try {
      guard case .dayOfWeekValue(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 8)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_Value, rhs: Google_Privacy_Dlp_V2_Value) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_QuoteInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QuoteInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "date_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: Google_Privacy_Dlp_V2_DateTime?
        if let current = self.parsedQuote {
          try decoder.handleConflictingOneOf()
          if case .dateTime(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.parsedQuote = .dateTime(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .dateTime(let v)? = self.parsedQuote {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_QuoteInfo, rhs: Google_Privacy_Dlp_V2_QuoteInfo) -> Bool {
    if lhs.parsedQuote != rhs.parsedQuote {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_DateTime: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DateTime"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "date"),
    2: .standard(proto: "day_of_week"),
    3: .same(proto: "time"),
    4: .standard(proto: "time_zone"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._date) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.dayOfWeek) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._timeZone) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._date {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.dayOfWeek != .unspecified {
      try visitor.visitSingularEnumField(value: self.dayOfWeek, fieldNumber: 2)
    }
    if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._timeZone {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_DateTime, rhs: Google_Privacy_Dlp_V2_DateTime) -> Bool {
    if lhs._date != rhs._date {return false}
    if lhs.dayOfWeek != rhs.dayOfWeek {return false}
    if lhs._time != rhs._time {return false}
    if lhs._timeZone != rhs._timeZone {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_DateTime.TimeZone: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_DateTime.protoMessageName + ".TimeZone"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "offset_minutes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.offsetMinutes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.offsetMinutes != 0 {
      try visitor.visitSingularInt32Field(value: self.offsetMinutes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_DateTime.TimeZone, rhs: Google_Privacy_Dlp_V2_DateTime.TimeZone) -> Bool {
    if lhs.offsetMinutes != rhs.offsetMinutes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_DeidentifyConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeidentifyConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "info_type_transformations"),
    2: .standard(proto: "record_transformations"),
    3: .standard(proto: "transformation_error_handling"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Privacy_Dlp_V2_InfoTypeTransformations?
        if let current = self.transformation {
          try decoder.handleConflictingOneOf()
          if case .infoTypeTransformations(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.transformation = .infoTypeTransformations(v)}
      }()
      case 2: try {
        var v: Google_Privacy_Dlp_V2_RecordTransformations?
        if let current = self.transformation {
          try decoder.handleConflictingOneOf()
          if case .recordTransformations(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.transformation = .recordTransformations(v)}
      }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._transformationErrorHandling) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.transformation {
    case .infoTypeTransformations?: try {
      guard case .infoTypeTransformations(let v)? = self.transformation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .recordTransformations?: try {
      guard case .recordTransformations(let v)? = self.transformation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if let v = self._transformationErrorHandling {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_DeidentifyConfig, rhs: Google_Privacy_Dlp_V2_DeidentifyConfig) -> Bool {
    if lhs.transformation != rhs.transformation {return false}
    if lhs._transformationErrorHandling != rhs._transformationErrorHandling {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_TransformationErrorHandling: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransformationErrorHandling"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "throw_error"),
    2: .standard(proto: "leave_untransformed"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Privacy_Dlp_V2_TransformationErrorHandling.ThrowError?
        if let current = self.mode {
          try decoder.handleConflictingOneOf()
          if case .throwError(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.mode = .throwError(v)}
      }()
      case 2: try {
        var v: Google_Privacy_Dlp_V2_TransformationErrorHandling.LeaveUntransformed?
        if let current = self.mode {
          try decoder.handleConflictingOneOf()
          if case .leaveUntransformed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.mode = .leaveUntransformed(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.mode {
    case .throwError?: try {
      guard case .throwError(let v)? = self.mode else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .leaveUntransformed?: try {
      guard case .leaveUntransformed(let v)? = self.mode else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_TransformationErrorHandling, rhs: Google_Privacy_Dlp_V2_TransformationErrorHandling) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_TransformationErrorHandling.ThrowError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_TransformationErrorHandling.protoMessageName + ".ThrowError"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_TransformationErrorHandling.ThrowError, rhs: Google_Privacy_Dlp_V2_TransformationErrorHandling.ThrowError) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_TransformationErrorHandling.LeaveUntransformed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_TransformationErrorHandling.protoMessageName + ".LeaveUntransformed"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_TransformationErrorHandling.LeaveUntransformed, rhs: Google_Privacy_Dlp_V2_TransformationErrorHandling.LeaveUntransformed) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_PrimitiveTransformation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PrimitiveTransformation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "replace_config"),
    2: .standard(proto: "redact_config"),
    3: .standard(proto: "character_mask_config"),
    4: .standard(proto: "crypto_replace_ffx_fpe_config"),
    5: .standard(proto: "fixed_size_bucketing_config"),
    6: .standard(proto: "bucketing_config"),
    7: .standard(proto: "replace_with_info_type_config"),
    8: .standard(proto: "time_part_config"),
    9: .standard(proto: "crypto_hash_config"),
    11: .standard(proto: "date_shift_config"),
    12: .standard(proto: "crypto_deterministic_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Privacy_Dlp_V2_ReplaceValueConfig?
        if let current = self.transformation {
          try decoder.handleConflictingOneOf()
          if case .replaceConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.transformation = .replaceConfig(v)}
      }()
      case 2: try {
        var v: Google_Privacy_Dlp_V2_RedactConfig?
        if let current = self.transformation {
          try decoder.handleConflictingOneOf()
          if case .redactConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.transformation = .redactConfig(v)}
      }()
      case 3: try {
        var v: Google_Privacy_Dlp_V2_CharacterMaskConfig?
        if let current = self.transformation {
          try decoder.handleConflictingOneOf()
          if case .characterMaskConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.transformation = .characterMaskConfig(v)}
      }()
      case 4: try {
        var v: Google_Privacy_Dlp_V2_CryptoReplaceFfxFpeConfig?
        if let current = self.transformation {
          try decoder.handleConflictingOneOf()
          if case .cryptoReplaceFfxFpeConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.transformation = .cryptoReplaceFfxFpeConfig(v)}
      }()
      case 5: try {
        var v: Google_Privacy_Dlp_V2_FixedSizeBucketingConfig?
        if let current = self.transformation {
          try decoder.handleConflictingOneOf()
          if case .fixedSizeBucketingConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.transformation = .fixedSizeBucketingConfig(v)}
      }()
      case 6: try {
        var v: Google_Privacy_Dlp_V2_BucketingConfig?
        if let current = self.transformation {
          try decoder.handleConflictingOneOf()
          if case .bucketingConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.transformation = .bucketingConfig(v)}
      }()
      case 7: try {
        var v: Google_Privacy_Dlp_V2_ReplaceWithInfoTypeConfig?
        if let current = self.transformation {
          try decoder.handleConflictingOneOf()
          if case .replaceWithInfoTypeConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.transformation = .replaceWithInfoTypeConfig(v)}
      }()
      case 8: try {
        var v: Google_Privacy_Dlp_V2_TimePartConfig?
        if let current = self.transformation {
          try decoder.handleConflictingOneOf()
          if case .timePartConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.transformation = .timePartConfig(v)}
      }()
      case 9: try {
        var v: Google_Privacy_Dlp_V2_CryptoHashConfig?
        if let current = self.transformation {
          try decoder.handleConflictingOneOf()
          if case .cryptoHashConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.transformation = .cryptoHashConfig(v)}
      }()
      case 11: try {
        var v: Google_Privacy_Dlp_V2_DateShiftConfig?
        if let current = self.transformation {
          try decoder.handleConflictingOneOf()
          if case .dateShiftConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.transformation = .dateShiftConfig(v)}
      }()
      case 12: try {
        var v: Google_Privacy_Dlp_V2_CryptoDeterministicConfig?
        if let current = self.transformation {
          try decoder.handleConflictingOneOf()
          if case .cryptoDeterministicConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.transformation = .cryptoDeterministicConfig(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.transformation {
    case .replaceConfig?: try {
      guard case .replaceConfig(let v)? = self.transformation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .redactConfig?: try {
      guard case .redactConfig(let v)? = self.transformation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .characterMaskConfig?: try {
      guard case .characterMaskConfig(let v)? = self.transformation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .cryptoReplaceFfxFpeConfig?: try {
      guard case .cryptoReplaceFfxFpeConfig(let v)? = self.transformation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .fixedSizeBucketingConfig?: try {
      guard case .fixedSizeBucketingConfig(let v)? = self.transformation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .bucketingConfig?: try {
      guard case .bucketingConfig(let v)? = self.transformation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .replaceWithInfoTypeConfig?: try {
      guard case .replaceWithInfoTypeConfig(let v)? = self.transformation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .timePartConfig?: try {
      guard case .timePartConfig(let v)? = self.transformation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .cryptoHashConfig?: try {
      guard case .cryptoHashConfig(let v)? = self.transformation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .dateShiftConfig?: try {
      guard case .dateShiftConfig(let v)? = self.transformation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .cryptoDeterministicConfig?: try {
      guard case .cryptoDeterministicConfig(let v)? = self.transformation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_PrimitiveTransformation, rhs: Google_Privacy_Dlp_V2_PrimitiveTransformation) -> Bool {
    if lhs.transformation != rhs.transformation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_TimePartConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TimePartConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "part_to_extract"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.partToExtract) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.partToExtract != .unspecified {
      try visitor.visitSingularEnumField(value: self.partToExtract, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_TimePartConfig, rhs: Google_Privacy_Dlp_V2_TimePartConfig) -> Bool {
    if lhs.partToExtract != rhs.partToExtract {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_TimePartConfig.TimePart: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TIME_PART_UNSPECIFIED"),
    1: .same(proto: "YEAR"),
    2: .same(proto: "MONTH"),
    3: .same(proto: "DAY_OF_MONTH"),
    4: .same(proto: "DAY_OF_WEEK"),
    5: .same(proto: "WEEK_OF_YEAR"),
    6: .same(proto: "HOUR_OF_DAY"),
  ]
}

extension Google_Privacy_Dlp_V2_CryptoHashConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CryptoHashConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "crypto_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._cryptoKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._cryptoKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_CryptoHashConfig, rhs: Google_Privacy_Dlp_V2_CryptoHashConfig) -> Bool {
    if lhs._cryptoKey != rhs._cryptoKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_CryptoDeterministicConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CryptoDeterministicConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "crypto_key"),
    2: .standard(proto: "surrogate_info_type"),
    3: .same(proto: "context"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._cryptoKey) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._surrogateInfoType) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._context) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._cryptoKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._surrogateInfoType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._context {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_CryptoDeterministicConfig, rhs: Google_Privacy_Dlp_V2_CryptoDeterministicConfig) -> Bool {
    if lhs._cryptoKey != rhs._cryptoKey {return false}
    if lhs._surrogateInfoType != rhs._surrogateInfoType {return false}
    if lhs._context != rhs._context {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_ReplaceValueConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReplaceValueConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "new_value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._newValue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._newValue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_ReplaceValueConfig, rhs: Google_Privacy_Dlp_V2_ReplaceValueConfig) -> Bool {
    if lhs._newValue != rhs._newValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_ReplaceWithInfoTypeConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReplaceWithInfoTypeConfig"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_ReplaceWithInfoTypeConfig, rhs: Google_Privacy_Dlp_V2_ReplaceWithInfoTypeConfig) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_RedactConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RedactConfig"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_RedactConfig, rhs: Google_Privacy_Dlp_V2_RedactConfig) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_CharsToIgnore: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CharsToIgnore"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "characters_to_skip"),
    2: .standard(proto: "common_characters_to_ignore"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.characters != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.characters = .charactersToSkip(v)}
      }()
      case 2: try {
        if self.characters != nil {try decoder.handleConflictingOneOf()}
        var v: Google_Privacy_Dlp_V2_CharsToIgnore.CommonCharsToIgnore?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {self.characters = .commonCharactersToIgnore(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.characters {
    case .charactersToSkip?: try {
      guard case .charactersToSkip(let v)? = self.characters else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .commonCharactersToIgnore?: try {
      guard case .commonCharactersToIgnore(let v)? = self.characters else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_CharsToIgnore, rhs: Google_Privacy_Dlp_V2_CharsToIgnore) -> Bool {
    if lhs.characters != rhs.characters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_CharsToIgnore.CommonCharsToIgnore: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COMMON_CHARS_TO_IGNORE_UNSPECIFIED"),
    1: .same(proto: "NUMERIC"),
    2: .same(proto: "ALPHA_UPPER_CASE"),
    3: .same(proto: "ALPHA_LOWER_CASE"),
    4: .same(proto: "PUNCTUATION"),
    5: .same(proto: "WHITESPACE"),
  ]
}

extension Google_Privacy_Dlp_V2_CharacterMaskConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CharacterMaskConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "masking_character"),
    2: .standard(proto: "number_to_mask"),
    3: .standard(proto: "reverse_order"),
    4: .standard(proto: "characters_to_ignore"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.maskingCharacter) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.numberToMask) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.reverseOrder) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.charactersToIgnore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.maskingCharacter.isEmpty {
      try visitor.visitSingularStringField(value: self.maskingCharacter, fieldNumber: 1)
    }
    if self.numberToMask != 0 {
      try visitor.visitSingularInt32Field(value: self.numberToMask, fieldNumber: 2)
    }
    if self.reverseOrder != false {
      try visitor.visitSingularBoolField(value: self.reverseOrder, fieldNumber: 3)
    }
    if !self.charactersToIgnore.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.charactersToIgnore, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_CharacterMaskConfig, rhs: Google_Privacy_Dlp_V2_CharacterMaskConfig) -> Bool {
    if lhs.maskingCharacter != rhs.maskingCharacter {return false}
    if lhs.numberToMask != rhs.numberToMask {return false}
    if lhs.reverseOrder != rhs.reverseOrder {return false}
    if lhs.charactersToIgnore != rhs.charactersToIgnore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_FixedSizeBucketingConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FixedSizeBucketingConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "lower_bound"),
    2: .standard(proto: "upper_bound"),
    3: .standard(proto: "bucket_size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._lowerBound) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._upperBound) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.bucketSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._lowerBound {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._upperBound {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.bucketSize != 0 {
      try visitor.visitSingularDoubleField(value: self.bucketSize, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_FixedSizeBucketingConfig, rhs: Google_Privacy_Dlp_V2_FixedSizeBucketingConfig) -> Bool {
    if lhs._lowerBound != rhs._lowerBound {return false}
    if lhs._upperBound != rhs._upperBound {return false}
    if lhs.bucketSize != rhs.bucketSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_BucketingConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BucketingConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "buckets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.buckets) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.buckets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.buckets, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_BucketingConfig, rhs: Google_Privacy_Dlp_V2_BucketingConfig) -> Bool {
    if lhs.buckets != rhs.buckets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_BucketingConfig.Bucket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_BucketingConfig.protoMessageName + ".Bucket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "min"),
    2: .same(proto: "max"),
    3: .standard(proto: "replacement_value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._min) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._max) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._replacementValue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._min {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._max {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._replacementValue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_BucketingConfig.Bucket, rhs: Google_Privacy_Dlp_V2_BucketingConfig.Bucket) -> Bool {
    if lhs._min != rhs._min {return false}
    if lhs._max != rhs._max {return false}
    if lhs._replacementValue != rhs._replacementValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_CryptoReplaceFfxFpeConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CryptoReplaceFfxFpeConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "crypto_key"),
    2: .same(proto: "context"),
    4: .standard(proto: "common_alphabet"),
    5: .standard(proto: "custom_alphabet"),
    6: .same(proto: "radix"),
    8: .standard(proto: "surrogate_info_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._cryptoKey) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._context) }()
      case 4: try {
        if self.alphabet != nil {try decoder.handleConflictingOneOf()}
        var v: Google_Privacy_Dlp_V2_CryptoReplaceFfxFpeConfig.FfxCommonNativeAlphabet?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {self.alphabet = .commonAlphabet(v)}
      }()
      case 5: try {
        if self.alphabet != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.alphabet = .customAlphabet(v)}
      }()
      case 6: try {
        if self.alphabet != nil {try decoder.handleConflictingOneOf()}
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {self.alphabet = .radix(v)}
      }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._surrogateInfoType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._cryptoKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._context {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.alphabet {
    case .commonAlphabet?: try {
      guard case .commonAlphabet(let v)? = self.alphabet else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    }()
    case .customAlphabet?: try {
      guard case .customAlphabet(let v)? = self.alphabet else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }()
    case .radix?: try {
      guard case .radix(let v)? = self.alphabet else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    if let v = self._surrogateInfoType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_CryptoReplaceFfxFpeConfig, rhs: Google_Privacy_Dlp_V2_CryptoReplaceFfxFpeConfig) -> Bool {
    if lhs._cryptoKey != rhs._cryptoKey {return false}
    if lhs._context != rhs._context {return false}
    if lhs.alphabet != rhs.alphabet {return false}
    if lhs._surrogateInfoType != rhs._surrogateInfoType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_CryptoReplaceFfxFpeConfig.FfxCommonNativeAlphabet: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FFX_COMMON_NATIVE_ALPHABET_UNSPECIFIED"),
    1: .same(proto: "NUMERIC"),
    2: .same(proto: "HEXADECIMAL"),
    3: .same(proto: "UPPER_CASE_ALPHA_NUMERIC"),
    4: .same(proto: "ALPHA_NUMERIC"),
  ]
}

extension Google_Privacy_Dlp_V2_CryptoKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CryptoKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transient"),
    2: .same(proto: "unwrapped"),
    3: .standard(proto: "kms_wrapped"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Privacy_Dlp_V2_TransientCryptoKey?
        if let current = self.source {
          try decoder.handleConflictingOneOf()
          if case .transient(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.source = .transient(v)}
      }()
      case 2: try {
        var v: Google_Privacy_Dlp_V2_UnwrappedCryptoKey?
        if let current = self.source {
          try decoder.handleConflictingOneOf()
          if case .unwrapped(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.source = .unwrapped(v)}
      }()
      case 3: try {
        var v: Google_Privacy_Dlp_V2_KmsWrappedCryptoKey?
        if let current = self.source {
          try decoder.handleConflictingOneOf()
          if case .kmsWrapped(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.source = .kmsWrapped(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.source {
    case .transient?: try {
      guard case .transient(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .unwrapped?: try {
      guard case .unwrapped(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .kmsWrapped?: try {
      guard case .kmsWrapped(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_CryptoKey, rhs: Google_Privacy_Dlp_V2_CryptoKey) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_TransientCryptoKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransientCryptoKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_TransientCryptoKey, rhs: Google_Privacy_Dlp_V2_TransientCryptoKey) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_UnwrappedCryptoKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnwrappedCryptoKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.key) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_UnwrappedCryptoKey, rhs: Google_Privacy_Dlp_V2_UnwrappedCryptoKey) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_KmsWrappedCryptoKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KmsWrappedCryptoKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "wrapped_key"),
    2: .standard(proto: "crypto_key_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.wrappedKey) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cryptoKeyName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.wrappedKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.wrappedKey, fieldNumber: 1)
    }
    if !self.cryptoKeyName.isEmpty {
      try visitor.visitSingularStringField(value: self.cryptoKeyName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_KmsWrappedCryptoKey, rhs: Google_Privacy_Dlp_V2_KmsWrappedCryptoKey) -> Bool {
    if lhs.wrappedKey != rhs.wrappedKey {return false}
    if lhs.cryptoKeyName != rhs.cryptoKeyName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_DateShiftConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DateShiftConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "upper_bound_days"),
    2: .standard(proto: "lower_bound_days"),
    3: .same(proto: "context"),
    4: .standard(proto: "crypto_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.upperBoundDays) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.lowerBoundDays) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._context) }()
      case 4: try {
        var v: Google_Privacy_Dlp_V2_CryptoKey?
        if let current = self.method {
          try decoder.handleConflictingOneOf()
          if case .cryptoKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.method = .cryptoKey(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.upperBoundDays != 0 {
      try visitor.visitSingularInt32Field(value: self.upperBoundDays, fieldNumber: 1)
    }
    if self.lowerBoundDays != 0 {
      try visitor.visitSingularInt32Field(value: self.lowerBoundDays, fieldNumber: 2)
    }
    if let v = self._context {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if case .cryptoKey(let v)? = self.method {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_DateShiftConfig, rhs: Google_Privacy_Dlp_V2_DateShiftConfig) -> Bool {
    if lhs.upperBoundDays != rhs.upperBoundDays {return false}
    if lhs.lowerBoundDays != rhs.lowerBoundDays {return false}
    if lhs._context != rhs._context {return false}
    if lhs.method != rhs.method {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_InfoTypeTransformations: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InfoTypeTransformations"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transformations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.transformations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transformations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transformations, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_InfoTypeTransformations, rhs: Google_Privacy_Dlp_V2_InfoTypeTransformations) -> Bool {
    if lhs.transformations != rhs.transformations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_InfoTypeTransformations.InfoTypeTransformation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_InfoTypeTransformations.protoMessageName + ".InfoTypeTransformation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "info_types"),
    2: .standard(proto: "primitive_transformation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.infoTypes) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._primitiveTransformation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.infoTypes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.infoTypes, fieldNumber: 1)
    }
    if let v = self._primitiveTransformation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_InfoTypeTransformations.InfoTypeTransformation, rhs: Google_Privacy_Dlp_V2_InfoTypeTransformations.InfoTypeTransformation) -> Bool {
    if lhs.infoTypes != rhs.infoTypes {return false}
    if lhs._primitiveTransformation != rhs._primitiveTransformation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_FieldTransformation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FieldTransformation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fields"),
    3: .same(proto: "condition"),
    4: .standard(proto: "primitive_transformation"),
    5: .standard(proto: "info_type_transformations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.fields) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._condition) }()
      case 4: try {
        var v: Google_Privacy_Dlp_V2_PrimitiveTransformation?
        if let current = self.transformation {
          try decoder.handleConflictingOneOf()
          if case .primitiveTransformation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.transformation = .primitiveTransformation(v)}
      }()
      case 5: try {
        var v: Google_Privacy_Dlp_V2_InfoTypeTransformations?
        if let current = self.transformation {
          try decoder.handleConflictingOneOf()
          if case .infoTypeTransformations(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.transformation = .infoTypeTransformations(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fields.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fields, fieldNumber: 1)
    }
    if let v = self._condition {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.transformation {
    case .primitiveTransformation?: try {
      guard case .primitiveTransformation(let v)? = self.transformation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .infoTypeTransformations?: try {
      guard case .infoTypeTransformations(let v)? = self.transformation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_FieldTransformation, rhs: Google_Privacy_Dlp_V2_FieldTransformation) -> Bool {
    if lhs.fields != rhs.fields {return false}
    if lhs._condition != rhs._condition {return false}
    if lhs.transformation != rhs.transformation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_RecordTransformations: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecordTransformations"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "field_transformations"),
    2: .standard(proto: "record_suppressions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.fieldTransformations) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.recordSuppressions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fieldTransformations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fieldTransformations, fieldNumber: 1)
    }
    if !self.recordSuppressions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.recordSuppressions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_RecordTransformations, rhs: Google_Privacy_Dlp_V2_RecordTransformations) -> Bool {
    if lhs.fieldTransformations != rhs.fieldTransformations {return false}
    if lhs.recordSuppressions != rhs.recordSuppressions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_RecordSuppression: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecordSuppression"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "condition"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._condition) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._condition {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_RecordSuppression, rhs: Google_Privacy_Dlp_V2_RecordSuppression) -> Bool {
    if lhs._condition != rhs._condition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_RecordCondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecordCondition"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "expressions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularMessageField(value: &self._expressions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._expressions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_RecordCondition, rhs: Google_Privacy_Dlp_V2_RecordCondition) -> Bool {
    if lhs._expressions != rhs._expressions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_RecordCondition.Condition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_RecordCondition.protoMessageName + ".Condition"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "field"),
    3: .same(proto: "operator"),
    4: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._field) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.`operator`) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._field {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.`operator` != .unspecified {
      try visitor.visitSingularEnumField(value: self.`operator`, fieldNumber: 3)
    }
    if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_RecordCondition.Condition, rhs: Google_Privacy_Dlp_V2_RecordCondition.Condition) -> Bool {
    if lhs._field != rhs._field {return false}
    if lhs.`operator` != rhs.`operator` {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_RecordCondition.Conditions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_RecordCondition.protoMessageName + ".Conditions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "conditions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.conditions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.conditions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.conditions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_RecordCondition.Conditions, rhs: Google_Privacy_Dlp_V2_RecordCondition.Conditions) -> Bool {
    if lhs.conditions != rhs.conditions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_RecordCondition.Expressions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_RecordCondition.protoMessageName + ".Expressions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "logical_operator"),
    3: .same(proto: "conditions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.logicalOperator) }()
      case 3: try {
        var v: Google_Privacy_Dlp_V2_RecordCondition.Conditions?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .conditions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .conditions(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.logicalOperator != .unspecified {
      try visitor.visitSingularEnumField(value: self.logicalOperator, fieldNumber: 1)
    }
    if case .conditions(let v)? = self.type {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_RecordCondition.Expressions, rhs: Google_Privacy_Dlp_V2_RecordCondition.Expressions) -> Bool {
    if lhs.logicalOperator != rhs.logicalOperator {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_RecordCondition.Expressions.LogicalOperator: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LOGICAL_OPERATOR_UNSPECIFIED"),
    1: .same(proto: "AND"),
  ]
}

extension Google_Privacy_Dlp_V2_TransformationOverview: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransformationOverview"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "transformed_bytes"),
    3: .standard(proto: "transformation_summaries"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.transformedBytes) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.transformationSummaries) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.transformedBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.transformedBytes, fieldNumber: 2)
    }
    if !self.transformationSummaries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transformationSummaries, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_TransformationOverview, rhs: Google_Privacy_Dlp_V2_TransformationOverview) -> Bool {
    if lhs.transformedBytes != rhs.transformedBytes {return false}
    if lhs.transformationSummaries != rhs.transformationSummaries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_TransformationSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransformationSummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "info_type"),
    2: .same(proto: "field"),
    3: .same(proto: "transformation"),
    5: .standard(proto: "field_transformations"),
    6: .standard(proto: "record_suppress"),
    4: .same(proto: "results"),
    7: .standard(proto: "transformed_bytes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._infoType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._field) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._transformation) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.results) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.fieldTransformations) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._recordSuppress) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.transformedBytes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._infoType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._field {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._transformation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.results.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.results, fieldNumber: 4)
    }
    if !self.fieldTransformations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fieldTransformations, fieldNumber: 5)
    }
    if let v = self._recordSuppress {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if self.transformedBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.transformedBytes, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_TransformationSummary, rhs: Google_Privacy_Dlp_V2_TransformationSummary) -> Bool {
    if lhs._infoType != rhs._infoType {return false}
    if lhs._field != rhs._field {return false}
    if lhs._transformation != rhs._transformation {return false}
    if lhs.fieldTransformations != rhs.fieldTransformations {return false}
    if lhs._recordSuppress != rhs._recordSuppress {return false}
    if lhs.results != rhs.results {return false}
    if lhs.transformedBytes != rhs.transformedBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_TransformationSummary.TransformationResultCode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TRANSFORMATION_RESULT_CODE_UNSPECIFIED"),
    1: .same(proto: "SUCCESS"),
    2: .same(proto: "ERROR"),
  ]
}

extension Google_Privacy_Dlp_V2_TransformationSummary.SummaryResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_TransformationSummary.protoMessageName + ".SummaryResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "count"),
    2: .same(proto: "code"),
    3: .same(proto: "details"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.count) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.details) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.count != 0 {
      try visitor.visitSingularInt64Field(value: self.count, fieldNumber: 1)
    }
    if self.code != .unspecified {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 2)
    }
    if !self.details.isEmpty {
      try visitor.visitSingularStringField(value: self.details, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_TransformationSummary.SummaryResult, rhs: Google_Privacy_Dlp_V2_TransformationSummary.SummaryResult) -> Bool {
    if lhs.count != rhs.count {return false}
    if lhs.code != rhs.code {return false}
    if lhs.details != rhs.details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_Schedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Schedule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "recurrence_period_duration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: SwiftProtobuf.Google_Protobuf_Duration?
        if let current = self.option {
          try decoder.handleConflictingOneOf()
          if case .recurrencePeriodDuration(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.option = .recurrencePeriodDuration(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .recurrencePeriodDuration(let v)? = self.option {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_Schedule, rhs: Google_Privacy_Dlp_V2_Schedule) -> Bool {
    if lhs.option != rhs.option {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_Manual: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Manual"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_Manual, rhs: Google_Privacy_Dlp_V2_Manual) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_InspectTemplate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InspectTemplate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "display_name"),
    3: .same(proto: "description"),
    4: .standard(proto: "create_time"),
    5: .standard(proto: "update_time"),
    6: .standard(proto: "inspect_config"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _displayName: String = String()
    var _description_p: String = String()
    var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _inspectConfig: Google_Privacy_Dlp_V2_InspectConfig? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _displayName = source._displayName
      _description_p = source._description_p
      _createTime = source._createTime
      _updateTime = source._updateTime
      _inspectConfig = source._inspectConfig
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._displayName) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._createTime) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._updateTime) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._inspectConfig) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._displayName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._displayName, fieldNumber: 2)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 3)
      }
      if let v = _storage._createTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._updateTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._inspectConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_InspectTemplate, rhs: Google_Privacy_Dlp_V2_InspectTemplate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._displayName != rhs_storage._displayName {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._updateTime != rhs_storage._updateTime {return false}
        if _storage._inspectConfig != rhs_storage._inspectConfig {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_DeidentifyTemplate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeidentifyTemplate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "display_name"),
    3: .same(proto: "description"),
    4: .standard(proto: "create_time"),
    5: .standard(proto: "update_time"),
    6: .standard(proto: "deidentify_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._updateTime) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._deidentifyConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._updateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._deidentifyConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_DeidentifyTemplate, rhs: Google_Privacy_Dlp_V2_DeidentifyTemplate) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs._updateTime != rhs._updateTime {return false}
    if lhs._deidentifyConfig != rhs._deidentifyConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "details"),
    2: .same(proto: "timestamps"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.timestamps) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.timestamps.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.timestamps, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_Error, rhs: Google_Privacy_Dlp_V2_Error) -> Bool {
    if lhs._details != rhs._details {return false}
    if lhs.timestamps != rhs.timestamps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_JobTrigger: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JobTrigger"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "display_name"),
    3: .same(proto: "description"),
    4: .standard(proto: "inspect_job"),
    5: .same(proto: "triggers"),
    6: .same(proto: "errors"),
    7: .standard(proto: "create_time"),
    8: .standard(proto: "update_time"),
    9: .standard(proto: "last_run_time"),
    10: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try {
        var v: Google_Privacy_Dlp_V2_InspectJobConfig?
        if let current = self.job {
          try decoder.handleConflictingOneOf()
          if case .inspectJob(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.job = .inspectJob(v)}
      }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.triggers) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.errors) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._updateTime) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._lastRunTime) }()
      case 10: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if case .inspectJob(let v)? = self.job {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.triggers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.triggers, fieldNumber: 5)
    }
    if !self.errors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errors, fieldNumber: 6)
    }
    if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if let v = self._updateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    if let v = self._lastRunTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_JobTrigger, rhs: Google_Privacy_Dlp_V2_JobTrigger) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.job != rhs.job {return false}
    if lhs.triggers != rhs.triggers {return false}
    if lhs.errors != rhs.errors {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs._updateTime != rhs._updateTime {return false}
    if lhs._lastRunTime != rhs._lastRunTime {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_JobTrigger.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNSPECIFIED"),
    1: .same(proto: "HEALTHY"),
    2: .same(proto: "PAUSED"),
    3: .same(proto: "CANCELLED"),
  ]
}

extension Google_Privacy_Dlp_V2_JobTrigger.Trigger: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_JobTrigger.protoMessageName + ".Trigger"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "schedule"),
    2: .same(proto: "manual"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Privacy_Dlp_V2_Schedule?
        if let current = self.trigger {
          try decoder.handleConflictingOneOf()
          if case .schedule(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.trigger = .schedule(v)}
      }()
      case 2: try {
        var v: Google_Privacy_Dlp_V2_Manual?
        if let current = self.trigger {
          try decoder.handleConflictingOneOf()
          if case .manual(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.trigger = .manual(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.trigger {
    case .schedule?: try {
      guard case .schedule(let v)? = self.trigger else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .manual?: try {
      guard case .manual(let v)? = self.trigger else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_JobTrigger.Trigger, rhs: Google_Privacy_Dlp_V2_JobTrigger.Trigger) -> Bool {
    if lhs.trigger != rhs.trigger {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_Action: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Action"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "save_findings"),
    2: .standard(proto: "pub_sub"),
    3: .standard(proto: "publish_summary_to_cscc"),
    5: .standard(proto: "publish_findings_to_cloud_data_catalog"),
    8: .standard(proto: "job_notification_emails"),
    9: .standard(proto: "publish_to_stackdriver"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Privacy_Dlp_V2_Action.SaveFindings?
        if let current = self.action {
          try decoder.handleConflictingOneOf()
          if case .saveFindings(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.action = .saveFindings(v)}
      }()
      case 2: try {
        var v: Google_Privacy_Dlp_V2_Action.PublishToPubSub?
        if let current = self.action {
          try decoder.handleConflictingOneOf()
          if case .pubSub(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.action = .pubSub(v)}
      }()
      case 3: try {
        var v: Google_Privacy_Dlp_V2_Action.PublishSummaryToCscc?
        if let current = self.action {
          try decoder.handleConflictingOneOf()
          if case .publishSummaryToCscc(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.action = .publishSummaryToCscc(v)}
      }()
      case 5: try {
        var v: Google_Privacy_Dlp_V2_Action.PublishFindingsToCloudDataCatalog?
        if let current = self.action {
          try decoder.handleConflictingOneOf()
          if case .publishFindingsToCloudDataCatalog(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.action = .publishFindingsToCloudDataCatalog(v)}
      }()
      case 8: try {
        var v: Google_Privacy_Dlp_V2_Action.JobNotificationEmails?
        if let current = self.action {
          try decoder.handleConflictingOneOf()
          if case .jobNotificationEmails(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.action = .jobNotificationEmails(v)}
      }()
      case 9: try {
        var v: Google_Privacy_Dlp_V2_Action.PublishToStackdriver?
        if let current = self.action {
          try decoder.handleConflictingOneOf()
          if case .publishToStackdriver(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.action = .publishToStackdriver(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.action {
    case .saveFindings?: try {
      guard case .saveFindings(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .pubSub?: try {
      guard case .pubSub(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .publishSummaryToCscc?: try {
      guard case .publishSummaryToCscc(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .publishFindingsToCloudDataCatalog?: try {
      guard case .publishFindingsToCloudDataCatalog(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .jobNotificationEmails?: try {
      guard case .jobNotificationEmails(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .publishToStackdriver?: try {
      guard case .publishToStackdriver(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_Action, rhs: Google_Privacy_Dlp_V2_Action) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_Action.SaveFindings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_Action.protoMessageName + ".SaveFindings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "output_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._outputConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._outputConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_Action.SaveFindings, rhs: Google_Privacy_Dlp_V2_Action.SaveFindings) -> Bool {
    if lhs._outputConfig != rhs._outputConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_Action.PublishToPubSub: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_Action.protoMessageName + ".PublishToPubSub"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_Action.PublishToPubSub, rhs: Google_Privacy_Dlp_V2_Action.PublishToPubSub) -> Bool {
    if lhs.topic != rhs.topic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_Action.PublishSummaryToCscc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_Action.protoMessageName + ".PublishSummaryToCscc"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_Action.PublishSummaryToCscc, rhs: Google_Privacy_Dlp_V2_Action.PublishSummaryToCscc) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_Action.PublishFindingsToCloudDataCatalog: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_Action.protoMessageName + ".PublishFindingsToCloudDataCatalog"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_Action.PublishFindingsToCloudDataCatalog, rhs: Google_Privacy_Dlp_V2_Action.PublishFindingsToCloudDataCatalog) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_Action.JobNotificationEmails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_Action.protoMessageName + ".JobNotificationEmails"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_Action.JobNotificationEmails, rhs: Google_Privacy_Dlp_V2_Action.JobNotificationEmails) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_Action.PublishToStackdriver: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_Action.protoMessageName + ".PublishToStackdriver"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_Action.PublishToStackdriver, rhs: Google_Privacy_Dlp_V2_Action.PublishToStackdriver) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_CreateInspectTemplateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateInspectTemplateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "inspect_template"),
    3: .standard(proto: "template_id"),
    4: .standard(proto: "location_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._inspectTemplate) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.templateID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.locationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if let v = self._inspectTemplate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.templateID.isEmpty {
      try visitor.visitSingularStringField(value: self.templateID, fieldNumber: 3)
    }
    if !self.locationID.isEmpty {
      try visitor.visitSingularStringField(value: self.locationID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_CreateInspectTemplateRequest, rhs: Google_Privacy_Dlp_V2_CreateInspectTemplateRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs._inspectTemplate != rhs._inspectTemplate {return false}
    if lhs.templateID != rhs.templateID {return false}
    if lhs.locationID != rhs.locationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_UpdateInspectTemplateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateInspectTemplateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "inspect_template"),
    3: .standard(proto: "update_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._inspectTemplate) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._inspectTemplate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_UpdateInspectTemplateRequest, rhs: Google_Privacy_Dlp_V2_UpdateInspectTemplateRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._inspectTemplate != rhs._inspectTemplate {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_GetInspectTemplateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetInspectTemplateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_GetInspectTemplateRequest, rhs: Google_Privacy_Dlp_V2_GetInspectTemplateRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_ListInspectTemplatesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListInspectTemplatesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_token"),
    3: .standard(proto: "page_size"),
    4: .standard(proto: "order_by"),
    5: .standard(proto: "location_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.orderBy) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.locationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    if !self.orderBy.isEmpty {
      try visitor.visitSingularStringField(value: self.orderBy, fieldNumber: 4)
    }
    if !self.locationID.isEmpty {
      try visitor.visitSingularStringField(value: self.locationID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_ListInspectTemplatesRequest, rhs: Google_Privacy_Dlp_V2_ListInspectTemplatesRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.orderBy != rhs.orderBy {return false}
    if lhs.locationID != rhs.locationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_ListInspectTemplatesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListInspectTemplatesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "inspect_templates"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.inspectTemplates) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inspectTemplates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inspectTemplates, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_ListInspectTemplatesResponse, rhs: Google_Privacy_Dlp_V2_ListInspectTemplatesResponse) -> Bool {
    if lhs.inspectTemplates != rhs.inspectTemplates {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_DeleteInspectTemplateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteInspectTemplateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_DeleteInspectTemplateRequest, rhs: Google_Privacy_Dlp_V2_DeleteInspectTemplateRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_CreateJobTriggerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateJobTriggerRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "job_trigger"),
    3: .standard(proto: "trigger_id"),
    4: .standard(proto: "location_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._jobTrigger) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.triggerID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.locationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if let v = self._jobTrigger {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.triggerID.isEmpty {
      try visitor.visitSingularStringField(value: self.triggerID, fieldNumber: 3)
    }
    if !self.locationID.isEmpty {
      try visitor.visitSingularStringField(value: self.locationID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_CreateJobTriggerRequest, rhs: Google_Privacy_Dlp_V2_CreateJobTriggerRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs._jobTrigger != rhs._jobTrigger {return false}
    if lhs.triggerID != rhs.triggerID {return false}
    if lhs.locationID != rhs.locationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_ActivateJobTriggerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActivateJobTriggerRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_ActivateJobTriggerRequest, rhs: Google_Privacy_Dlp_V2_ActivateJobTriggerRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_UpdateJobTriggerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateJobTriggerRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "job_trigger"),
    3: .standard(proto: "update_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._jobTrigger) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._jobTrigger {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_UpdateJobTriggerRequest, rhs: Google_Privacy_Dlp_V2_UpdateJobTriggerRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._jobTrigger != rhs._jobTrigger {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_GetJobTriggerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetJobTriggerRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_GetJobTriggerRequest, rhs: Google_Privacy_Dlp_V2_GetJobTriggerRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_CreateDlpJobRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateDlpJobRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "inspect_job"),
    3: .standard(proto: "risk_job"),
    4: .standard(proto: "job_id"),
    5: .standard(proto: "location_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try {
        var v: Google_Privacy_Dlp_V2_InspectJobConfig?
        if let current = self.job {
          try decoder.handleConflictingOneOf()
          if case .inspectJob(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.job = .inspectJob(v)}
      }()
      case 3: try {
        var v: Google_Privacy_Dlp_V2_RiskAnalysisJobConfig?
        if let current = self.job {
          try decoder.handleConflictingOneOf()
          if case .riskJob(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.job = .riskJob(v)}
      }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.jobID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.locationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.job {
    case .inspectJob?: try {
      guard case .inspectJob(let v)? = self.job else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .riskJob?: try {
      guard case .riskJob(let v)? = self.job else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if !self.jobID.isEmpty {
      try visitor.visitSingularStringField(value: self.jobID, fieldNumber: 4)
    }
    if !self.locationID.isEmpty {
      try visitor.visitSingularStringField(value: self.locationID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_CreateDlpJobRequest, rhs: Google_Privacy_Dlp_V2_CreateDlpJobRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.job != rhs.job {return false}
    if lhs.jobID != rhs.jobID {return false}
    if lhs.locationID != rhs.locationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_ListJobTriggersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListJobTriggersRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_token"),
    3: .standard(proto: "page_size"),
    4: .standard(proto: "order_by"),
    5: .same(proto: "filter"),
    7: .standard(proto: "location_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.orderBy) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.locationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    if !self.orderBy.isEmpty {
      try visitor.visitSingularStringField(value: self.orderBy, fieldNumber: 4)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 5)
    }
    if !self.locationID.isEmpty {
      try visitor.visitSingularStringField(value: self.locationID, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_ListJobTriggersRequest, rhs: Google_Privacy_Dlp_V2_ListJobTriggersRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.orderBy != rhs.orderBy {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.locationID != rhs.locationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_ListJobTriggersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListJobTriggersResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "job_triggers"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.jobTriggers) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.jobTriggers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.jobTriggers, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_ListJobTriggersResponse, rhs: Google_Privacy_Dlp_V2_ListJobTriggersResponse) -> Bool {
    if lhs.jobTriggers != rhs.jobTriggers {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_DeleteJobTriggerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteJobTriggerRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_DeleteJobTriggerRequest, rhs: Google_Privacy_Dlp_V2_DeleteJobTriggerRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_InspectJobConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InspectJobConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "storage_config"),
    2: .standard(proto: "inspect_config"),
    3: .standard(proto: "inspect_template_name"),
    4: .same(proto: "actions"),
  ]

  fileprivate class _StorageClass {
    var _storageConfig: Google_Privacy_Dlp_V2_StorageConfig? = nil
    var _inspectConfig: Google_Privacy_Dlp_V2_InspectConfig? = nil
    var _inspectTemplateName: String = String()
    var _actions: [Google_Privacy_Dlp_V2_Action] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _storageConfig = source._storageConfig
      _inspectConfig = source._inspectConfig
      _inspectTemplateName = source._inspectTemplateName
      _actions = source._actions
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._storageConfig) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._inspectConfig) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._inspectTemplateName) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._actions) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._storageConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._inspectConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._inspectTemplateName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._inspectTemplateName, fieldNumber: 3)
      }
      if !_storage._actions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._actions, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_InspectJobConfig, rhs: Google_Privacy_Dlp_V2_InspectJobConfig) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._storageConfig != rhs_storage._storageConfig {return false}
        if _storage._inspectConfig != rhs_storage._inspectConfig {return false}
        if _storage._inspectTemplateName != rhs_storage._inspectTemplateName {return false}
        if _storage._actions != rhs_storage._actions {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_DlpJob: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DlpJob"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "type"),
    3: .same(proto: "state"),
    4: .standard(proto: "risk_details"),
    5: .standard(proto: "inspect_details"),
    6: .standard(proto: "create_time"),
    7: .standard(proto: "start_time"),
    8: .standard(proto: "end_time"),
    10: .standard(proto: "job_trigger_name"),
    11: .same(proto: "errors"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _type: Google_Privacy_Dlp_V2_DlpJobType = .unspecified
    var _state: Google_Privacy_Dlp_V2_DlpJob.JobState = .unspecified
    var _details: Google_Privacy_Dlp_V2_DlpJob.OneOf_Details?
    var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _jobTriggerName: String = String()
    var _errors: [Google_Privacy_Dlp_V2_Error] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _type = source._type
      _state = source._state
      _details = source._details
      _createTime = source._createTime
      _startTime = source._startTime
      _endTime = source._endTime
      _jobTriggerName = source._jobTriggerName
      _errors = source._errors
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 4: try {
          var v: Google_Privacy_Dlp_V2_AnalyzeDataSourceRiskDetails?
          if let current = _storage._details {
            try decoder.handleConflictingOneOf()
            if case .riskDetails(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._details = .riskDetails(v)}
        }()
        case 5: try {
          var v: Google_Privacy_Dlp_V2_InspectDataSourceDetails?
          if let current = _storage._details {
            try decoder.handleConflictingOneOf()
            if case .inspectDetails(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._details = .inspectDetails(v)}
        }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._createTime) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._startTime) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._endTime) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._jobTriggerName) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._errors) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if _storage._type != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 2)
      }
      if _storage._state != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 3)
      }
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._details {
      case .riskDetails?: try {
        guard case .riskDetails(let v)? = _storage._details else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .inspectDetails?: try {
        guard case .inspectDetails(let v)? = _storage._details else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case nil: break
      }
      if let v = _storage._createTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._startTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._endTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if !_storage._jobTriggerName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._jobTriggerName, fieldNumber: 10)
      }
      if !_storage._errors.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._errors, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_DlpJob, rhs: Google_Privacy_Dlp_V2_DlpJob) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._details != rhs_storage._details {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._startTime != rhs_storage._startTime {return false}
        if _storage._endTime != rhs_storage._endTime {return false}
        if _storage._jobTriggerName != rhs_storage._jobTriggerName {return false}
        if _storage._errors != rhs_storage._errors {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_DlpJob.JobState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "JOB_STATE_UNSPECIFIED"),
    1: .same(proto: "PENDING"),
    2: .same(proto: "RUNNING"),
    3: .same(proto: "DONE"),
    4: .same(proto: "CANCELED"),
    5: .same(proto: "FAILED"),
    6: .same(proto: "ACTIVE"),
  ]
}

extension Google_Privacy_Dlp_V2_GetDlpJobRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDlpJobRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_GetDlpJobRequest, rhs: Google_Privacy_Dlp_V2_GetDlpJobRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_ListDlpJobsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListDlpJobsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .same(proto: "parent"),
    1: .same(proto: "filter"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
    5: .same(proto: "type"),
    6: .standard(proto: "order_by"),
    7: .standard(proto: "location_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.orderBy) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.locationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 4)
    }
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 5)
    }
    if !self.orderBy.isEmpty {
      try visitor.visitSingularStringField(value: self.orderBy, fieldNumber: 6)
    }
    if !self.locationID.isEmpty {
      try visitor.visitSingularStringField(value: self.locationID, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_ListDlpJobsRequest, rhs: Google_Privacy_Dlp_V2_ListDlpJobsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.type != rhs.type {return false}
    if lhs.orderBy != rhs.orderBy {return false}
    if lhs.locationID != rhs.locationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_ListDlpJobsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListDlpJobsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "jobs"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.jobs) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.jobs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.jobs, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_ListDlpJobsResponse, rhs: Google_Privacy_Dlp_V2_ListDlpJobsResponse) -> Bool {
    if lhs.jobs != rhs.jobs {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_CancelDlpJobRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CancelDlpJobRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_CancelDlpJobRequest, rhs: Google_Privacy_Dlp_V2_CancelDlpJobRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_FinishDlpJobRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FinishDlpJobRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_FinishDlpJobRequest, rhs: Google_Privacy_Dlp_V2_FinishDlpJobRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_DeleteDlpJobRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteDlpJobRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_DeleteDlpJobRequest, rhs: Google_Privacy_Dlp_V2_DeleteDlpJobRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_CreateDeidentifyTemplateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateDeidentifyTemplateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "deidentify_template"),
    3: .standard(proto: "template_id"),
    4: .standard(proto: "location_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._deidentifyTemplate) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.templateID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.locationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if let v = self._deidentifyTemplate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.templateID.isEmpty {
      try visitor.visitSingularStringField(value: self.templateID, fieldNumber: 3)
    }
    if !self.locationID.isEmpty {
      try visitor.visitSingularStringField(value: self.locationID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_CreateDeidentifyTemplateRequest, rhs: Google_Privacy_Dlp_V2_CreateDeidentifyTemplateRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs._deidentifyTemplate != rhs._deidentifyTemplate {return false}
    if lhs.templateID != rhs.templateID {return false}
    if lhs.locationID != rhs.locationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_UpdateDeidentifyTemplateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateDeidentifyTemplateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "deidentify_template"),
    3: .standard(proto: "update_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._deidentifyTemplate) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._deidentifyTemplate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_UpdateDeidentifyTemplateRequest, rhs: Google_Privacy_Dlp_V2_UpdateDeidentifyTemplateRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._deidentifyTemplate != rhs._deidentifyTemplate {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_GetDeidentifyTemplateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDeidentifyTemplateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_GetDeidentifyTemplateRequest, rhs: Google_Privacy_Dlp_V2_GetDeidentifyTemplateRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_ListDeidentifyTemplatesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListDeidentifyTemplatesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_token"),
    3: .standard(proto: "page_size"),
    4: .standard(proto: "order_by"),
    5: .standard(proto: "location_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.orderBy) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.locationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    if !self.orderBy.isEmpty {
      try visitor.visitSingularStringField(value: self.orderBy, fieldNumber: 4)
    }
    if !self.locationID.isEmpty {
      try visitor.visitSingularStringField(value: self.locationID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_ListDeidentifyTemplatesRequest, rhs: Google_Privacy_Dlp_V2_ListDeidentifyTemplatesRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.orderBy != rhs.orderBy {return false}
    if lhs.locationID != rhs.locationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_ListDeidentifyTemplatesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListDeidentifyTemplatesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "deidentify_templates"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.deidentifyTemplates) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deidentifyTemplates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.deidentifyTemplates, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_ListDeidentifyTemplatesResponse, rhs: Google_Privacy_Dlp_V2_ListDeidentifyTemplatesResponse) -> Bool {
    if lhs.deidentifyTemplates != rhs.deidentifyTemplates {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_DeleteDeidentifyTemplateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteDeidentifyTemplateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_DeleteDeidentifyTemplateRequest, rhs: Google_Privacy_Dlp_V2_DeleteDeidentifyTemplateRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_LargeCustomDictionaryConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LargeCustomDictionaryConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "output_path"),
    2: .standard(proto: "cloud_storage_file_set"),
    3: .standard(proto: "big_query_field"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._outputPath) }()
      case 2: try {
        var v: Google_Privacy_Dlp_V2_CloudStorageFileSet?
        if let current = self.source {
          try decoder.handleConflictingOneOf()
          if case .cloudStorageFileSet(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.source = .cloudStorageFileSet(v)}
      }()
      case 3: try {
        var v: Google_Privacy_Dlp_V2_BigQueryField?
        if let current = self.source {
          try decoder.handleConflictingOneOf()
          if case .bigQueryField(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.source = .bigQueryField(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._outputPath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.source {
    case .cloudStorageFileSet?: try {
      guard case .cloudStorageFileSet(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .bigQueryField?: try {
      guard case .bigQueryField(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_LargeCustomDictionaryConfig, rhs: Google_Privacy_Dlp_V2_LargeCustomDictionaryConfig) -> Bool {
    if lhs._outputPath != rhs._outputPath {return false}
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_LargeCustomDictionaryStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LargeCustomDictionaryStats"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "approx_num_phrases"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.approxNumPhrases) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.approxNumPhrases != 0 {
      try visitor.visitSingularInt64Field(value: self.approxNumPhrases, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_LargeCustomDictionaryStats, rhs: Google_Privacy_Dlp_V2_LargeCustomDictionaryStats) -> Bool {
    if lhs.approxNumPhrases != rhs.approxNumPhrases {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_StoredInfoTypeConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StoredInfoTypeConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "display_name"),
    2: .same(proto: "description"),
    3: .standard(proto: "large_custom_dictionary"),
    4: .same(proto: "dictionary"),
    5: .same(proto: "regex"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try {
        var v: Google_Privacy_Dlp_V2_LargeCustomDictionaryConfig?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .largeCustomDictionary(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .largeCustomDictionary(v)}
      }()
      case 4: try {
        var v: Google_Privacy_Dlp_V2_CustomInfoType.Dictionary?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .dictionary(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .dictionary(v)}
      }()
      case 5: try {
        var v: Google_Privacy_Dlp_V2_CustomInfoType.Regex?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .regex(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .regex(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.type {
    case .largeCustomDictionary?: try {
      guard case .largeCustomDictionary(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .dictionary?: try {
      guard case .dictionary(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .regex?: try {
      guard case .regex(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_StoredInfoTypeConfig, rhs: Google_Privacy_Dlp_V2_StoredInfoTypeConfig) -> Bool {
    if lhs.displayName != rhs.displayName {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_StoredInfoTypeStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StoredInfoTypeStats"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "large_custom_dictionary"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Privacy_Dlp_V2_LargeCustomDictionaryStats?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .largeCustomDictionary(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .largeCustomDictionary(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .largeCustomDictionary(let v)? = self.type {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_StoredInfoTypeStats, rhs: Google_Privacy_Dlp_V2_StoredInfoTypeStats) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_StoredInfoTypeVersion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StoredInfoTypeVersion"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "config"),
    2: .standard(proto: "create_time"),
    3: .same(proto: "state"),
    4: .same(proto: "errors"),
    5: .same(proto: "stats"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._config) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.errors) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._stats) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 3)
    }
    if !self.errors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errors, fieldNumber: 4)
    }
    if let v = self._stats {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_StoredInfoTypeVersion, rhs: Google_Privacy_Dlp_V2_StoredInfoTypeVersion) -> Bool {
    if lhs._config != rhs._config {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs.state != rhs.state {return false}
    if lhs.errors != rhs.errors {return false}
    if lhs._stats != rhs._stats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_StoredInfoType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StoredInfoType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "current_version"),
    3: .standard(proto: "pending_versions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._currentVersion) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.pendingVersions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._currentVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.pendingVersions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pendingVersions, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_StoredInfoType, rhs: Google_Privacy_Dlp_V2_StoredInfoType) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._currentVersion != rhs._currentVersion {return false}
    if lhs.pendingVersions != rhs.pendingVersions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_CreateStoredInfoTypeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateStoredInfoTypeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "config"),
    3: .standard(proto: "stored_info_type_id"),
    4: .standard(proto: "location_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._config) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.storedInfoTypeID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.locationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if let v = self._config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.storedInfoTypeID.isEmpty {
      try visitor.visitSingularStringField(value: self.storedInfoTypeID, fieldNumber: 3)
    }
    if !self.locationID.isEmpty {
      try visitor.visitSingularStringField(value: self.locationID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_CreateStoredInfoTypeRequest, rhs: Google_Privacy_Dlp_V2_CreateStoredInfoTypeRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs._config != rhs._config {return false}
    if lhs.storedInfoTypeID != rhs.storedInfoTypeID {return false}
    if lhs.locationID != rhs.locationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_UpdateStoredInfoTypeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStoredInfoTypeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "config"),
    3: .standard(proto: "update_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._config) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_UpdateStoredInfoTypeRequest, rhs: Google_Privacy_Dlp_V2_UpdateStoredInfoTypeRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._config != rhs._config {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_GetStoredInfoTypeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoredInfoTypeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_GetStoredInfoTypeRequest, rhs: Google_Privacy_Dlp_V2_GetStoredInfoTypeRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_ListStoredInfoTypesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListStoredInfoTypesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_token"),
    3: .standard(proto: "page_size"),
    4: .standard(proto: "order_by"),
    5: .standard(proto: "location_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.orderBy) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.locationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    if !self.orderBy.isEmpty {
      try visitor.visitSingularStringField(value: self.orderBy, fieldNumber: 4)
    }
    if !self.locationID.isEmpty {
      try visitor.visitSingularStringField(value: self.locationID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_ListStoredInfoTypesRequest, rhs: Google_Privacy_Dlp_V2_ListStoredInfoTypesRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.orderBy != rhs.orderBy {return false}
    if lhs.locationID != rhs.locationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_ListStoredInfoTypesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListStoredInfoTypesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stored_info_types"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.storedInfoTypes) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.storedInfoTypes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.storedInfoTypes, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_ListStoredInfoTypesResponse, rhs: Google_Privacy_Dlp_V2_ListStoredInfoTypesResponse) -> Bool {
    if lhs.storedInfoTypes != rhs.storedInfoTypes {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_DeleteStoredInfoTypeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteStoredInfoTypeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_DeleteStoredInfoTypeRequest, rhs: Google_Privacy_Dlp_V2_DeleteStoredInfoTypeRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_HybridInspectJobTriggerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HybridInspectJobTriggerRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    3: .standard(proto: "hybrid_item"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._hybridItem) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._hybridItem {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_HybridInspectJobTriggerRequest, rhs: Google_Privacy_Dlp_V2_HybridInspectJobTriggerRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._hybridItem != rhs._hybridItem {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_HybridInspectDlpJobRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HybridInspectDlpJobRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    3: .standard(proto: "hybrid_item"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._hybridItem) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._hybridItem {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_HybridInspectDlpJobRequest, rhs: Google_Privacy_Dlp_V2_HybridInspectDlpJobRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._hybridItem != rhs._hybridItem {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_HybridContentItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HybridContentItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "item"),
    2: .standard(proto: "finding_details"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._item) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._findingDetails) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._item {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._findingDetails {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_HybridContentItem, rhs: Google_Privacy_Dlp_V2_HybridContentItem) -> Bool {
    if lhs._item != rhs._item {return false}
    if lhs._findingDetails != rhs._findingDetails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_HybridFindingDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HybridFindingDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "container_details"),
    2: .standard(proto: "file_offset"),
    3: .standard(proto: "row_offset"),
    4: .standard(proto: "table_options"),
    5: .same(proto: "labels"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._containerDetails) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.fileOffset) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.rowOffset) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._tableOptions) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._containerDetails {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.fileOffset != 0 {
      try visitor.visitSingularInt64Field(value: self.fileOffset, fieldNumber: 2)
    }
    if self.rowOffset != 0 {
      try visitor.visitSingularInt64Field(value: self.rowOffset, fieldNumber: 3)
    }
    if let v = self._tableOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_HybridFindingDetails, rhs: Google_Privacy_Dlp_V2_HybridFindingDetails) -> Bool {
    if lhs._containerDetails != rhs._containerDetails {return false}
    if lhs.fileOffset != rhs.fileOffset {return false}
    if lhs.rowOffset != rhs.rowOffset {return false}
    if lhs._tableOptions != rhs._tableOptions {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_HybridInspectResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HybridInspectResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_HybridInspectResponse, rhs: Google_Privacy_Dlp_V2_HybridInspectResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

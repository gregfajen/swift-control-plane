// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/privacy/dlp/v2/storage.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Categorization of results based on how likely they are to represent a match,
/// based on the number of elements they contain which imply a match.
public enum Google_Privacy_Dlp_V2_Likelihood: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Default value; same as POSSIBLE.
  case unspecified // = 0

  /// Few matching elements.
  case veryUnlikely // = 1
  case unlikely // = 2

  /// Some matching elements.
  case possible // = 3
  case likely // = 4

  /// Many matching elements.
  case veryLikely // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .veryUnlikely
    case 2: self = .unlikely
    case 3: self = .possible
    case 4: self = .likely
    case 5: self = .veryLikely
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .veryUnlikely: return 1
    case .unlikely: return 2
    case .possible: return 3
    case .likely: return 4
    case .veryLikely: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Privacy_Dlp_V2_Likelihood: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Privacy_Dlp_V2_Likelihood] = [
    .unspecified,
    .veryUnlikely,
    .unlikely,
    .possible,
    .likely,
    .veryLikely,
  ]
}

#endif  // swift(>=4.2)

/// Definitions of file type groups to scan. New types will be added to this
/// list.
public enum Google_Privacy_Dlp_V2_FileType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Includes all files.
  case unspecified // = 0

  /// Includes all file extensions not covered by another entry. Binary
  /// scanning attempts to convert the content of the file to utf_8 to scan
  /// the file.
  /// If you wish to avoid this fall back, specify one or more of the other
  /// FileType's in your storage scan.
  case binaryFile // = 1

  /// Included file extensions:
  ///   asc, brf, c, cc, cpp, csv, cxx, c++, cs, css, dart, eml, go, h, hh, hpp,
  ///   hxx, h++, hs, html, htm, shtml, shtm, xhtml, lhs, ini, java, js, json,
  ///   ocaml, md, mkd, markdown, m, ml, mli, pl, pm, php, phtml, pht, py, pyw,
  ///   rb, rbw, rs, rc, scala, sh, sql, tex, txt, text, tsv, vcard, vcs, wml,
  ///   xml, xsl, xsd, yml, yaml.
  case textFile // = 2

  /// Included file extensions:
  ///   bmp, gif, jpg, jpeg, jpe, png.
  /// bytes_limit_per_file has no effect on image files.
  /// Image inspection is restricted to 'global', 'us', 'asia', and 'europe'.
  case image // = 3

  /// Word files >30 MB will be scanned as binary files.
  /// Included file extensions:
  ///   docx, dotx, docm, dotm
  case word // = 5

  /// PDF files >30 MB will be scanned as binary files.
  /// Included file extensions:
  ///   pdf
  case pdf // = 6

  /// Included file extensions:
  ///   avro
  case avro // = 7

  /// Included file extensions:
  ///   csv
  case csv // = 8

  /// Included file extensions:
  ///   tsv
  case tsv // = 9
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .binaryFile
    case 2: self = .textFile
    case 3: self = .image
    case 5: self = .word
    case 6: self = .pdf
    case 7: self = .avro
    case 8: self = .csv
    case 9: self = .tsv
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .binaryFile: return 1
    case .textFile: return 2
    case .image: return 3
    case .word: return 5
    case .pdf: return 6
    case .avro: return 7
    case .csv: return 8
    case .tsv: return 9
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Privacy_Dlp_V2_FileType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Privacy_Dlp_V2_FileType] = [
    .unspecified,
    .binaryFile,
    .textFile,
    .image,
    .word,
    .pdf,
    .avro,
    .csv,
    .tsv,
  ]
}

#endif  // swift(>=4.2)

/// Type of information detected by the API.
public struct Google_Privacy_Dlp_V2_InfoType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the information type. Either a name of your choosing when
  /// creating a CustomInfoType, or one of the names listed
  /// at https://cloud.google.com/dlp/docs/infotypes-reference when specifying
  /// a built-in type.  When sending Cloud DLP results to Data Catalog, infoType
  /// names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A reference to a StoredInfoType to use with scanning.
public struct Google_Privacy_Dlp_V2_StoredType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Resource name of the requested `StoredInfoType`, for example
  /// `organizations/433245324/storedInfoTypes/432452342` or
  /// `projects/project-id/storedInfoTypes/432452342`.
  public var name: String = String()

  /// Timestamp indicating when the version of the `StoredInfoType` used for
  /// inspection was created. Output-only field, populated by the system.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {self._createTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Custom information type provided by the user. Used to find domain-specific
/// sensitive information configurable to the data in question.
public struct Google_Privacy_Dlp_V2_CustomInfoType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// CustomInfoType can either be a new infoType, or an extension of built-in
  /// infoType, when the name matches one of existing infoTypes and that infoType
  /// is specified in `InspectContent.info_types` field. Specifying the latter
  /// adds findings to the one detected by the system. If built-in info type is
  /// not specified in `InspectContent.info_types` list then the name is treated
  /// as a custom info type.
  public var infoType: Google_Privacy_Dlp_V2_InfoType {
    get {return _infoType ?? Google_Privacy_Dlp_V2_InfoType()}
    set {_infoType = newValue}
  }
  /// Returns true if `infoType` has been explicitly set.
  public var hasInfoType: Bool {return self._infoType != nil}
  /// Clears the value of `infoType`. Subsequent reads from it will return its default value.
  public mutating func clearInfoType() {self._infoType = nil}

  /// Likelihood to return for this CustomInfoType. This base value can be
  /// altered by a detection rule if the finding meets the criteria specified by
  /// the rule. Defaults to `VERY_LIKELY` if not specified.
  public var likelihood: Google_Privacy_Dlp_V2_Likelihood = .unspecified

  public var type: Google_Privacy_Dlp_V2_CustomInfoType.OneOf_Type? = nil

  /// A list of phrases to detect as a CustomInfoType.
  public var dictionary: Google_Privacy_Dlp_V2_CustomInfoType.Dictionary {
    get {
      if case .dictionary(let v)? = type {return v}
      return Google_Privacy_Dlp_V2_CustomInfoType.Dictionary()
    }
    set {type = .dictionary(newValue)}
  }

  /// Regular expression based CustomInfoType.
  public var regex: Google_Privacy_Dlp_V2_CustomInfoType.Regex {
    get {
      if case .regex(let v)? = type {return v}
      return Google_Privacy_Dlp_V2_CustomInfoType.Regex()
    }
    set {type = .regex(newValue)}
  }

  /// Message for detecting output from deidentification transformations that
  /// support reversing.
  public var surrogateType: Google_Privacy_Dlp_V2_CustomInfoType.SurrogateType {
    get {
      if case .surrogateType(let v)? = type {return v}
      return Google_Privacy_Dlp_V2_CustomInfoType.SurrogateType()
    }
    set {type = .surrogateType(newValue)}
  }

  /// Load an existing `StoredInfoType` resource for use in
  /// `InspectDataSource`. Not currently supported in `InspectContent`.
  public var storedType: Google_Privacy_Dlp_V2_StoredType {
    get {
      if case .storedType(let v)? = type {return v}
      return Google_Privacy_Dlp_V2_StoredType()
    }
    set {type = .storedType(newValue)}
  }

  /// Set of detection rules to apply to all findings of this CustomInfoType.
  /// Rules are applied in order that they are specified. Not supported for the
  /// `surrogate_type` CustomInfoType.
  public var detectionRules: [Google_Privacy_Dlp_V2_CustomInfoType.DetectionRule] = []

  /// If set to EXCLUSION_TYPE_EXCLUDE this infoType will not cause a finding
  /// to be returned. It still can be used for rules matching.
  public var exclusionType: Google_Privacy_Dlp_V2_CustomInfoType.ExclusionType = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable {
    /// A list of phrases to detect as a CustomInfoType.
    case dictionary(Google_Privacy_Dlp_V2_CustomInfoType.Dictionary)
    /// Regular expression based CustomInfoType.
    case regex(Google_Privacy_Dlp_V2_CustomInfoType.Regex)
    /// Message for detecting output from deidentification transformations that
    /// support reversing.
    case surrogateType(Google_Privacy_Dlp_V2_CustomInfoType.SurrogateType)
    /// Load an existing `StoredInfoType` resource for use in
    /// `InspectDataSource`. Not currently supported in `InspectContent`.
    case storedType(Google_Privacy_Dlp_V2_StoredType)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Privacy_Dlp_V2_CustomInfoType.OneOf_Type, rhs: Google_Privacy_Dlp_V2_CustomInfoType.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.dictionary, .dictionary): return {
        guard case .dictionary(let l) = lhs, case .dictionary(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.regex, .regex): return {
        guard case .regex(let l) = lhs, case .regex(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.surrogateType, .surrogateType): return {
        guard case .surrogateType(let l) = lhs, case .surrogateType(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storedType, .storedType): return {
        guard case .storedType(let l) = lhs, case .storedType(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum ExclusionType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// A finding of this custom info type will not be excluded from results.
    case unspecified // = 0

    /// A finding of this custom info type will be excluded from final results,
    /// but can still affect rule execution.
    case exclude // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .exclude
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .exclude: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Custom information type based on a dictionary of words or phrases. This can
  /// be used to match sensitive information specific to the data, such as a list
  /// of employee IDs or job titles.
  ///
  /// Dictionary words are case-insensitive and all characters other than letters
  /// and digits in the unicode [Basic Multilingual
  /// Plane](https://en.wikipedia.org/wiki/Plane_%28Unicode%29#Basic_Multilingual_Plane)
  /// will be replaced with whitespace when scanning for matches, so the
  /// dictionary phrase "Sam Johnson" will match all three phrases "sam johnson",
  /// "Sam, Johnson", and "Sam (Johnson)". Additionally, the characters
  /// surrounding any match must be of a different type than the adjacent
  /// characters within the word, so letters must be next to non-letters and
  /// digits next to non-digits. For example, the dictionary word "jen" will
  /// match the first three letters of the text "jen123" but will return no
  /// matches for "jennifer".
  ///
  /// Dictionary words containing a large number of characters that are not
  /// letters or digits may result in unexpected findings because such characters
  /// are treated as whitespace. The
  /// [limits](https://cloud.google.com/dlp/limits) page contains details about
  /// the size limits of dictionaries. For dictionaries that do not fit within
  /// these constraints, consider using `LargeCustomDictionaryConfig` in the
  /// `StoredInfoType` API.
  public struct Dictionary {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var source: Google_Privacy_Dlp_V2_CustomInfoType.Dictionary.OneOf_Source? = nil

    /// List of words or phrases to search for.
    public var wordList: Google_Privacy_Dlp_V2_CustomInfoType.Dictionary.WordList {
      get {
        if case .wordList(let v)? = source {return v}
        return Google_Privacy_Dlp_V2_CustomInfoType.Dictionary.WordList()
      }
      set {source = .wordList(newValue)}
    }

    /// Newline-delimited file of words in Cloud Storage. Only a single file
    /// is accepted.
    public var cloudStoragePath: Google_Privacy_Dlp_V2_CloudStoragePath {
      get {
        if case .cloudStoragePath(let v)? = source {return v}
        return Google_Privacy_Dlp_V2_CloudStoragePath()
      }
      set {source = .cloudStoragePath(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Source: Equatable {
      /// List of words or phrases to search for.
      case wordList(Google_Privacy_Dlp_V2_CustomInfoType.Dictionary.WordList)
      /// Newline-delimited file of words in Cloud Storage. Only a single file
      /// is accepted.
      case cloudStoragePath(Google_Privacy_Dlp_V2_CloudStoragePath)

    #if !swift(>=4.1)
      public static func ==(lhs: Google_Privacy_Dlp_V2_CustomInfoType.Dictionary.OneOf_Source, rhs: Google_Privacy_Dlp_V2_CustomInfoType.Dictionary.OneOf_Source) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.wordList, .wordList): return {
          guard case .wordList(let l) = lhs, case .wordList(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.cloudStoragePath, .cloudStoragePath): return {
          guard case .cloudStoragePath(let l) = lhs, case .cloudStoragePath(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    /// Message defining a list of words or phrases to search for in the data.
    public struct WordList {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Words or phrases defining the dictionary. The dictionary must contain
      /// at least one phrase and every phrase must contain at least 2 characters
      /// that are letters or digits. [required]
      public var words: [String] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  /// Message defining a custom regular expression.
  public struct Regex {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Pattern defining the regular expression. Its syntax
    /// (https://github.com/google/re2/wiki/Syntax) can be found under the
    /// google/re2 repository on GitHub.
    public var pattern: String = String()

    /// The index of the submatch to extract as findings. When not
    /// specified, the entire match is returned. No more than 3 may be included.
    public var groupIndexes: [Int32] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Message for detecting output from deidentification transformations
  /// such as
  /// [`CryptoReplaceFfxFpeConfig`](https://cloud.google.com/dlp/docs/reference/rest/v2/organizations.deidentifyTemplates#cryptoreplaceffxfpeconfig).
  /// These types of transformations are
  /// those that perform pseudonymization, thereby producing a "surrogate" as
  /// output. This should be used in conjunction with a field on the
  /// transformation such as `surrogate_info_type`. This CustomInfoType does
  /// not support the use of `detection_rules`.
  public struct SurrogateType {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Deprecated; use `InspectionRuleSet` instead. Rule for modifying a
  /// `CustomInfoType` to alter behavior under certain circumstances, depending
  /// on the specific details of the rule. Not supported for the `surrogate_type`
  /// custom infoType.
  public struct DetectionRule {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var type: Google_Privacy_Dlp_V2_CustomInfoType.DetectionRule.OneOf_Type? = nil

    /// Hotword-based detection rule.
    public var hotwordRule: Google_Privacy_Dlp_V2_CustomInfoType.DetectionRule.HotwordRule {
      get {
        if case .hotwordRule(let v)? = type {return v}
        return Google_Privacy_Dlp_V2_CustomInfoType.DetectionRule.HotwordRule()
      }
      set {type = .hotwordRule(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Type: Equatable {
      /// Hotword-based detection rule.
      case hotwordRule(Google_Privacy_Dlp_V2_CustomInfoType.DetectionRule.HotwordRule)

    #if !swift(>=4.1)
      public static func ==(lhs: Google_Privacy_Dlp_V2_CustomInfoType.DetectionRule.OneOf_Type, rhs: Google_Privacy_Dlp_V2_CustomInfoType.DetectionRule.OneOf_Type) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.hotwordRule, .hotwordRule): return {
          guard case .hotwordRule(let l) = lhs, case .hotwordRule(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        }
      }
    #endif
    }

    /// Message for specifying a window around a finding to apply a detection
    /// rule.
    public struct Proximity {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Number of characters before the finding to consider.
      public var windowBefore: Int32 = 0

      /// Number of characters after the finding to consider.
      public var windowAfter: Int32 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// Message for specifying an adjustment to the likelihood of a finding as
    /// part of a detection rule.
    public struct LikelihoodAdjustment {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var adjustment: Google_Privacy_Dlp_V2_CustomInfoType.DetectionRule.LikelihoodAdjustment.OneOf_Adjustment? = nil

      /// Set the likelihood of a finding to a fixed value.
      public var fixedLikelihood: Google_Privacy_Dlp_V2_Likelihood {
        get {
          if case .fixedLikelihood(let v)? = adjustment {return v}
          return .unspecified
        }
        set {adjustment = .fixedLikelihood(newValue)}
      }

      /// Increase or decrease the likelihood by the specified number of
      /// levels. For example, if a finding would be `POSSIBLE` without the
      /// detection rule and `relative_likelihood` is 1, then it is upgraded to
      /// `LIKELY`, while a value of -1 would downgrade it to `UNLIKELY`.
      /// Likelihood may never drop below `VERY_UNLIKELY` or exceed
      /// `VERY_LIKELY`, so applying an adjustment of 1 followed by an
      /// adjustment of -1 when base likelihood is `VERY_LIKELY` will result in
      /// a final likelihood of `LIKELY`.
      public var relativeLikelihood: Int32 {
        get {
          if case .relativeLikelihood(let v)? = adjustment {return v}
          return 0
        }
        set {adjustment = .relativeLikelihood(newValue)}
      }

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum OneOf_Adjustment: Equatable {
        /// Set the likelihood of a finding to a fixed value.
        case fixedLikelihood(Google_Privacy_Dlp_V2_Likelihood)
        /// Increase or decrease the likelihood by the specified number of
        /// levels. For example, if a finding would be `POSSIBLE` without the
        /// detection rule and `relative_likelihood` is 1, then it is upgraded to
        /// `LIKELY`, while a value of -1 would downgrade it to `UNLIKELY`.
        /// Likelihood may never drop below `VERY_UNLIKELY` or exceed
        /// `VERY_LIKELY`, so applying an adjustment of 1 followed by an
        /// adjustment of -1 when base likelihood is `VERY_LIKELY` will result in
        /// a final likelihood of `LIKELY`.
        case relativeLikelihood(Int32)

      #if !swift(>=4.1)
        public static func ==(lhs: Google_Privacy_Dlp_V2_CustomInfoType.DetectionRule.LikelihoodAdjustment.OneOf_Adjustment, rhs: Google_Privacy_Dlp_V2_CustomInfoType.DetectionRule.LikelihoodAdjustment.OneOf_Adjustment) -> Bool {
          // The use of inline closures is to circumvent an issue where the compiler
          // allocates stack space for every case branch when no optimizations are
          // enabled. https://github.com/apple/swift-protobuf/issues/1034
          switch (lhs, rhs) {
          case (.fixedLikelihood, .fixedLikelihood): return {
            guard case .fixedLikelihood(let l) = lhs, case .fixedLikelihood(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.relativeLikelihood, .relativeLikelihood): return {
            guard case .relativeLikelihood(let l) = lhs, case .relativeLikelihood(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          default: return false
          }
        }
      #endif
      }

      public init() {}
    }

    /// The rule that adjusts the likelihood of findings within a certain
    /// proximity of hotwords.
    public struct HotwordRule {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Regular expression pattern defining what qualifies as a hotword.
      public var hotwordRegex: Google_Privacy_Dlp_V2_CustomInfoType.Regex {
        get {return _hotwordRegex ?? Google_Privacy_Dlp_V2_CustomInfoType.Regex()}
        set {_hotwordRegex = newValue}
      }
      /// Returns true if `hotwordRegex` has been explicitly set.
      public var hasHotwordRegex: Bool {return self._hotwordRegex != nil}
      /// Clears the value of `hotwordRegex`. Subsequent reads from it will return its default value.
      public mutating func clearHotwordRegex() {self._hotwordRegex = nil}

      /// Proximity of the finding within which the entire hotword must reside.
      /// The total length of the window cannot exceed 1000 characters. Note that
      /// the finding itself will be included in the window, so that hotwords may
      /// be used to match substrings of the finding itself. For example, the
      /// certainty of a phone number regex "\(\d{3}\) \d{3}-\d{4}" could be
      /// adjusted upwards if the area code is known to be the local area code of
      /// a company office using the hotword regex "\(xxx\)", where "xxx"
      /// is the area code in question.
      public var proximity: Google_Privacy_Dlp_V2_CustomInfoType.DetectionRule.Proximity {
        get {return _proximity ?? Google_Privacy_Dlp_V2_CustomInfoType.DetectionRule.Proximity()}
        set {_proximity = newValue}
      }
      /// Returns true if `proximity` has been explicitly set.
      public var hasProximity: Bool {return self._proximity != nil}
      /// Clears the value of `proximity`. Subsequent reads from it will return its default value.
      public mutating func clearProximity() {self._proximity = nil}

      /// Likelihood adjustment to apply to all matching findings.
      public var likelihoodAdjustment: Google_Privacy_Dlp_V2_CustomInfoType.DetectionRule.LikelihoodAdjustment {
        get {return _likelihoodAdjustment ?? Google_Privacy_Dlp_V2_CustomInfoType.DetectionRule.LikelihoodAdjustment()}
        set {_likelihoodAdjustment = newValue}
      }
      /// Returns true if `likelihoodAdjustment` has been explicitly set.
      public var hasLikelihoodAdjustment: Bool {return self._likelihoodAdjustment != nil}
      /// Clears the value of `likelihoodAdjustment`. Subsequent reads from it will return its default value.
      public mutating func clearLikelihoodAdjustment() {self._likelihoodAdjustment = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _hotwordRegex: Google_Privacy_Dlp_V2_CustomInfoType.Regex? = nil
      fileprivate var _proximity: Google_Privacy_Dlp_V2_CustomInfoType.DetectionRule.Proximity? = nil
      fileprivate var _likelihoodAdjustment: Google_Privacy_Dlp_V2_CustomInfoType.DetectionRule.LikelihoodAdjustment? = nil
    }

    public init() {}
  }

  public init() {}

  fileprivate var _infoType: Google_Privacy_Dlp_V2_InfoType? = nil
}

#if swift(>=4.2)

extension Google_Privacy_Dlp_V2_CustomInfoType.ExclusionType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Privacy_Dlp_V2_CustomInfoType.ExclusionType] = [
    .unspecified,
    .exclude,
  ]
}

#endif  // swift(>=4.2)

/// General identifier of a data field in a storage service.
public struct Google_Privacy_Dlp_V2_FieldId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name describing the field.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Datastore partition ID.
/// A partition ID identifies a grouping of entities. The grouping is always
/// by project and namespace, however the namespace ID may be empty.
///
/// A partition ID contains several dimensions:
/// project ID and namespace ID.
public struct Google_Privacy_Dlp_V2_PartitionId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the project to which the entities belong.
  public var projectID: String = String()

  /// If not empty, the ID of the namespace to which the entities belong.
  public var namespaceID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A representation of a Datastore kind.
public struct Google_Privacy_Dlp_V2_KindExpression {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the kind.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Options defining a data set within Google Cloud Datastore.
public struct Google_Privacy_Dlp_V2_DatastoreOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A partition ID identifies a grouping of entities. The grouping is always
  /// by project and namespace, however the namespace ID may be empty.
  public var partitionID: Google_Privacy_Dlp_V2_PartitionId {
    get {return _partitionID ?? Google_Privacy_Dlp_V2_PartitionId()}
    set {_partitionID = newValue}
  }
  /// Returns true if `partitionID` has been explicitly set.
  public var hasPartitionID: Bool {return self._partitionID != nil}
  /// Clears the value of `partitionID`. Subsequent reads from it will return its default value.
  public mutating func clearPartitionID() {self._partitionID = nil}

  /// The kind to process.
  public var kind: Google_Privacy_Dlp_V2_KindExpression {
    get {return _kind ?? Google_Privacy_Dlp_V2_KindExpression()}
    set {_kind = newValue}
  }
  /// Returns true if `kind` has been explicitly set.
  public var hasKind: Bool {return self._kind != nil}
  /// Clears the value of `kind`. Subsequent reads from it will return its default value.
  public mutating func clearKind() {self._kind = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _partitionID: Google_Privacy_Dlp_V2_PartitionId? = nil
  fileprivate var _kind: Google_Privacy_Dlp_V2_KindExpression? = nil
}

/// Message representing a set of files in a Cloud Storage bucket. Regular
/// expressions are used to allow fine-grained control over which files in the
/// bucket to include.
///
/// Included files are those that match at least one item in `include_regex` and
/// do not match any items in `exclude_regex`. Note that a file that matches
/// items from both lists will _not_ be included. For a match to occur, the
/// entire file path (i.e., everything in the url after the bucket name) must
/// match the regular expression.
///
/// For example, given the input `{bucket_name: "mybucket", include_regex:
/// ["directory1/.*"], exclude_regex:
/// ["directory1/excluded.*"]}`:
///
/// * `gs://mybucket/directory1/myfile` will be included
/// * `gs://mybucket/directory1/directory2/myfile` will be included (`.*` matches
/// across `/`)
/// * `gs://mybucket/directory0/directory1/myfile` will _not_ be included (the
/// full path doesn't match any items in `include_regex`)
/// * `gs://mybucket/directory1/excludedfile` will _not_ be included (the path
/// matches an item in `exclude_regex`)
///
/// If `include_regex` is left empty, it will match all files by default
/// (this is equivalent to setting `include_regex: [".*"]`).
///
/// Some other common use cases:
///
/// * `{bucket_name: "mybucket", exclude_regex: [".*\.pdf"]}` will include all
/// files in `mybucket` except for .pdf files
/// * `{bucket_name: "mybucket", include_regex: ["directory/[^/]+"]}` will
/// include all files directly under `gs://mybucket/directory/`, without matching
/// across `/`
public struct Google_Privacy_Dlp_V2_CloudStorageRegexFileSet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of a Cloud Storage bucket. Required.
  public var bucketName: String = String()

  /// A list of regular expressions matching file paths to include. All files in
  /// the bucket that match at least one of these regular expressions will be
  /// included in the set of files, except for those that also match an item in
  /// `exclude_regex`. Leaving this field empty will match all files by default
  /// (this is equivalent to including `.*` in the list).
  ///
  /// Regular expressions use RE2
  /// [syntax](https://github.com/google/re2/wiki/Syntax); a guide can be found
  /// under the google/re2 repository on GitHub.
  public var includeRegex: [String] = []

  /// A list of regular expressions matching file paths to exclude. All files in
  /// the bucket that match at least one of these regular expressions will be
  /// excluded from the scan.
  ///
  /// Regular expressions use RE2
  /// [syntax](https://github.com/google/re2/wiki/Syntax); a guide can be found
  /// under the google/re2 repository on GitHub.
  public var excludeRegex: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Options defining a file or a set of files within a Google Cloud Storage
/// bucket.
public struct Google_Privacy_Dlp_V2_CloudStorageOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The set of one or more files to scan.
  public var fileSet: Google_Privacy_Dlp_V2_CloudStorageOptions.FileSet {
    get {return _fileSet ?? Google_Privacy_Dlp_V2_CloudStorageOptions.FileSet()}
    set {_fileSet = newValue}
  }
  /// Returns true if `fileSet` has been explicitly set.
  public var hasFileSet: Bool {return self._fileSet != nil}
  /// Clears the value of `fileSet`. Subsequent reads from it will return its default value.
  public mutating func clearFileSet() {self._fileSet = nil}

  /// Max number of bytes to scan from a file. If a scanned file's size is bigger
  /// than this value then the rest of the bytes are omitted. Only one
  /// of bytes_limit_per_file and bytes_limit_per_file_percent can be specified.
  public var bytesLimitPerFile: Int64 = 0

  /// Max percentage of bytes to scan from a file. The rest are omitted. The
  /// number of bytes scanned is rounded down. Must be between 0 and 100,
  /// inclusively. Both 0 and 100 means no limit. Defaults to 0. Only one
  /// of bytes_limit_per_file and bytes_limit_per_file_percent can be specified.
  public var bytesLimitPerFilePercent: Int32 = 0

  /// List of file type groups to include in the scan.
  /// If empty, all files are scanned and available data format processors
  /// are applied. In addition, the binary content of the selected files
  /// is always scanned as well.
  /// Images are scanned only as binary if the specified region
  /// does not support image inspection and no file_types were specified.
  /// Image inspection is restricted to 'global', 'us', 'asia', and 'europe'.
  public var fileTypes: [Google_Privacy_Dlp_V2_FileType] = []

  public var sampleMethod: Google_Privacy_Dlp_V2_CloudStorageOptions.SampleMethod = .unspecified

  /// Limits the number of files to scan to this percentage of the input FileSet.
  /// Number of files scanned is rounded down. Must be between 0 and 100,
  /// inclusively. Both 0 and 100 means no limit. Defaults to 0.
  public var filesLimitPercent: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// How to sample bytes if not all bytes are scanned. Meaningful only when used
  /// in conjunction with bytes_limit_per_file. If not specified, scanning would
  /// start from the top.
  public enum SampleMethod: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unspecified // = 0

    /// Scan from the top (default).
    case top // = 1

    /// For each file larger than bytes_limit_per_file, randomly pick the offset
    /// to start scanning. The scanned bytes are contiguous.
    case randomStart // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .top
      case 2: self = .randomStart
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .top: return 1
      case .randomStart: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Set of files to scan.
  public struct FileSet {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The Cloud Storage url of the file(s) to scan, in the format
    /// `gs://<bucket>/<path>`. Trailing wildcard in the path is allowed.
    ///
    /// If the url ends in a trailing slash, the bucket or directory represented
    /// by the url will be scanned non-recursively (content in sub-directories
    /// will not be scanned). This means that `gs://mybucket/` is equivalent to
    /// `gs://mybucket/*`, and `gs://mybucket/directory/` is equivalent to
    /// `gs://mybucket/directory/*`.
    ///
    /// Exactly one of `url` or `regex_file_set` must be set.
    public var url: String = String()

    /// The regex-filtered set of files to scan. Exactly one of `url` or
    /// `regex_file_set` must be set.
    public var regexFileSet: Google_Privacy_Dlp_V2_CloudStorageRegexFileSet {
      get {return _regexFileSet ?? Google_Privacy_Dlp_V2_CloudStorageRegexFileSet()}
      set {_regexFileSet = newValue}
    }
    /// Returns true if `regexFileSet` has been explicitly set.
    public var hasRegexFileSet: Bool {return self._regexFileSet != nil}
    /// Clears the value of `regexFileSet`. Subsequent reads from it will return its default value.
    public mutating func clearRegexFileSet() {self._regexFileSet = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _regexFileSet: Google_Privacy_Dlp_V2_CloudStorageRegexFileSet? = nil
  }

  public init() {}

  fileprivate var _fileSet: Google_Privacy_Dlp_V2_CloudStorageOptions.FileSet? = nil
}

#if swift(>=4.2)

extension Google_Privacy_Dlp_V2_CloudStorageOptions.SampleMethod: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Privacy_Dlp_V2_CloudStorageOptions.SampleMethod] = [
    .unspecified,
    .top,
    .randomStart,
  ]
}

#endif  // swift(>=4.2)

/// Message representing a set of files in Cloud Storage.
public struct Google_Privacy_Dlp_V2_CloudStorageFileSet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The url, in the format `gs://<bucket>/<path>`. Trailing wildcard in the
  /// path is allowed.
  public var url: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message representing a single file or path in Cloud Storage.
public struct Google_Privacy_Dlp_V2_CloudStoragePath {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A url representing a file or path (no wildcards) in Cloud Storage.
  /// Example: gs://[BUCKET_NAME]/dictionary.txt
  public var path: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Options defining BigQuery table and row identifiers.
public struct Google_Privacy_Dlp_V2_BigQueryOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Complete BigQuery table reference.
  public var tableReference: Google_Privacy_Dlp_V2_BigQueryTable {
    get {return _tableReference ?? Google_Privacy_Dlp_V2_BigQueryTable()}
    set {_tableReference = newValue}
  }
  /// Returns true if `tableReference` has been explicitly set.
  public var hasTableReference: Bool {return self._tableReference != nil}
  /// Clears the value of `tableReference`. Subsequent reads from it will return its default value.
  public mutating func clearTableReference() {self._tableReference = nil}

  /// Table fields that may uniquely identify a row within the table. When
  /// `actions.saveFindings.outputConfig.table` is specified, the values of
  /// columns specified here are available in the output table under
  /// `location.content_locations.record_location.record_key.id_values`. Nested
  /// fields such as `person.birthdate.year` are allowed.
  public var identifyingFields: [Google_Privacy_Dlp_V2_FieldId] = []

  /// Max number of rows to scan. If the table has more rows than this value, the
  /// rest of the rows are omitted. If not set, or if set to 0, all rows will be
  /// scanned. Only one of rows_limit and rows_limit_percent can be specified.
  /// Cannot be used in conjunction with TimespanConfig.
  public var rowsLimit: Int64 = 0

  /// Max percentage of rows to scan. The rest are omitted. The number of rows
  /// scanned is rounded down. Must be between 0 and 100, inclusively. Both 0 and
  /// 100 means no limit. Defaults to 0. Only one of rows_limit and
  /// rows_limit_percent can be specified. Cannot be used in conjunction with
  /// TimespanConfig.
  public var rowsLimitPercent: Int32 = 0

  public var sampleMethod: Google_Privacy_Dlp_V2_BigQueryOptions.SampleMethod = .unspecified

  /// References to fields excluded from scanning. This allows you to skip
  /// inspection of entire columns which you know have no findings.
  public var excludedFields: [Google_Privacy_Dlp_V2_FieldId] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// How to sample rows if not all rows are scanned. Meaningful only when used
  /// in conjunction with either rows_limit or rows_limit_percent. If not
  /// specified, rows are scanned in the order BigQuery reads them.
  public enum SampleMethod: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unspecified // = 0

    /// Scan groups of rows in the order BigQuery provides (default). Multiple
    /// groups of rows may be scanned in parallel, so results may not appear in
    /// the same order the rows are read.
    case top // = 1

    /// Randomly pick groups of rows to scan.
    case randomStart // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .top
      case 2: self = .randomStart
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .top: return 1
      case .randomStart: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _tableReference: Google_Privacy_Dlp_V2_BigQueryTable? = nil
}

#if swift(>=4.2)

extension Google_Privacy_Dlp_V2_BigQueryOptions.SampleMethod: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Privacy_Dlp_V2_BigQueryOptions.SampleMethod] = [
    .unspecified,
    .top,
    .randomStart,
  ]
}

#endif  // swift(>=4.2)

/// Shared message indicating Cloud storage type.
public struct Google_Privacy_Dlp_V2_StorageConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Google_Privacy_Dlp_V2_StorageConfig.OneOf_Type? = nil

  /// Google Cloud Datastore options.
  public var datastoreOptions: Google_Privacy_Dlp_V2_DatastoreOptions {
    get {
      if case .datastoreOptions(let v)? = type {return v}
      return Google_Privacy_Dlp_V2_DatastoreOptions()
    }
    set {type = .datastoreOptions(newValue)}
  }

  /// Google Cloud Storage options.
  public var cloudStorageOptions: Google_Privacy_Dlp_V2_CloudStorageOptions {
    get {
      if case .cloudStorageOptions(let v)? = type {return v}
      return Google_Privacy_Dlp_V2_CloudStorageOptions()
    }
    set {type = .cloudStorageOptions(newValue)}
  }

  /// BigQuery options.
  public var bigQueryOptions: Google_Privacy_Dlp_V2_BigQueryOptions {
    get {
      if case .bigQueryOptions(let v)? = type {return v}
      return Google_Privacy_Dlp_V2_BigQueryOptions()
    }
    set {type = .bigQueryOptions(newValue)}
  }

  /// Hybrid inspection options.
  /// Early access feature is in a pre-release state and might change or have
  /// limited support. For more information, see
  /// https://cloud.google.com/products#product-launch-stages.
  public var hybridOptions: Google_Privacy_Dlp_V2_HybridOptions {
    get {
      if case .hybridOptions(let v)? = type {return v}
      return Google_Privacy_Dlp_V2_HybridOptions()
    }
    set {type = .hybridOptions(newValue)}
  }

  public var timespanConfig: Google_Privacy_Dlp_V2_StorageConfig.TimespanConfig {
    get {return _timespanConfig ?? Google_Privacy_Dlp_V2_StorageConfig.TimespanConfig()}
    set {_timespanConfig = newValue}
  }
  /// Returns true if `timespanConfig` has been explicitly set.
  public var hasTimespanConfig: Bool {return self._timespanConfig != nil}
  /// Clears the value of `timespanConfig`. Subsequent reads from it will return its default value.
  public mutating func clearTimespanConfig() {self._timespanConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable {
    /// Google Cloud Datastore options.
    case datastoreOptions(Google_Privacy_Dlp_V2_DatastoreOptions)
    /// Google Cloud Storage options.
    case cloudStorageOptions(Google_Privacy_Dlp_V2_CloudStorageOptions)
    /// BigQuery options.
    case bigQueryOptions(Google_Privacy_Dlp_V2_BigQueryOptions)
    /// Hybrid inspection options.
    /// Early access feature is in a pre-release state and might change or have
    /// limited support. For more information, see
    /// https://cloud.google.com/products#product-launch-stages.
    case hybridOptions(Google_Privacy_Dlp_V2_HybridOptions)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Privacy_Dlp_V2_StorageConfig.OneOf_Type, rhs: Google_Privacy_Dlp_V2_StorageConfig.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.datastoreOptions, .datastoreOptions): return {
        guard case .datastoreOptions(let l) = lhs, case .datastoreOptions(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cloudStorageOptions, .cloudStorageOptions): return {
        guard case .cloudStorageOptions(let l) = lhs, case .cloudStorageOptions(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bigQueryOptions, .bigQueryOptions): return {
        guard case .bigQueryOptions(let l) = lhs, case .bigQueryOptions(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hybridOptions, .hybridOptions): return {
        guard case .hybridOptions(let l) = lhs, case .hybridOptions(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Configuration of the timespan of the items to include in scanning.
  /// Currently only supported when inspecting Google Cloud Storage and BigQuery.
  public struct TimespanConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Exclude files, tables, or rows older than this value.
    /// If not set, no lower time limit is applied.
    public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_startTime = newValue}
    }
    /// Returns true if `startTime` has been explicitly set.
    public var hasStartTime: Bool {return self._startTime != nil}
    /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
    public mutating func clearStartTime() {self._startTime = nil}

    /// Exclude files, tables, or rows newer than this value.
    /// If not set, no upper time limit is applied.
    public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_endTime = newValue}
    }
    /// Returns true if `endTime` has been explicitly set.
    public var hasEndTime: Bool {return self._endTime != nil}
    /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
    public mutating func clearEndTime() {self._endTime = nil}

    /// Specification of the field containing the timestamp of scanned items.
    /// Used for data sources like Datastore and BigQuery.
    ///
    /// For BigQuery:
    /// If this value is not specified and the table was modified between the
    /// given start and end times, the entire table will be scanned. If this
    /// value is specified, then rows are filtered based on the given start and
    /// end times. Rows with a `NULL` value in the provided BigQuery column are
    /// skipped.
    /// Valid data types of the provided BigQuery column are: `INTEGER`, `DATE`,
    /// `TIMESTAMP`, and `DATETIME`.
    ///
    /// For Datastore:
    /// If this value is specified, then entities are filtered based on the given
    /// start and end times. If an entity does not contain the provided timestamp
    /// property or contains empty or invalid values, then it is included.
    /// Valid data types of the provided timestamp property are: `TIMESTAMP`.
    public var timestampField: Google_Privacy_Dlp_V2_FieldId {
      get {return _timestampField ?? Google_Privacy_Dlp_V2_FieldId()}
      set {_timestampField = newValue}
    }
    /// Returns true if `timestampField` has been explicitly set.
    public var hasTimestampField: Bool {return self._timestampField != nil}
    /// Clears the value of `timestampField`. Subsequent reads from it will return its default value.
    public mutating func clearTimestampField() {self._timestampField = nil}

    /// When the job is started by a JobTrigger we will automatically figure out
    /// a valid start_time to avoid scanning files that have not been modified
    /// since the last time the JobTrigger executed. This will be based on the
    /// time of the execution of the last run of the JobTrigger.
    public var enableAutoPopulationOfTimespanConfig: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _timestampField: Google_Privacy_Dlp_V2_FieldId? = nil
  }

  public init() {}

  fileprivate var _timespanConfig: Google_Privacy_Dlp_V2_StorageConfig.TimespanConfig? = nil
}

/// Configuration to control jobs where the content being inspected is outside
/// of Google Cloud Platform.
public struct Google_Privacy_Dlp_V2_HybridOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A short description of where the data is coming from. Will be stored once
  /// in the job. 256 max length.
  public var description_p: String = String()

  /// These are labels that each inspection request must include within their
  /// 'finding_labels' map. Request may contain others, but any missing one of
  /// these will be rejected.
  ///
  /// Label keys must be between 1 and 63 characters long and must conform
  /// to the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`.
  ///
  /// No more than 10 keys can be required.
  public var requiredFindingLabelKeys: [String] = []

  /// To organize findings, these labels will be added to each finding.
  ///
  /// Label keys must be between 1 and 63 characters long and must conform
  /// to the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`.
  ///
  /// Label values must be between 0 and 63 characters long and must conform
  /// to the regular expression `([a-z]([-a-z0-9]*[a-z0-9])?)?`.
  ///
  /// No more than 10 labels can be associated with a given finding.
  ///
  /// Examples:
  /// * `"environment" : "production"`
  /// * `"pipeline" : "etl"`
  public var labels: Dictionary<String,String> = [:]

  /// If the container is a table, additional information to make findings
  /// meaningful such as the columns that are primary keys.
  public var tableOptions: Google_Privacy_Dlp_V2_TableOptions {
    get {return _tableOptions ?? Google_Privacy_Dlp_V2_TableOptions()}
    set {_tableOptions = newValue}
  }
  /// Returns true if `tableOptions` has been explicitly set.
  public var hasTableOptions: Bool {return self._tableOptions != nil}
  /// Clears the value of `tableOptions`. Subsequent reads from it will return its default value.
  public mutating func clearTableOptions() {self._tableOptions = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _tableOptions: Google_Privacy_Dlp_V2_TableOptions? = nil
}

/// Row key for identifying a record in BigQuery table.
public struct Google_Privacy_Dlp_V2_BigQueryKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Complete BigQuery table reference.
  public var tableReference: Google_Privacy_Dlp_V2_BigQueryTable {
    get {return _tableReference ?? Google_Privacy_Dlp_V2_BigQueryTable()}
    set {_tableReference = newValue}
  }
  /// Returns true if `tableReference` has been explicitly set.
  public var hasTableReference: Bool {return self._tableReference != nil}
  /// Clears the value of `tableReference`. Subsequent reads from it will return its default value.
  public mutating func clearTableReference() {self._tableReference = nil}

  /// Row number inferred at the time the table was scanned. This value is
  /// nondeterministic, cannot be queried, and may be null for inspection
  /// jobs. To locate findings within a table, specify
  /// `inspect_job.storage_config.big_query_options.identifying_fields` in
  /// `CreateDlpJobRequest`.
  public var rowNumber: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _tableReference: Google_Privacy_Dlp_V2_BigQueryTable? = nil
}

/// Record key for a finding in Cloud Datastore.
public struct Google_Privacy_Dlp_V2_DatastoreKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Datastore entity key.
  public var entityKey: Google_Privacy_Dlp_V2_Key {
    get {return _entityKey ?? Google_Privacy_Dlp_V2_Key()}
    set {_entityKey = newValue}
  }
  /// Returns true if `entityKey` has been explicitly set.
  public var hasEntityKey: Bool {return self._entityKey != nil}
  /// Clears the value of `entityKey`. Subsequent reads from it will return its default value.
  public mutating func clearEntityKey() {self._entityKey = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _entityKey: Google_Privacy_Dlp_V2_Key? = nil
}

/// A unique identifier for a Datastore entity.
/// If a key's partition ID or any of its path kinds or names are
/// reserved/read-only, the key is reserved/read-only.
/// A reserved/read-only key is forbidden in certain documented contexts.
public struct Google_Privacy_Dlp_V2_Key {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Entities are partitioned into subsets, currently identified by a project
  /// ID and namespace ID.
  /// Queries are scoped to a single partition.
  public var partitionID: Google_Privacy_Dlp_V2_PartitionId {
    get {return _partitionID ?? Google_Privacy_Dlp_V2_PartitionId()}
    set {_partitionID = newValue}
  }
  /// Returns true if `partitionID` has been explicitly set.
  public var hasPartitionID: Bool {return self._partitionID != nil}
  /// Clears the value of `partitionID`. Subsequent reads from it will return its default value.
  public mutating func clearPartitionID() {self._partitionID = nil}

  /// The entity path.
  /// An entity path consists of one or more elements composed of a kind and a
  /// string or numerical identifier, which identify entities. The first
  /// element identifies a _root entity_, the second element identifies
  /// a _child_ of the root entity, the third element identifies a child of the
  /// second entity, and so forth. The entities identified by all prefixes of
  /// the path are called the element's _ancestors_.
  ///
  /// A path can never be empty, and a path can have at most 100 elements.
  public var path: [Google_Privacy_Dlp_V2_Key.PathElement] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A (kind, ID/name) pair used to construct a key path.
  ///
  /// If either name or ID is set, the element is complete.
  /// If neither is set, the element is incomplete.
  public struct PathElement {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The kind of the entity.
    /// A kind matching regex `__.*__` is reserved/read-only.
    /// A kind must not contain more than 1500 bytes when UTF-8 encoded.
    /// Cannot be `""`.
    public var kind: String = String()

    /// The type of ID.
    public var idType: Google_Privacy_Dlp_V2_Key.PathElement.OneOf_IDType? = nil

    /// The auto-allocated ID of the entity.
    /// Never equal to zero. Values less than zero are discouraged and may not
    /// be supported in the future.
    public var id: Int64 {
      get {
        if case .id(let v)? = idType {return v}
        return 0
      }
      set {idType = .id(newValue)}
    }

    /// The name of the entity.
    /// A name matching regex `__.*__` is reserved/read-only.
    /// A name must not be more than 1500 bytes when UTF-8 encoded.
    /// Cannot be `""`.
    public var name: String {
      get {
        if case .name(let v)? = idType {return v}
        return String()
      }
      set {idType = .name(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The type of ID.
    public enum OneOf_IDType: Equatable {
      /// The auto-allocated ID of the entity.
      /// Never equal to zero. Values less than zero are discouraged and may not
      /// be supported in the future.
      case id(Int64)
      /// The name of the entity.
      /// A name matching regex `__.*__` is reserved/read-only.
      /// A name must not be more than 1500 bytes when UTF-8 encoded.
      /// Cannot be `""`.
      case name(String)

    #if !swift(>=4.1)
      public static func ==(lhs: Google_Privacy_Dlp_V2_Key.PathElement.OneOf_IDType, rhs: Google_Privacy_Dlp_V2_Key.PathElement.OneOf_IDType) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.id, .id): return {
          guard case .id(let l) = lhs, case .id(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.name, .name): return {
          guard case .name(let l) = lhs, case .name(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  public init() {}

  fileprivate var _partitionID: Google_Privacy_Dlp_V2_PartitionId? = nil
}

/// Message for a unique key indicating a record that contains a finding.
public struct Google_Privacy_Dlp_V2_RecordKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Google_Privacy_Dlp_V2_RecordKey.OneOf_Type? = nil

  public var datastoreKey: Google_Privacy_Dlp_V2_DatastoreKey {
    get {
      if case .datastoreKey(let v)? = type {return v}
      return Google_Privacy_Dlp_V2_DatastoreKey()
    }
    set {type = .datastoreKey(newValue)}
  }

  public var bigQueryKey: Google_Privacy_Dlp_V2_BigQueryKey {
    get {
      if case .bigQueryKey(let v)? = type {return v}
      return Google_Privacy_Dlp_V2_BigQueryKey()
    }
    set {type = .bigQueryKey(newValue)}
  }

  /// Values of identifying columns in the given row. Order of values matches
  /// the order of `identifying_fields` specified in the scanning request.
  public var idValues: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable {
    case datastoreKey(Google_Privacy_Dlp_V2_DatastoreKey)
    case bigQueryKey(Google_Privacy_Dlp_V2_BigQueryKey)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Privacy_Dlp_V2_RecordKey.OneOf_Type, rhs: Google_Privacy_Dlp_V2_RecordKey.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.datastoreKey, .datastoreKey): return {
        guard case .datastoreKey(let l) = lhs, case .datastoreKey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bigQueryKey, .bigQueryKey): return {
        guard case .bigQueryKey(let l) = lhs, case .bigQueryKey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Message defining the location of a BigQuery table. A table is uniquely
/// identified  by its project_id, dataset_id, and table_name. Within a query
/// a table is often referenced with a string in the format of:
/// `<project_id>:<dataset_id>.<table_id>` or
/// `<project_id>.<dataset_id>.<table_id>`.
public struct Google_Privacy_Dlp_V2_BigQueryTable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Google Cloud Platform project ID of the project containing the table.
  /// If omitted, project ID is inferred from the API call.
  public var projectID: String = String()

  /// Dataset ID of the table.
  public var datasetID: String = String()

  /// Name of the table.
  public var tableID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message defining a field of a BigQuery table.
public struct Google_Privacy_Dlp_V2_BigQueryField {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Source table of the field.
  public var table: Google_Privacy_Dlp_V2_BigQueryTable {
    get {return _table ?? Google_Privacy_Dlp_V2_BigQueryTable()}
    set {_table = newValue}
  }
  /// Returns true if `table` has been explicitly set.
  public var hasTable: Bool {return self._table != nil}
  /// Clears the value of `table`. Subsequent reads from it will return its default value.
  public mutating func clearTable() {self._table = nil}

  /// Designated field in the BigQuery table.
  public var field: Google_Privacy_Dlp_V2_FieldId {
    get {return _field ?? Google_Privacy_Dlp_V2_FieldId()}
    set {_field = newValue}
  }
  /// Returns true if `field` has been explicitly set.
  public var hasField: Bool {return self._field != nil}
  /// Clears the value of `field`. Subsequent reads from it will return its default value.
  public mutating func clearField() {self._field = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _table: Google_Privacy_Dlp_V2_BigQueryTable? = nil
  fileprivate var _field: Google_Privacy_Dlp_V2_FieldId? = nil
}

/// An entity in a dataset is a field or set of fields that correspond to a
/// single person. For example, in medical records the `EntityId` might be a
/// patient identifier, or for financial records it might be an account
/// identifier. This message is used when generalizations or analysis must take
/// into account that multiple rows correspond to the same entity.
public struct Google_Privacy_Dlp_V2_EntityId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Composite key indicating which field contains the entity identifier.
  public var field: Google_Privacy_Dlp_V2_FieldId {
    get {return _field ?? Google_Privacy_Dlp_V2_FieldId()}
    set {_field = newValue}
  }
  /// Returns true if `field` has been explicitly set.
  public var hasField: Bool {return self._field != nil}
  /// Clears the value of `field`. Subsequent reads from it will return its default value.
  public mutating func clearField() {self._field = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _field: Google_Privacy_Dlp_V2_FieldId? = nil
}

/// Instructions regarding the table content being inspected.
public struct Google_Privacy_Dlp_V2_TableOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The columns that are the primary keys for table objects included in
  /// ContentItem. A copy of this cell's value will stored alongside alongside
  /// each finding so that the finding can be traced to the specific row it came
  /// from. No more than 3 may be provided.
  public var identifyingFields: [Google_Privacy_Dlp_V2_FieldId] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.privacy.dlp.v2"

extension Google_Privacy_Dlp_V2_Likelihood: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LIKELIHOOD_UNSPECIFIED"),
    1: .same(proto: "VERY_UNLIKELY"),
    2: .same(proto: "UNLIKELY"),
    3: .same(proto: "POSSIBLE"),
    4: .same(proto: "LIKELY"),
    5: .same(proto: "VERY_LIKELY"),
  ]
}

extension Google_Privacy_Dlp_V2_FileType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FILE_TYPE_UNSPECIFIED"),
    1: .same(proto: "BINARY_FILE"),
    2: .same(proto: "TEXT_FILE"),
    3: .same(proto: "IMAGE"),
    5: .same(proto: "WORD"),
    6: .same(proto: "PDF"),
    7: .same(proto: "AVRO"),
    8: .same(proto: "CSV"),
    9: .same(proto: "TSV"),
  ]
}

extension Google_Privacy_Dlp_V2_InfoType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InfoType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_InfoType, rhs: Google_Privacy_Dlp_V2_InfoType) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_StoredType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StoredType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "create_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_StoredType, rhs: Google_Privacy_Dlp_V2_StoredType) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_CustomInfoType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CustomInfoType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "info_type"),
    6: .same(proto: "likelihood"),
    2: .same(proto: "dictionary"),
    3: .same(proto: "regex"),
    4: .standard(proto: "surrogate_type"),
    5: .standard(proto: "stored_type"),
    7: .standard(proto: "detection_rules"),
    8: .standard(proto: "exclusion_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._infoType) }()
      case 2: try {
        var v: Google_Privacy_Dlp_V2_CustomInfoType.Dictionary?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .dictionary(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .dictionary(v)}
      }()
      case 3: try {
        var v: Google_Privacy_Dlp_V2_CustomInfoType.Regex?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .regex(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .regex(v)}
      }()
      case 4: try {
        var v: Google_Privacy_Dlp_V2_CustomInfoType.SurrogateType?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .surrogateType(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .surrogateType(v)}
      }()
      case 5: try {
        var v: Google_Privacy_Dlp_V2_StoredType?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .storedType(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .storedType(v)}
      }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.likelihood) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.detectionRules) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.exclusionType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._infoType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.type {
    case .dictionary?: try {
      guard case .dictionary(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .regex?: try {
      guard case .regex(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .surrogateType?: try {
      guard case .surrogateType(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .storedType?: try {
      guard case .storedType(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    if self.likelihood != .unspecified {
      try visitor.visitSingularEnumField(value: self.likelihood, fieldNumber: 6)
    }
    if !self.detectionRules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.detectionRules, fieldNumber: 7)
    }
    if self.exclusionType != .unspecified {
      try visitor.visitSingularEnumField(value: self.exclusionType, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_CustomInfoType, rhs: Google_Privacy_Dlp_V2_CustomInfoType) -> Bool {
    if lhs._infoType != rhs._infoType {return false}
    if lhs.likelihood != rhs.likelihood {return false}
    if lhs.type != rhs.type {return false}
    if lhs.detectionRules != rhs.detectionRules {return false}
    if lhs.exclusionType != rhs.exclusionType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_CustomInfoType.ExclusionType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EXCLUSION_TYPE_UNSPECIFIED"),
    1: .same(proto: "EXCLUSION_TYPE_EXCLUDE"),
  ]
}

extension Google_Privacy_Dlp_V2_CustomInfoType.Dictionary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_CustomInfoType.protoMessageName + ".Dictionary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "word_list"),
    3: .standard(proto: "cloud_storage_path"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Privacy_Dlp_V2_CustomInfoType.Dictionary.WordList?
        if let current = self.source {
          try decoder.handleConflictingOneOf()
          if case .wordList(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.source = .wordList(v)}
      }()
      case 3: try {
        var v: Google_Privacy_Dlp_V2_CloudStoragePath?
        if let current = self.source {
          try decoder.handleConflictingOneOf()
          if case .cloudStoragePath(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.source = .cloudStoragePath(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.source {
    case .wordList?: try {
      guard case .wordList(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .cloudStoragePath?: try {
      guard case .cloudStoragePath(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_CustomInfoType.Dictionary, rhs: Google_Privacy_Dlp_V2_CustomInfoType.Dictionary) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_CustomInfoType.Dictionary.WordList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_CustomInfoType.Dictionary.protoMessageName + ".WordList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "words"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.words) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.words.isEmpty {
      try visitor.visitRepeatedStringField(value: self.words, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_CustomInfoType.Dictionary.WordList, rhs: Google_Privacy_Dlp_V2_CustomInfoType.Dictionary.WordList) -> Bool {
    if lhs.words != rhs.words {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_CustomInfoType.Regex: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_CustomInfoType.protoMessageName + ".Regex"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pattern"),
    2: .standard(proto: "group_indexes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pattern) }()
      case 2: try { try decoder.decodeRepeatedInt32Field(value: &self.groupIndexes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pattern.isEmpty {
      try visitor.visitSingularStringField(value: self.pattern, fieldNumber: 1)
    }
    if !self.groupIndexes.isEmpty {
      try visitor.visitPackedInt32Field(value: self.groupIndexes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_CustomInfoType.Regex, rhs: Google_Privacy_Dlp_V2_CustomInfoType.Regex) -> Bool {
    if lhs.pattern != rhs.pattern {return false}
    if lhs.groupIndexes != rhs.groupIndexes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_CustomInfoType.SurrogateType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_CustomInfoType.protoMessageName + ".SurrogateType"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_CustomInfoType.SurrogateType, rhs: Google_Privacy_Dlp_V2_CustomInfoType.SurrogateType) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_CustomInfoType.DetectionRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_CustomInfoType.protoMessageName + ".DetectionRule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "hotword_rule"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Privacy_Dlp_V2_CustomInfoType.DetectionRule.HotwordRule?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .hotwordRule(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .hotwordRule(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .hotwordRule(let v)? = self.type {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_CustomInfoType.DetectionRule, rhs: Google_Privacy_Dlp_V2_CustomInfoType.DetectionRule) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_CustomInfoType.DetectionRule.Proximity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_CustomInfoType.DetectionRule.protoMessageName + ".Proximity"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "window_before"),
    2: .standard(proto: "window_after"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.windowBefore) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.windowAfter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.windowBefore != 0 {
      try visitor.visitSingularInt32Field(value: self.windowBefore, fieldNumber: 1)
    }
    if self.windowAfter != 0 {
      try visitor.visitSingularInt32Field(value: self.windowAfter, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_CustomInfoType.DetectionRule.Proximity, rhs: Google_Privacy_Dlp_V2_CustomInfoType.DetectionRule.Proximity) -> Bool {
    if lhs.windowBefore != rhs.windowBefore {return false}
    if lhs.windowAfter != rhs.windowAfter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_CustomInfoType.DetectionRule.LikelihoodAdjustment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_CustomInfoType.DetectionRule.protoMessageName + ".LikelihoodAdjustment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fixed_likelihood"),
    2: .standard(proto: "relative_likelihood"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.adjustment != nil {try decoder.handleConflictingOneOf()}
        var v: Google_Privacy_Dlp_V2_Likelihood?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {self.adjustment = .fixedLikelihood(v)}
      }()
      case 2: try {
        if self.adjustment != nil {try decoder.handleConflictingOneOf()}
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {self.adjustment = .relativeLikelihood(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.adjustment {
    case .fixedLikelihood?: try {
      guard case .fixedLikelihood(let v)? = self.adjustment else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .relativeLikelihood?: try {
      guard case .relativeLikelihood(let v)? = self.adjustment else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_CustomInfoType.DetectionRule.LikelihoodAdjustment, rhs: Google_Privacy_Dlp_V2_CustomInfoType.DetectionRule.LikelihoodAdjustment) -> Bool {
    if lhs.adjustment != rhs.adjustment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_CustomInfoType.DetectionRule.HotwordRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_CustomInfoType.DetectionRule.protoMessageName + ".HotwordRule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "hotword_regex"),
    2: .same(proto: "proximity"),
    3: .standard(proto: "likelihood_adjustment"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._hotwordRegex) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._proximity) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._likelihoodAdjustment) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._hotwordRegex {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._proximity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._likelihoodAdjustment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_CustomInfoType.DetectionRule.HotwordRule, rhs: Google_Privacy_Dlp_V2_CustomInfoType.DetectionRule.HotwordRule) -> Bool {
    if lhs._hotwordRegex != rhs._hotwordRegex {return false}
    if lhs._proximity != rhs._proximity {return false}
    if lhs._likelihoodAdjustment != rhs._likelihoodAdjustment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_FieldId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FieldId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_FieldId, rhs: Google_Privacy_Dlp_V2_FieldId) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_PartitionId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PartitionId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "project_id"),
    4: .standard(proto: "namespace_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.namespaceID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 2)
    }
    if !self.namespaceID.isEmpty {
      try visitor.visitSingularStringField(value: self.namespaceID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_PartitionId, rhs: Google_Privacy_Dlp_V2_PartitionId) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.namespaceID != rhs.namespaceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_KindExpression: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KindExpression"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_KindExpression, rhs: Google_Privacy_Dlp_V2_KindExpression) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_DatastoreOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DatastoreOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "partition_id"),
    2: .same(proto: "kind"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._partitionID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._kind) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._partitionID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._kind {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_DatastoreOptions, rhs: Google_Privacy_Dlp_V2_DatastoreOptions) -> Bool {
    if lhs._partitionID != rhs._partitionID {return false}
    if lhs._kind != rhs._kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_CloudStorageRegexFileSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CloudStorageRegexFileSet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bucket_name"),
    2: .standard(proto: "include_regex"),
    3: .standard(proto: "exclude_regex"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bucketName) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.includeRegex) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.excludeRegex) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bucketName.isEmpty {
      try visitor.visitSingularStringField(value: self.bucketName, fieldNumber: 1)
    }
    if !self.includeRegex.isEmpty {
      try visitor.visitRepeatedStringField(value: self.includeRegex, fieldNumber: 2)
    }
    if !self.excludeRegex.isEmpty {
      try visitor.visitRepeatedStringField(value: self.excludeRegex, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_CloudStorageRegexFileSet, rhs: Google_Privacy_Dlp_V2_CloudStorageRegexFileSet) -> Bool {
    if lhs.bucketName != rhs.bucketName {return false}
    if lhs.includeRegex != rhs.includeRegex {return false}
    if lhs.excludeRegex != rhs.excludeRegex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_CloudStorageOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CloudStorageOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "file_set"),
    4: .standard(proto: "bytes_limit_per_file"),
    8: .standard(proto: "bytes_limit_per_file_percent"),
    5: .standard(proto: "file_types"),
    6: .standard(proto: "sample_method"),
    7: .standard(proto: "files_limit_percent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._fileSet) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.bytesLimitPerFile) }()
      case 5: try { try decoder.decodeRepeatedEnumField(value: &self.fileTypes) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.sampleMethod) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.filesLimitPercent) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.bytesLimitPerFilePercent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._fileSet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.bytesLimitPerFile != 0 {
      try visitor.visitSingularInt64Field(value: self.bytesLimitPerFile, fieldNumber: 4)
    }
    if !self.fileTypes.isEmpty {
      try visitor.visitPackedEnumField(value: self.fileTypes, fieldNumber: 5)
    }
    if self.sampleMethod != .unspecified {
      try visitor.visitSingularEnumField(value: self.sampleMethod, fieldNumber: 6)
    }
    if self.filesLimitPercent != 0 {
      try visitor.visitSingularInt32Field(value: self.filesLimitPercent, fieldNumber: 7)
    }
    if self.bytesLimitPerFilePercent != 0 {
      try visitor.visitSingularInt32Field(value: self.bytesLimitPerFilePercent, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_CloudStorageOptions, rhs: Google_Privacy_Dlp_V2_CloudStorageOptions) -> Bool {
    if lhs._fileSet != rhs._fileSet {return false}
    if lhs.bytesLimitPerFile != rhs.bytesLimitPerFile {return false}
    if lhs.bytesLimitPerFilePercent != rhs.bytesLimitPerFilePercent {return false}
    if lhs.fileTypes != rhs.fileTypes {return false}
    if lhs.sampleMethod != rhs.sampleMethod {return false}
    if lhs.filesLimitPercent != rhs.filesLimitPercent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_CloudStorageOptions.SampleMethod: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SAMPLE_METHOD_UNSPECIFIED"),
    1: .same(proto: "TOP"),
    2: .same(proto: "RANDOM_START"),
  ]
}

extension Google_Privacy_Dlp_V2_CloudStorageOptions.FileSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_CloudStorageOptions.protoMessageName + ".FileSet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .standard(proto: "regex_file_set"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._regexFileSet) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    if let v = self._regexFileSet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_CloudStorageOptions.FileSet, rhs: Google_Privacy_Dlp_V2_CloudStorageOptions.FileSet) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs._regexFileSet != rhs._regexFileSet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_CloudStorageFileSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CloudStorageFileSet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_CloudStorageFileSet, rhs: Google_Privacy_Dlp_V2_CloudStorageFileSet) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_CloudStoragePath: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CloudStoragePath"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.path) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_CloudStoragePath, rhs: Google_Privacy_Dlp_V2_CloudStoragePath) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_BigQueryOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BigQueryOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "table_reference"),
    2: .standard(proto: "identifying_fields"),
    3: .standard(proto: "rows_limit"),
    6: .standard(proto: "rows_limit_percent"),
    4: .standard(proto: "sample_method"),
    5: .standard(proto: "excluded_fields"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tableReference) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.identifyingFields) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.rowsLimit) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.sampleMethod) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.excludedFields) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.rowsLimitPercent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._tableReference {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.identifyingFields.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.identifyingFields, fieldNumber: 2)
    }
    if self.rowsLimit != 0 {
      try visitor.visitSingularInt64Field(value: self.rowsLimit, fieldNumber: 3)
    }
    if self.sampleMethod != .unspecified {
      try visitor.visitSingularEnumField(value: self.sampleMethod, fieldNumber: 4)
    }
    if !self.excludedFields.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.excludedFields, fieldNumber: 5)
    }
    if self.rowsLimitPercent != 0 {
      try visitor.visitSingularInt32Field(value: self.rowsLimitPercent, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_BigQueryOptions, rhs: Google_Privacy_Dlp_V2_BigQueryOptions) -> Bool {
    if lhs._tableReference != rhs._tableReference {return false}
    if lhs.identifyingFields != rhs.identifyingFields {return false}
    if lhs.rowsLimit != rhs.rowsLimit {return false}
    if lhs.rowsLimitPercent != rhs.rowsLimitPercent {return false}
    if lhs.sampleMethod != rhs.sampleMethod {return false}
    if lhs.excludedFields != rhs.excludedFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_BigQueryOptions.SampleMethod: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SAMPLE_METHOD_UNSPECIFIED"),
    1: .same(proto: "TOP"),
    2: .same(proto: "RANDOM_START"),
  ]
}

extension Google_Privacy_Dlp_V2_StorageConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StorageConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "datastore_options"),
    3: .standard(proto: "cloud_storage_options"),
    4: .standard(proto: "big_query_options"),
    9: .standard(proto: "hybrid_options"),
    6: .standard(proto: "timespan_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: Google_Privacy_Dlp_V2_DatastoreOptions?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .datastoreOptions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .datastoreOptions(v)}
      }()
      case 3: try {
        var v: Google_Privacy_Dlp_V2_CloudStorageOptions?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .cloudStorageOptions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .cloudStorageOptions(v)}
      }()
      case 4: try {
        var v: Google_Privacy_Dlp_V2_BigQueryOptions?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .bigQueryOptions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .bigQueryOptions(v)}
      }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._timespanConfig) }()
      case 9: try {
        var v: Google_Privacy_Dlp_V2_HybridOptions?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .hybridOptions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .hybridOptions(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.type {
    case .datastoreOptions?: try {
      guard case .datastoreOptions(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .cloudStorageOptions?: try {
      guard case .cloudStorageOptions(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .bigQueryOptions?: try {
      guard case .bigQueryOptions(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    default: break
    }
    if let v = self._timespanConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if case .hybridOptions(let v)? = self.type {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_StorageConfig, rhs: Google_Privacy_Dlp_V2_StorageConfig) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs._timespanConfig != rhs._timespanConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_StorageConfig.TimespanConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_StorageConfig.protoMessageName + ".TimespanConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_time"),
    2: .standard(proto: "end_time"),
    3: .standard(proto: "timestamp_field"),
    4: .standard(proto: "enable_auto_population_of_timespan_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._endTime) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._timestampField) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.enableAutoPopulationOfTimespanConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._timestampField {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.enableAutoPopulationOfTimespanConfig != false {
      try visitor.visitSingularBoolField(value: self.enableAutoPopulationOfTimespanConfig, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_StorageConfig.TimespanConfig, rhs: Google_Privacy_Dlp_V2_StorageConfig.TimespanConfig) -> Bool {
    if lhs._startTime != rhs._startTime {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs._timestampField != rhs._timestampField {return false}
    if lhs.enableAutoPopulationOfTimespanConfig != rhs.enableAutoPopulationOfTimespanConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_HybridOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HybridOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "description"),
    2: .standard(proto: "required_finding_label_keys"),
    3: .same(proto: "labels"),
    4: .standard(proto: "table_options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.requiredFindingLabelKeys) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._tableOptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 1)
    }
    if !self.requiredFindingLabelKeys.isEmpty {
      try visitor.visitRepeatedStringField(value: self.requiredFindingLabelKeys, fieldNumber: 2)
    }
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 3)
    }
    if let v = self._tableOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_HybridOptions, rhs: Google_Privacy_Dlp_V2_HybridOptions) -> Bool {
    if lhs.description_p != rhs.description_p {return false}
    if lhs.requiredFindingLabelKeys != rhs.requiredFindingLabelKeys {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs._tableOptions != rhs._tableOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_BigQueryKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BigQueryKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "table_reference"),
    2: .standard(proto: "row_number"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tableReference) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.rowNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._tableReference {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.rowNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.rowNumber, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_BigQueryKey, rhs: Google_Privacy_Dlp_V2_BigQueryKey) -> Bool {
    if lhs._tableReference != rhs._tableReference {return false}
    if lhs.rowNumber != rhs.rowNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_DatastoreKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DatastoreKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "entity_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._entityKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._entityKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_DatastoreKey, rhs: Google_Privacy_Dlp_V2_DatastoreKey) -> Bool {
    if lhs._entityKey != rhs._entityKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_Key: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Key"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "partition_id"),
    2: .same(proto: "path"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._partitionID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.path) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._partitionID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.path.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.path, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_Key, rhs: Google_Privacy_Dlp_V2_Key) -> Bool {
    if lhs._partitionID != rhs._partitionID {return false}
    if lhs.path != rhs.path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_Key.PathElement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Privacy_Dlp_V2_Key.protoMessageName + ".PathElement"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .same(proto: "id"),
    3: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      case 2: try {
        if self.idType != nil {try decoder.handleConflictingOneOf()}
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {self.idType = .id(v)}
      }()
      case 3: try {
        if self.idType != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.idType = .name(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.idType {
    case .id?: try {
      guard case .id(let v)? = self.idType else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    }()
    case .name?: try {
      guard case .name(let v)? = self.idType else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_Key.PathElement, rhs: Google_Privacy_Dlp_V2_Key.PathElement) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.idType != rhs.idType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_RecordKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecordKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "datastore_key"),
    3: .standard(proto: "big_query_key"),
    5: .standard(proto: "id_values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: Google_Privacy_Dlp_V2_DatastoreKey?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .datastoreKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .datastoreKey(v)}
      }()
      case 3: try {
        var v: Google_Privacy_Dlp_V2_BigQueryKey?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .bigQueryKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .bigQueryKey(v)}
      }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.idValues) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.type {
    case .datastoreKey?: try {
      guard case .datastoreKey(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .bigQueryKey?: try {
      guard case .bigQueryKey(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if !self.idValues.isEmpty {
      try visitor.visitRepeatedStringField(value: self.idValues, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_RecordKey, rhs: Google_Privacy_Dlp_V2_RecordKey) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.idValues != rhs.idValues {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_BigQueryTable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BigQueryTable"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .standard(proto: "dataset_id"),
    3: .standard(proto: "table_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.datasetID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.tableID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.datasetID.isEmpty {
      try visitor.visitSingularStringField(value: self.datasetID, fieldNumber: 2)
    }
    if !self.tableID.isEmpty {
      try visitor.visitSingularStringField(value: self.tableID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_BigQueryTable, rhs: Google_Privacy_Dlp_V2_BigQueryTable) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.datasetID != rhs.datasetID {return false}
    if lhs.tableID != rhs.tableID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_BigQueryField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BigQueryField"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "table"),
    2: .same(proto: "field"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._table) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._field) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._table {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._field {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_BigQueryField, rhs: Google_Privacy_Dlp_V2_BigQueryField) -> Bool {
    if lhs._table != rhs._table {return false}
    if lhs._field != rhs._field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_EntityId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EntityId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "field"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._field) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._field {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_EntityId, rhs: Google_Privacy_Dlp_V2_EntityId) -> Bool {
    if lhs._field != rhs._field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Privacy_Dlp_V2_TableOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TableOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "identifying_fields"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.identifyingFields) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identifyingFields.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.identifyingFields, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Privacy_Dlp_V2_TableOptions, rhs: Google_Privacy_Dlp_V2_TableOptions) -> Bool {
    if lhs.identifyingFields != rhs.identifyingFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

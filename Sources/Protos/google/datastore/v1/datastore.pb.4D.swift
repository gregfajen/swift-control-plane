// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/datastore/v1/datastore.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The request for [Datastore.Lookup][google.datastore.v1.Datastore.Lookup].
public struct Google_Datastore_V1_LookupRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The ID of the project against which to make the request.
  public var projectID: String = String()

  /// The options for this lookup request.
  public var readOptions: Google_Datastore_V1_ReadOptions {
    get {return _readOptions ?? Google_Datastore_V1_ReadOptions()}
    set {_readOptions = newValue}
  }
  /// Returns true if `readOptions` has been explicitly set.
  public var hasReadOptions: Bool {return self._readOptions != nil}
  /// Clears the value of `readOptions`. Subsequent reads from it will return its default value.
  public mutating func clearReadOptions() {self._readOptions = nil}

  /// Required. Keys of entities to look up.
  public var keys: [Google_Datastore_V1_Key] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _readOptions: Google_Datastore_V1_ReadOptions? = nil
}

/// The response for [Datastore.Lookup][google.datastore.v1.Datastore.Lookup].
public struct Google_Datastore_V1_LookupResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Entities found as `ResultType.FULL` entities. The order of results in this
  /// field is undefined and has no relation to the order of the keys in the
  /// input.
  public var found: [Google_Datastore_V1_EntityResult] = []

  /// Entities not found as `ResultType.KEY_ONLY` entities. The order of results
  /// in this field is undefined and has no relation to the order of the keys
  /// in the input.
  public var missing: [Google_Datastore_V1_EntityResult] = []

  /// A list of keys that were not looked up due to resource constraints. The
  /// order of results in this field is undefined and has no relation to the
  /// order of the keys in the input.
  public var deferred: [Google_Datastore_V1_Key] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request for [Datastore.RunQuery][google.datastore.v1.Datastore.RunQuery].
public struct Google_Datastore_V1_RunQueryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The ID of the project against which to make the request.
  public var projectID: String {
    get {return _storage._projectID}
    set {_uniqueStorage()._projectID = newValue}
  }

  /// Entities are partitioned into subsets, identified by a partition ID.
  /// Queries are scoped to a single partition.
  /// This partition ID is normalized with the standard default context
  /// partition ID.
  public var partitionID: Google_Datastore_V1_PartitionId {
    get {return _storage._partitionID ?? Google_Datastore_V1_PartitionId()}
    set {_uniqueStorage()._partitionID = newValue}
  }
  /// Returns true if `partitionID` has been explicitly set.
  public var hasPartitionID: Bool {return _storage._partitionID != nil}
  /// Clears the value of `partitionID`. Subsequent reads from it will return its default value.
  public mutating func clearPartitionID() {_uniqueStorage()._partitionID = nil}

  /// The options for this query.
  public var readOptions: Google_Datastore_V1_ReadOptions {
    get {return _storage._readOptions ?? Google_Datastore_V1_ReadOptions()}
    set {_uniqueStorage()._readOptions = newValue}
  }
  /// Returns true if `readOptions` has been explicitly set.
  public var hasReadOptions: Bool {return _storage._readOptions != nil}
  /// Clears the value of `readOptions`. Subsequent reads from it will return its default value.
  public mutating func clearReadOptions() {_uniqueStorage()._readOptions = nil}

  /// The type of query.
  public var queryType: OneOf_QueryType? {
    get {return _storage._queryType}
    set {_uniqueStorage()._queryType = newValue}
  }

  /// The query to run.
  public var query: Google_Datastore_V1_Query {
    get {
      if case .query(let v)? = _storage._queryType {return v}
      return Google_Datastore_V1_Query()
    }
    set {_uniqueStorage()._queryType = .query(newValue)}
  }

  /// The GQL query to run.
  public var gqlQuery: Google_Datastore_V1_GqlQuery {
    get {
      if case .gqlQuery(let v)? = _storage._queryType {return v}
      return Google_Datastore_V1_GqlQuery()
    }
    set {_uniqueStorage()._queryType = .gqlQuery(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The type of query.
  public enum OneOf_QueryType: Equatable {
    /// The query to run.
    case query(Google_Datastore_V1_Query)
    /// The GQL query to run.
    case gqlQuery(Google_Datastore_V1_GqlQuery)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Datastore_V1_RunQueryRequest.OneOf_QueryType, rhs: Google_Datastore_V1_RunQueryRequest.OneOf_QueryType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.query, .query): return {
        guard case .query(let l) = lhs, case .query(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.gqlQuery, .gqlQuery): return {
        guard case .gqlQuery(let l) = lhs, case .gqlQuery(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The response for [Datastore.RunQuery][google.datastore.v1.Datastore.RunQuery].
public struct Google_Datastore_V1_RunQueryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A batch of query results (always present).
  public var batch: Google_Datastore_V1_QueryResultBatch {
    get {return _storage._batch ?? Google_Datastore_V1_QueryResultBatch()}
    set {_uniqueStorage()._batch = newValue}
  }
  /// Returns true if `batch` has been explicitly set.
  public var hasBatch: Bool {return _storage._batch != nil}
  /// Clears the value of `batch`. Subsequent reads from it will return its default value.
  public mutating func clearBatch() {_uniqueStorage()._batch = nil}

  /// The parsed form of the `GqlQuery` from the request, if it was set.
  public var query: Google_Datastore_V1_Query {
    get {return _storage._query ?? Google_Datastore_V1_Query()}
    set {_uniqueStorage()._query = newValue}
  }
  /// Returns true if `query` has been explicitly set.
  public var hasQuery: Bool {return _storage._query != nil}
  /// Clears the value of `query`. Subsequent reads from it will return its default value.
  public mutating func clearQuery() {_uniqueStorage()._query = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The request for [Datastore.BeginTransaction][google.datastore.v1.Datastore.BeginTransaction].
public struct Google_Datastore_V1_BeginTransactionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The ID of the project against which to make the request.
  public var projectID: String = String()

  /// Options for a new transaction.
  public var transactionOptions: Google_Datastore_V1_TransactionOptions {
    get {return _transactionOptions ?? Google_Datastore_V1_TransactionOptions()}
    set {_transactionOptions = newValue}
  }
  /// Returns true if `transactionOptions` has been explicitly set.
  public var hasTransactionOptions: Bool {return self._transactionOptions != nil}
  /// Clears the value of `transactionOptions`. Subsequent reads from it will return its default value.
  public mutating func clearTransactionOptions() {self._transactionOptions = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _transactionOptions: Google_Datastore_V1_TransactionOptions? = nil
}

/// The response for [Datastore.BeginTransaction][google.datastore.v1.Datastore.BeginTransaction].
public struct Google_Datastore_V1_BeginTransactionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The transaction identifier (always present).
  public var transaction: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request for [Datastore.Rollback][google.datastore.v1.Datastore.Rollback].
public struct Google_Datastore_V1_RollbackRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The ID of the project against which to make the request.
  public var projectID: String = String()

  /// Required. The transaction identifier, returned by a call to
  /// [Datastore.BeginTransaction][google.datastore.v1.Datastore.BeginTransaction].
  public var transaction: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The response for [Datastore.Rollback][google.datastore.v1.Datastore.Rollback].
/// (an empty message).
public struct Google_Datastore_V1_RollbackResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request for [Datastore.Commit][google.datastore.v1.Datastore.Commit].
public struct Google_Datastore_V1_CommitRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The ID of the project against which to make the request.
  public var projectID: String = String()

  /// The type of commit to perform. Defaults to `TRANSACTIONAL`.
  public var mode: Google_Datastore_V1_CommitRequest.Mode = .unspecified

  /// Must be set when mode is `TRANSACTIONAL`.
  public var transactionSelector: Google_Datastore_V1_CommitRequest.OneOf_TransactionSelector? = nil

  /// The identifier of the transaction associated with the commit. A
  /// transaction identifier is returned by a call to
  /// [Datastore.BeginTransaction][google.datastore.v1.Datastore.BeginTransaction].
  public var transaction: Data {
    get {
      if case .transaction(let v)? = transactionSelector {return v}
      return Data()
    }
    set {transactionSelector = .transaction(newValue)}
  }

  /// The mutations to perform.
  ///
  /// When mode is `TRANSACTIONAL`, mutations affecting a single entity are
  /// applied in order. The following sequences of mutations affecting a single
  /// entity are not permitted in a single `Commit` request:
  ///
  /// - `insert` followed by `insert`
  /// - `update` followed by `insert`
  /// - `upsert` followed by `insert`
  /// - `delete` followed by `update`
  ///
  /// When mode is `NON_TRANSACTIONAL`, no two mutations may affect a single
  /// entity.
  public var mutations: [Google_Datastore_V1_Mutation] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Must be set when mode is `TRANSACTIONAL`.
  public enum OneOf_TransactionSelector: Equatable {
    /// The identifier of the transaction associated with the commit. A
    /// transaction identifier is returned by a call to
    /// [Datastore.BeginTransaction][google.datastore.v1.Datastore.BeginTransaction].
    case transaction(Data)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Datastore_V1_CommitRequest.OneOf_TransactionSelector, rhs: Google_Datastore_V1_CommitRequest.OneOf_TransactionSelector) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.transaction, .transaction): return {
        guard case .transaction(let l) = lhs, case .transaction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  /// The modes available for commits.
  public enum Mode: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unspecified. This value must not be used.
    case unspecified // = 0

    /// Transactional: The mutations are either all applied, or none are applied.
    /// Learn about transactions
    /// [here](https://cloud.google.com/datastore/docs/concepts/transactions).
    case transactional // = 1

    /// Non-transactional: The mutations may not apply as all or none.
    case nonTransactional // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .transactional
      case 2: self = .nonTransactional
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .transactional: return 1
      case .nonTransactional: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Datastore_V1_CommitRequest.Mode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Datastore_V1_CommitRequest.Mode] = [
    .unspecified,
    .transactional,
    .nonTransactional,
  ]
}

#endif  // swift(>=4.2)

/// The response for [Datastore.Commit][google.datastore.v1.Datastore.Commit].
public struct Google_Datastore_V1_CommitResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The result of performing the mutations.
  /// The i-th mutation result corresponds to the i-th mutation in the request.
  public var mutationResults: [Google_Datastore_V1_MutationResult] = []

  /// The number of index entries updated during the commit, or zero if none were
  /// updated.
  public var indexUpdates: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request for [Datastore.AllocateIds][google.datastore.v1.Datastore.AllocateIds].
public struct Google_Datastore_V1_AllocateIdsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The ID of the project against which to make the request.
  public var projectID: String = String()

  /// Required. A list of keys with incomplete key paths for which to allocate IDs.
  /// No key may be reserved/read-only.
  public var keys: [Google_Datastore_V1_Key] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The response for [Datastore.AllocateIds][google.datastore.v1.Datastore.AllocateIds].
public struct Google_Datastore_V1_AllocateIdsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The keys specified in the request (in the same order), each with
  /// its key path completed with a newly allocated ID.
  public var keys: [Google_Datastore_V1_Key] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request for [Datastore.ReserveIds][google.datastore.v1.Datastore.ReserveIds].
public struct Google_Datastore_V1_ReserveIdsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The ID of the project against which to make the request.
  public var projectID: String = String()

  /// If not empty, the ID of the database against which to make the request.
  public var databaseID: String = String()

  /// Required. A list of keys with complete key paths whose numeric IDs should not be
  /// auto-allocated.
  public var keys: [Google_Datastore_V1_Key] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The response for [Datastore.ReserveIds][google.datastore.v1.Datastore.ReserveIds].
public struct Google_Datastore_V1_ReserveIdsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A mutation to apply to an entity.
public struct Google_Datastore_V1_Mutation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The mutation operation.
  ///
  /// For `insert`, `update`, and `upsert`:
  /// - The entity's key must not be reserved/read-only.
  /// - No property in the entity may have a reserved name,
  ///   not even a property in an entity in a value.
  /// - No value in the entity may have meaning 18,
  ///   not even a value in an entity in another value.
  public var operation: Google_Datastore_V1_Mutation.OneOf_Operation? = nil

  /// The entity to insert. The entity must not already exist.
  /// The entity key's final path element may be incomplete.
  public var insert: Google_Datastore_V1_Entity {
    get {
      if case .insert(let v)? = operation {return v}
      return Google_Datastore_V1_Entity()
    }
    set {operation = .insert(newValue)}
  }

  /// The entity to update. The entity must already exist.
  /// Must have a complete key path.
  public var update: Google_Datastore_V1_Entity {
    get {
      if case .update(let v)? = operation {return v}
      return Google_Datastore_V1_Entity()
    }
    set {operation = .update(newValue)}
  }

  /// The entity to upsert. The entity may or may not already exist.
  /// The entity key's final path element may be incomplete.
  public var upsert: Google_Datastore_V1_Entity {
    get {
      if case .upsert(let v)? = operation {return v}
      return Google_Datastore_V1_Entity()
    }
    set {operation = .upsert(newValue)}
  }

  /// The key of the entity to delete. The entity may or may not already exist.
  /// Must have a complete key path and must not be reserved/read-only.
  public var delete: Google_Datastore_V1_Key {
    get {
      if case .delete(let v)? = operation {return v}
      return Google_Datastore_V1_Key()
    }
    set {operation = .delete(newValue)}
  }

  /// When set, the server will detect whether or not this mutation conflicts
  /// with the current version of the entity on the server. Conflicting mutations
  /// are not applied, and are marked as such in MutationResult.
  public var conflictDetectionStrategy: Google_Datastore_V1_Mutation.OneOf_ConflictDetectionStrategy? = nil

  /// The version of the entity that this mutation is being applied to. If this
  /// does not match the current version on the server, the mutation conflicts.
  public var baseVersion: Int64 {
    get {
      if case .baseVersion(let v)? = conflictDetectionStrategy {return v}
      return 0
    }
    set {conflictDetectionStrategy = .baseVersion(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The mutation operation.
  ///
  /// For `insert`, `update`, and `upsert`:
  /// - The entity's key must not be reserved/read-only.
  /// - No property in the entity may have a reserved name,
  ///   not even a property in an entity in a value.
  /// - No value in the entity may have meaning 18,
  ///   not even a value in an entity in another value.
  public enum OneOf_Operation: Equatable {
    /// The entity to insert. The entity must not already exist.
    /// The entity key's final path element may be incomplete.
    case insert(Google_Datastore_V1_Entity)
    /// The entity to update. The entity must already exist.
    /// Must have a complete key path.
    case update(Google_Datastore_V1_Entity)
    /// The entity to upsert. The entity may or may not already exist.
    /// The entity key's final path element may be incomplete.
    case upsert(Google_Datastore_V1_Entity)
    /// The key of the entity to delete. The entity may or may not already exist.
    /// Must have a complete key path and must not be reserved/read-only.
    case delete(Google_Datastore_V1_Key)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Datastore_V1_Mutation.OneOf_Operation, rhs: Google_Datastore_V1_Mutation.OneOf_Operation) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.insert, .insert): return {
        guard case .insert(let l) = lhs, case .insert(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.update, .update): return {
        guard case .update(let l) = lhs, case .update(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.upsert, .upsert): return {
        guard case .upsert(let l) = lhs, case .upsert(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.delete, .delete): return {
        guard case .delete(let l) = lhs, case .delete(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// When set, the server will detect whether or not this mutation conflicts
  /// with the current version of the entity on the server. Conflicting mutations
  /// are not applied, and are marked as such in MutationResult.
  public enum OneOf_ConflictDetectionStrategy: Equatable {
    /// The version of the entity that this mutation is being applied to. If this
    /// does not match the current version on the server, the mutation conflicts.
    case baseVersion(Int64)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Datastore_V1_Mutation.OneOf_ConflictDetectionStrategy, rhs: Google_Datastore_V1_Mutation.OneOf_ConflictDetectionStrategy) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.baseVersion, .baseVersion): return {
        guard case .baseVersion(let l) = lhs, case .baseVersion(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

/// The result of applying a mutation.
public struct Google_Datastore_V1_MutationResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The automatically allocated key.
  /// Set only when the mutation allocated a key.
  public var key: Google_Datastore_V1_Key {
    get {return _key ?? Google_Datastore_V1_Key()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  public var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  public mutating func clearKey() {self._key = nil}

  /// The version of the entity on the server after processing the mutation. If
  /// the mutation doesn't change anything on the server, then the version will
  /// be the version of the current entity or, if no entity is present, a version
  /// that is strictly greater than the version of any previous entity and less
  /// than the version of any possible future entity.
  public var version: Int64 = 0

  /// Whether a conflict was detected for this mutation. Always false when a
  /// conflict detection strategy field is not set in the mutation.
  public var conflictDetected: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _key: Google_Datastore_V1_Key? = nil
}

/// The options shared by read requests.
public struct Google_Datastore_V1_ReadOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If not specified, lookups and ancestor queries default to
  /// `read_consistency`=`STRONG`, global queries default to
  /// `read_consistency`=`EVENTUAL`.
  public var consistencyType: Google_Datastore_V1_ReadOptions.OneOf_ConsistencyType? = nil

  /// The non-transactional read consistency to use.
  /// Cannot be set to `STRONG` for global queries.
  public var readConsistency: Google_Datastore_V1_ReadOptions.ReadConsistency {
    get {
      if case .readConsistency(let v)? = consistencyType {return v}
      return .unspecified
    }
    set {consistencyType = .readConsistency(newValue)}
  }

  /// The identifier of the transaction in which to read. A
  /// transaction identifier is returned by a call to
  /// [Datastore.BeginTransaction][google.datastore.v1.Datastore.BeginTransaction].
  public var transaction: Data {
    get {
      if case .transaction(let v)? = consistencyType {return v}
      return Data()
    }
    set {consistencyType = .transaction(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// If not specified, lookups and ancestor queries default to
  /// `read_consistency`=`STRONG`, global queries default to
  /// `read_consistency`=`EVENTUAL`.
  public enum OneOf_ConsistencyType: Equatable {
    /// The non-transactional read consistency to use.
    /// Cannot be set to `STRONG` for global queries.
    case readConsistency(Google_Datastore_V1_ReadOptions.ReadConsistency)
    /// The identifier of the transaction in which to read. A
    /// transaction identifier is returned by a call to
    /// [Datastore.BeginTransaction][google.datastore.v1.Datastore.BeginTransaction].
    case transaction(Data)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Datastore_V1_ReadOptions.OneOf_ConsistencyType, rhs: Google_Datastore_V1_ReadOptions.OneOf_ConsistencyType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.readConsistency, .readConsistency): return {
        guard case .readConsistency(let l) = lhs, case .readConsistency(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.transaction, .transaction): return {
        guard case .transaction(let l) = lhs, case .transaction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// The possible values for read consistencies.
  public enum ReadConsistency: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unspecified. This value must not be used.
    case unspecified // = 0

    /// Strong consistency.
    case strong // = 1

    /// Eventual consistency.
    case eventual // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .strong
      case 2: self = .eventual
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .strong: return 1
      case .eventual: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Datastore_V1_ReadOptions.ReadConsistency: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Datastore_V1_ReadOptions.ReadConsistency] = [
    .unspecified,
    .strong,
    .eventual,
  ]
}

#endif  // swift(>=4.2)

/// Options for beginning a new transaction.
///
/// Transactions can be created explicitly with calls to
/// [Datastore.BeginTransaction][google.datastore.v1.Datastore.BeginTransaction] or implicitly by setting
/// [ReadOptions.new_transaction][google.datastore.v1.ReadOptions.new_transaction] in read requests.
public struct Google_Datastore_V1_TransactionOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The `mode` of the transaction, indicating whether write operations are
  /// supported.
  public var mode: Google_Datastore_V1_TransactionOptions.OneOf_Mode? = nil

  /// The transaction should allow both reads and writes.
  public var readWrite: Google_Datastore_V1_TransactionOptions.ReadWrite {
    get {
      if case .readWrite(let v)? = mode {return v}
      return Google_Datastore_V1_TransactionOptions.ReadWrite()
    }
    set {mode = .readWrite(newValue)}
  }

  /// The transaction should only allow reads.
  public var readOnly: Google_Datastore_V1_TransactionOptions.ReadOnly {
    get {
      if case .readOnly(let v)? = mode {return v}
      return Google_Datastore_V1_TransactionOptions.ReadOnly()
    }
    set {mode = .readOnly(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The `mode` of the transaction, indicating whether write operations are
  /// supported.
  public enum OneOf_Mode: Equatable {
    /// The transaction should allow both reads and writes.
    case readWrite(Google_Datastore_V1_TransactionOptions.ReadWrite)
    /// The transaction should only allow reads.
    case readOnly(Google_Datastore_V1_TransactionOptions.ReadOnly)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Datastore_V1_TransactionOptions.OneOf_Mode, rhs: Google_Datastore_V1_TransactionOptions.OneOf_Mode) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.readWrite, .readWrite): return {
        guard case .readWrite(let l) = lhs, case .readWrite(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.readOnly, .readOnly): return {
        guard case .readOnly(let l) = lhs, case .readOnly(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Options specific to read / write transactions.
  public struct ReadWrite {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The transaction identifier of the transaction being retried.
    public var previousTransaction: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Options specific to read-only transactions.
  public struct ReadOnly {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.datastore.v1"

extension Google_Datastore_V1_LookupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LookupRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    8: .standard(proto: "project_id"),
    1: .standard(proto: "read_options"),
    3: .same(proto: "keys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._readOptions) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.keys) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._readOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.keys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keys, fieldNumber: 3)
    }
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Datastore_V1_LookupRequest, rhs: Google_Datastore_V1_LookupRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs._readOptions != rhs._readOptions {return false}
    if lhs.keys != rhs.keys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_LookupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LookupResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "found"),
    2: .same(proto: "missing"),
    3: .same(proto: "deferred"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.found) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.missing) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.deferred) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.found.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.found, fieldNumber: 1)
    }
    if !self.missing.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.missing, fieldNumber: 2)
    }
    if !self.deferred.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.deferred, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Datastore_V1_LookupResponse, rhs: Google_Datastore_V1_LookupResponse) -> Bool {
    if lhs.found != rhs.found {return false}
    if lhs.missing != rhs.missing {return false}
    if lhs.deferred != rhs.deferred {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_RunQueryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RunQueryRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    8: .standard(proto: "project_id"),
    2: .standard(proto: "partition_id"),
    1: .standard(proto: "read_options"),
    3: .same(proto: "query"),
    7: .standard(proto: "gql_query"),
  ]

  fileprivate class _StorageClass {
    var _projectID: String = String()
    var _partitionID: Google_Datastore_V1_PartitionId? = nil
    var _readOptions: Google_Datastore_V1_ReadOptions? = nil
    var _queryType: Google_Datastore_V1_RunQueryRequest.OneOf_QueryType?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _projectID = source._projectID
      _partitionID = source._partitionID
      _readOptions = source._readOptions
      _queryType = source._queryType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._readOptions) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._partitionID) }()
        case 3: try {
          var v: Google_Datastore_V1_Query?
          if let current = _storage._queryType {
            try decoder.handleConflictingOneOf()
            if case .query(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._queryType = .query(v)}
        }()
        case 7: try {
          var v: Google_Datastore_V1_GqlQuery?
          if let current = _storage._queryType {
            try decoder.handleConflictingOneOf()
            if case .gqlQuery(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._queryType = .gqlQuery(v)}
        }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._projectID) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._readOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._partitionID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._queryType {
      case .query?: try {
        guard case .query(let v)? = _storage._queryType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case .gqlQuery?: try {
        guard case .gqlQuery(let v)? = _storage._queryType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case nil: break
      }
      if !_storage._projectID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._projectID, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Datastore_V1_RunQueryRequest, rhs: Google_Datastore_V1_RunQueryRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._projectID != rhs_storage._projectID {return false}
        if _storage._partitionID != rhs_storage._partitionID {return false}
        if _storage._readOptions != rhs_storage._readOptions {return false}
        if _storage._queryType != rhs_storage._queryType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_RunQueryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RunQueryResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "batch"),
    2: .same(proto: "query"),
  ]

  fileprivate class _StorageClass {
    var _batch: Google_Datastore_V1_QueryResultBatch? = nil
    var _query: Google_Datastore_V1_Query? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _batch = source._batch
      _query = source._query
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._batch) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._query) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._batch {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._query {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Datastore_V1_RunQueryResponse, rhs: Google_Datastore_V1_RunQueryResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._batch != rhs_storage._batch {return false}
        if _storage._query != rhs_storage._query {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_BeginTransactionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BeginTransactionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    8: .standard(proto: "project_id"),
    10: .standard(proto: "transaction_options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 8: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._transactionOptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 8)
    }
    if let v = self._transactionOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Datastore_V1_BeginTransactionRequest, rhs: Google_Datastore_V1_BeginTransactionRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs._transactionOptions != rhs._transactionOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_BeginTransactionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BeginTransactionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transaction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.transaction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transaction.isEmpty {
      try visitor.visitSingularBytesField(value: self.transaction, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Datastore_V1_BeginTransactionResponse, rhs: Google_Datastore_V1_BeginTransactionResponse) -> Bool {
    if lhs.transaction != rhs.transaction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_RollbackRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RollbackRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    8: .standard(proto: "project_id"),
    1: .same(proto: "transaction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.transaction) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transaction.isEmpty {
      try visitor.visitSingularBytesField(value: self.transaction, fieldNumber: 1)
    }
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Datastore_V1_RollbackRequest, rhs: Google_Datastore_V1_RollbackRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.transaction != rhs.transaction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_RollbackResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RollbackResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Datastore_V1_RollbackResponse, rhs: Google_Datastore_V1_RollbackResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_CommitRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommitRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    8: .standard(proto: "project_id"),
    5: .same(proto: "mode"),
    1: .same(proto: "transaction"),
    6: .same(proto: "mutations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.transactionSelector != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.transactionSelector = .transaction(v)}
      }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.mutations) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .transaction(let v)? = self.transactionSelector {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    if self.mode != .unspecified {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 5)
    }
    if !self.mutations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mutations, fieldNumber: 6)
    }
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Datastore_V1_CommitRequest, rhs: Google_Datastore_V1_CommitRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs.transactionSelector != rhs.transactionSelector {return false}
    if lhs.mutations != rhs.mutations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_CommitRequest.Mode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MODE_UNSPECIFIED"),
    1: .same(proto: "TRANSACTIONAL"),
    2: .same(proto: "NON_TRANSACTIONAL"),
  ]
}

extension Google_Datastore_V1_CommitResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommitResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .standard(proto: "mutation_results"),
    4: .standard(proto: "index_updates"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.mutationResults) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.indexUpdates) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mutationResults.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mutationResults, fieldNumber: 3)
    }
    if self.indexUpdates != 0 {
      try visitor.visitSingularInt32Field(value: self.indexUpdates, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Datastore_V1_CommitResponse, rhs: Google_Datastore_V1_CommitResponse) -> Bool {
    if lhs.mutationResults != rhs.mutationResults {return false}
    if lhs.indexUpdates != rhs.indexUpdates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_AllocateIdsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AllocateIdsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    8: .standard(proto: "project_id"),
    1: .same(proto: "keys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.keys) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keys, fieldNumber: 1)
    }
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Datastore_V1_AllocateIdsRequest, rhs: Google_Datastore_V1_AllocateIdsRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.keys != rhs.keys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_AllocateIdsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AllocateIdsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.keys) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keys, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Datastore_V1_AllocateIdsResponse, rhs: Google_Datastore_V1_AllocateIdsResponse) -> Bool {
    if lhs.keys != rhs.keys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_ReserveIdsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReserveIdsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    8: .standard(proto: "project_id"),
    9: .standard(proto: "database_id"),
    1: .same(proto: "keys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.keys) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.databaseID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keys, fieldNumber: 1)
    }
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 8)
    }
    if !self.databaseID.isEmpty {
      try visitor.visitSingularStringField(value: self.databaseID, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Datastore_V1_ReserveIdsRequest, rhs: Google_Datastore_V1_ReserveIdsRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.databaseID != rhs.databaseID {return false}
    if lhs.keys != rhs.keys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_ReserveIdsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReserveIdsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Datastore_V1_ReserveIdsResponse, rhs: Google_Datastore_V1_ReserveIdsResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_Mutation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Mutation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .same(proto: "insert"),
    5: .same(proto: "update"),
    6: .same(proto: "upsert"),
    7: .same(proto: "delete"),
    8: .standard(proto: "base_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 4: try {
        var v: Google_Datastore_V1_Entity?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .insert(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .insert(v)}
      }()
      case 5: try {
        var v: Google_Datastore_V1_Entity?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .update(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .update(v)}
      }()
      case 6: try {
        var v: Google_Datastore_V1_Entity?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .upsert(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .upsert(v)}
      }()
      case 7: try {
        var v: Google_Datastore_V1_Key?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .delete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .delete(v)}
      }()
      case 8: try {
        if self.conflictDetectionStrategy != nil {try decoder.handleConflictingOneOf()}
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {self.conflictDetectionStrategy = .baseVersion(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.operation {
    case .insert?: try {
      guard case .insert(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .update?: try {
      guard case .update(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .upsert?: try {
      guard case .upsert(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .delete?: try {
      guard case .delete(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    if case .baseVersion(let v)? = self.conflictDetectionStrategy {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Datastore_V1_Mutation, rhs: Google_Datastore_V1_Mutation) -> Bool {
    if lhs.operation != rhs.operation {return false}
    if lhs.conflictDetectionStrategy != rhs.conflictDetectionStrategy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_MutationResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MutationResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "key"),
    4: .same(proto: "version"),
    5: .standard(proto: "conflict_detected"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularMessageField(value: &self._key) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.version) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.conflictDetected) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._key {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.version != 0 {
      try visitor.visitSingularInt64Field(value: self.version, fieldNumber: 4)
    }
    if self.conflictDetected != false {
      try visitor.visitSingularBoolField(value: self.conflictDetected, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Datastore_V1_MutationResult, rhs: Google_Datastore_V1_MutationResult) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs.version != rhs.version {return false}
    if lhs.conflictDetected != rhs.conflictDetected {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_ReadOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReadOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "read_consistency"),
    2: .same(proto: "transaction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.consistencyType != nil {try decoder.handleConflictingOneOf()}
        var v: Google_Datastore_V1_ReadOptions.ReadConsistency?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {self.consistencyType = .readConsistency(v)}
      }()
      case 2: try {
        if self.consistencyType != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.consistencyType = .transaction(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.consistencyType {
    case .readConsistency?: try {
      guard case .readConsistency(let v)? = self.consistencyType else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .transaction?: try {
      guard case .transaction(let v)? = self.consistencyType else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Datastore_V1_ReadOptions, rhs: Google_Datastore_V1_ReadOptions) -> Bool {
    if lhs.consistencyType != rhs.consistencyType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_ReadOptions.ReadConsistency: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "READ_CONSISTENCY_UNSPECIFIED"),
    1: .same(proto: "STRONG"),
    2: .same(proto: "EVENTUAL"),
  ]
}

extension Google_Datastore_V1_TransactionOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "read_write"),
    2: .standard(proto: "read_only"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Datastore_V1_TransactionOptions.ReadWrite?
        if let current = self.mode {
          try decoder.handleConflictingOneOf()
          if case .readWrite(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.mode = .readWrite(v)}
      }()
      case 2: try {
        var v: Google_Datastore_V1_TransactionOptions.ReadOnly?
        if let current = self.mode {
          try decoder.handleConflictingOneOf()
          if case .readOnly(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.mode = .readOnly(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.mode {
    case .readWrite?: try {
      guard case .readWrite(let v)? = self.mode else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .readOnly?: try {
      guard case .readOnly(let v)? = self.mode else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Datastore_V1_TransactionOptions, rhs: Google_Datastore_V1_TransactionOptions) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_TransactionOptions.ReadWrite: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Datastore_V1_TransactionOptions.protoMessageName + ".ReadWrite"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "previous_transaction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.previousTransaction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.previousTransaction.isEmpty {
      try visitor.visitSingularBytesField(value: self.previousTransaction, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Datastore_V1_TransactionOptions.ReadWrite, rhs: Google_Datastore_V1_TransactionOptions.ReadWrite) -> Bool {
    if lhs.previousTransaction != rhs.previousTransaction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_TransactionOptions.ReadOnly: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Datastore_V1_TransactionOptions.protoMessageName + ".ReadOnly"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Datastore_V1_TransactionOptions.ReadOnly, rhs: Google_Datastore_V1_TransactionOptions.ReadOnly) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

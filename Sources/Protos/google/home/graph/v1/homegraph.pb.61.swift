// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/home/graph/v1/homegraph.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Request type for the
/// [`RequestSyncDevices`](#google.home.graph.v1.HomeGraphApiService.RequestSyncDevices)
/// call.
public struct Google_Home_Graph_V1_RequestSyncDevicesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Third-party user ID.
  public var agentUserID: String = String()

  /// Optional. If set, the request will be added to a queue and a response will
  /// be returned immediately. This enables concurrent requests for the given
  /// `agent_user_id`, but the caller will not receive any error responses.
  public var async: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response type for the
/// [`RequestSyncDevices`](#google.home.graph.v1.HomeGraphApiService.RequestSyncDevices)
/// call.
///
/// Intentionally empty upon success. An HTTP response code is returned
/// with more details upon failure.
public struct Google_Home_Graph_V1_RequestSyncDevicesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request type for the
/// [`ReportStateAndNotification`](#google.home.graph.v1.HomeGraphApiService.ReportStateAndNotification)
/// call. It may include states, notifications, or both. States and notifications
/// are defined per `device_id` (for example, "123" and "456" in the following
/// example).
/// # Example
///
/// ```json
/// {
///   "requestId": "ff36a3cc-ec34-11e6-b1a0-64510650abcf",
///   "agentUserId": "1234",
///   "payload": {
///     "devices": {
///       "states": {
///         "123": {
///           "on": true
///         },
///         "456": {
///           "on": true,
///           "brightness": 10
///         }
///       },
///     }
///   }
/// }
/// ```
public struct Google_Home_Graph_V1_ReportStateAndNotificationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Request ID used for debugging.
  public var requestID: String = String()

  /// Unique identifier per event (for example, a doorbell press).
  public var eventID: String = String()

  /// Required. Third-party user ID.
  public var agentUserID: String = String()

  /// Token to maintain state in the follow up notification response.
  /// Deprecated. See the [notifications
  /// guide](https://developers.google.com/assistant/smarthome/develop/notifications)
  /// for details on implementing follow up notifications.
  public var followUpToken: String = String()

  /// Required. State of devices to update and notification metadata for devices.
  public var payload: Google_Home_Graph_V1_StateAndNotificationPayload {
    get {return _payload ?? Google_Home_Graph_V1_StateAndNotificationPayload()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  public var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  public mutating func clearPayload() {self._payload = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _payload: Google_Home_Graph_V1_StateAndNotificationPayload? = nil
}

/// Response type for the
/// [`ReportStateAndNotification`](#google.home.graph.v1.HomeGraphApiService.ReportStateAndNotification)
/// call.
public struct Google_Home_Graph_V1_ReportStateAndNotificationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Request ID copied from
  /// [ReportStateAndNotificationRequest][google.home.graph.v1.ReportStateAndNotificationRequest].
  public var requestID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Payload containing the state and notification information for devices.
public struct Google_Home_Graph_V1_StateAndNotificationPayload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The devices for updating state and sending notifications.
  public var devices: Google_Home_Graph_V1_ReportStateAndNotificationDevice {
    get {return _devices ?? Google_Home_Graph_V1_ReportStateAndNotificationDevice()}
    set {_devices = newValue}
  }
  /// Returns true if `devices` has been explicitly set.
  public var hasDevices: Bool {return self._devices != nil}
  /// Clears the value of `devices`. Subsequent reads from it will return its default value.
  public mutating func clearDevices() {self._devices = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _devices: Google_Home_Graph_V1_ReportStateAndNotificationDevice? = nil
}

/// The states and notifications specific to a device.
public struct Google_Home_Graph_V1_ReportStateAndNotificationDevice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// States of devices to update. See the **Device STATES** section
  /// of the individual trait [reference
  /// guides](https://developers.google.com/assistant/smarthome/traits).
  public var states: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _states ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_states = newValue}
  }
  /// Returns true if `states` has been explicitly set.
  public var hasStates: Bool {return self._states != nil}
  /// Clears the value of `states`. Subsequent reads from it will return its default value.
  public mutating func clearStates() {self._states = nil}

  /// Notifications metadata for devices. See the **Device NOTIFICATIONS**
  /// section of the individual trait [reference
  /// guides](https://developers.google.com/assistant/smarthome/traits).
  public var notifications: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _notifications ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_notifications = newValue}
  }
  /// Returns true if `notifications` has been explicitly set.
  public var hasNotifications: Bool {return self._notifications != nil}
  /// Clears the value of `notifications`. Subsequent reads from it will return its default value.
  public mutating func clearNotifications() {self._notifications = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _states: SwiftProtobuf.Google_Protobuf_Struct? = nil
  fileprivate var _notifications: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

/// Request type for the
/// [`DeleteAgentUser`](#google.home.graph.v1.HomeGraphApiService.DeleteAgentUser)
/// call.
public struct Google_Home_Graph_V1_DeleteAgentUserRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Request ID used for debugging.
  public var requestID: String = String()

  /// Required. Third-party user ID.
  public var agentUserID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request type for the
/// [`Query`](#google.home.graph.v1.HomeGraphApiService.Query) call.
public struct Google_Home_Graph_V1_QueryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Request ID used for debugging.
  public var requestID: String = String()

  /// Required. Third-party user ID.
  public var agentUserID: String = String()

  /// Required. Inputs containing third-party device IDs for which to
  /// get the device states.
  public var inputs: [Google_Home_Graph_V1_QueryRequestInput] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Device ID inputs to [QueryRequest][google.home.graph.v1.QueryRequest].
public struct Google_Home_Graph_V1_QueryRequestInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Payload containing third-party device IDs.
  public var payload: Google_Home_Graph_V1_QueryRequestPayload {
    get {return _payload ?? Google_Home_Graph_V1_QueryRequestPayload()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  public var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  public mutating func clearPayload() {self._payload = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _payload: Google_Home_Graph_V1_QueryRequestPayload? = nil
}

/// Payload containing device IDs.
public struct Google_Home_Graph_V1_QueryRequestPayload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Third-party device IDs for which to get the device states.
  public var devices: [Google_Home_Graph_V1_AgentDeviceId] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Third-party device ID for one device.
public struct Google_Home_Graph_V1_AgentDeviceId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Third-party device ID.
  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response type for the
/// [`Query`](#google.home.graph.v1.HomeGraphApiService.Query) call.
/// This should follow the same format as the Google smart home
/// `action.devices.QUERY`
/// [response](https://developers.google.com/assistant/smarthome/reference/intent/query).
/// # Example
///
/// ```json
/// {
///   "requestId": "ff36a3cc-ec34-11e6-b1a0-64510650abcf",
///   "payload": {
///     "devices": {
///       "123": {
///         "on": true,
///         "online": true
///       },
///       "456": {
///         "on": true,
///         "online": true,
///         "brightness": 80,
///         "color": {
///           "name": "cerulean",
///           "spectrumRGB": 31655
///         }
///       }
///     }
///   }
/// }
/// ```
public struct Google_Home_Graph_V1_QueryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Request ID used for debugging. Copied from the request.
  public var requestID: String = String()

  /// Device states for the devices given in the request.
  public var payload: Google_Home_Graph_V1_QueryResponsePayload {
    get {return _payload ?? Google_Home_Graph_V1_QueryResponsePayload()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  public var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  public mutating func clearPayload() {self._payload = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _payload: Google_Home_Graph_V1_QueryResponsePayload? = nil
}

/// Payload containing device states information.
public struct Google_Home_Graph_V1_QueryResponsePayload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// States of the devices. Map of third-party device ID to struct of device
  /// states.
  public var devices: Dictionary<String,SwiftProtobuf.Google_Protobuf_Struct> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request type for the [`Sync`](#google.home.graph.v1.HomeGraphApiService.Sync)
/// call.
public struct Google_Home_Graph_V1_SyncRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Request ID used for debugging.
  public var requestID: String = String()

  /// Required. Third-party user ID.
  public var agentUserID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response type for the
/// [`Sync`](#google.home.graph.v1.HomeGraphApiService.Sync) call.
/// This should follow the same format as the Google smart home
/// `action.devices.SYNC`
/// [response](https://developers.google.com/assistant/smarthome/reference/intent/sync).
/// # Example
///
/// ```json
/// {
///   "requestId": "ff36a3cc-ec34-11e6-b1a0-64510650abcf",
///   "payload": {
///     "agentUserId": "1836.15267389",
///     "devices": [{
///       "id": "123",
///       "type": "action.devices.types.OUTLET",
///       "traits": [
///         "action.devices.traits.OnOff"
///       ],
///       "name": {
///         "defaultNames": ["My Outlet 1234"],
///         "name": "Night light",
///         "nicknames": ["wall plug"]
///       },
///       "willReportState": false,
///       "deviceInfo": {
///         "manufacturer": "lights-out-inc",
///         "model": "hs1234",
///         "hwVersion": "3.2",
///         "swVersion": "11.4"
///       },
///       "customData": {
///         "fooValue": 74,
///         "barValue": true,
///         "bazValue": "foo"
///       }
///     }]
///   }
/// }
/// ```
public struct Google_Home_Graph_V1_SyncResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Request ID used for debugging. Copied from the request.
  public var requestID: String = String()

  /// Devices associated with the third-party user.
  public var payload: Google_Home_Graph_V1_SyncResponsePayload {
    get {return _payload ?? Google_Home_Graph_V1_SyncResponsePayload()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  public var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  public mutating func clearPayload() {self._payload = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _payload: Google_Home_Graph_V1_SyncResponsePayload? = nil
}

/// Payload containing device information.
public struct Google_Home_Graph_V1_SyncResponsePayload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Third-party user ID
  public var agentUserID: String = String()

  /// Devices associated with the third-party user.
  public var devices: [Google_Home_Graph_V1_Device] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.home.graph.v1"

extension Google_Home_Graph_V1_RequestSyncDevicesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestSyncDevicesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "agent_user_id"),
    2: .same(proto: "async"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.agentUserID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.async) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.agentUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.agentUserID, fieldNumber: 1)
    }
    if self.async != false {
      try visitor.visitSingularBoolField(value: self.async, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Home_Graph_V1_RequestSyncDevicesRequest, rhs: Google_Home_Graph_V1_RequestSyncDevicesRequest) -> Bool {
    if lhs.agentUserID != rhs.agentUserID {return false}
    if lhs.async != rhs.async {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Home_Graph_V1_RequestSyncDevicesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestSyncDevicesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Home_Graph_V1_RequestSyncDevicesResponse, rhs: Google_Home_Graph_V1_RequestSyncDevicesResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Home_Graph_V1_ReportStateAndNotificationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReportStateAndNotificationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    4: .standard(proto: "event_id"),
    2: .standard(proto: "agent_user_id"),
    5: .standard(proto: "follow_up_token"),
    3: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.agentUserID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.eventID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.followUpToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    if !self.agentUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.agentUserID, fieldNumber: 2)
    }
    if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.eventID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventID, fieldNumber: 4)
    }
    if !self.followUpToken.isEmpty {
      try visitor.visitSingularStringField(value: self.followUpToken, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Home_Graph_V1_ReportStateAndNotificationRequest, rhs: Google_Home_Graph_V1_ReportStateAndNotificationRequest) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.eventID != rhs.eventID {return false}
    if lhs.agentUserID != rhs.agentUserID {return false}
    if lhs.followUpToken != rhs.followUpToken {return false}
    if lhs._payload != rhs._payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Home_Graph_V1_ReportStateAndNotificationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReportStateAndNotificationResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Home_Graph_V1_ReportStateAndNotificationResponse, rhs: Google_Home_Graph_V1_ReportStateAndNotificationResponse) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Home_Graph_V1_StateAndNotificationPayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StateAndNotificationPayload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "devices"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._devices) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._devices {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Home_Graph_V1_StateAndNotificationPayload, rhs: Google_Home_Graph_V1_StateAndNotificationPayload) -> Bool {
    if lhs._devices != rhs._devices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Home_Graph_V1_ReportStateAndNotificationDevice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReportStateAndNotificationDevice"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "states"),
    2: .same(proto: "notifications"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._states) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._notifications) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._states {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._notifications {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Home_Graph_V1_ReportStateAndNotificationDevice, rhs: Google_Home_Graph_V1_ReportStateAndNotificationDevice) -> Bool {
    if lhs._states != rhs._states {return false}
    if lhs._notifications != rhs._notifications {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Home_Graph_V1_DeleteAgentUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteAgentUserRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "agent_user_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.agentUserID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    if !self.agentUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.agentUserID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Home_Graph_V1_DeleteAgentUserRequest, rhs: Google_Home_Graph_V1_DeleteAgentUserRequest) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.agentUserID != rhs.agentUserID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Home_Graph_V1_QueryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "agent_user_id"),
    3: .same(proto: "inputs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.agentUserID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.inputs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    if !self.agentUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.agentUserID, fieldNumber: 2)
    }
    if !self.inputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputs, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Home_Graph_V1_QueryRequest, rhs: Google_Home_Graph_V1_QueryRequest) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.agentUserID != rhs.agentUserID {return false}
    if lhs.inputs != rhs.inputs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Home_Graph_V1_QueryRequestInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryRequestInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Home_Graph_V1_QueryRequestInput, rhs: Google_Home_Graph_V1_QueryRequestInput) -> Bool {
    if lhs._payload != rhs._payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Home_Graph_V1_QueryRequestPayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryRequestPayload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "devices"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.devices) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.devices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.devices, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Home_Graph_V1_QueryRequestPayload, rhs: Google_Home_Graph_V1_QueryRequestPayload) -> Bool {
    if lhs.devices != rhs.devices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Home_Graph_V1_AgentDeviceId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AgentDeviceId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Home_Graph_V1_AgentDeviceId, rhs: Google_Home_Graph_V1_AgentDeviceId) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Home_Graph_V1_QueryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Home_Graph_V1_QueryResponse, rhs: Google_Home_Graph_V1_QueryResponse) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs._payload != rhs._payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Home_Graph_V1_QueryResponsePayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryResponsePayload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "devices"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Struct>.self, value: &self.devices) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.devices.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Struct>.self, value: self.devices, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Home_Graph_V1_QueryResponsePayload, rhs: Google_Home_Graph_V1_QueryResponsePayload) -> Bool {
    if lhs.devices != rhs.devices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Home_Graph_V1_SyncRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SyncRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "agent_user_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.agentUserID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    if !self.agentUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.agentUserID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Home_Graph_V1_SyncRequest, rhs: Google_Home_Graph_V1_SyncRequest) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.agentUserID != rhs.agentUserID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Home_Graph_V1_SyncResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SyncResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Home_Graph_V1_SyncResponse, rhs: Google_Home_Graph_V1_SyncResponse) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs._payload != rhs._payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Home_Graph_V1_SyncResponsePayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SyncResponsePayload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "agent_user_id"),
    2: .same(proto: "devices"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.agentUserID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.devices) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.agentUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.agentUserID, fieldNumber: 1)
    }
    if !self.devices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.devices, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Home_Graph_V1_SyncResponsePayload, rhs: Google_Home_Graph_V1_SyncResponsePayload) -> Bool {
    if lhs.agentUserID != rhs.agentUserID {return false}
    if lhs.devices != rhs.devices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

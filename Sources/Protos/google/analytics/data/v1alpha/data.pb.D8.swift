// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/analytics/data/v1alpha/data.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Represents aggregation of metrics.
public enum Google_Analytics_Data_V1alpha_MetricAggregation: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Unspecified operator.
  case unspecified // = 0

  /// SUM operator.
  case total // = 1

  /// Minimum operator.
  case minimum // = 5

  /// Maximum operator.
  case maximum // = 6

  /// Count operator.
  case count // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .total
    case 4: self = .count
    case 5: self = .minimum
    case 6: self = .maximum
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .total: return 1
    case .count: return 4
    case .minimum: return 5
    case .maximum: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Analytics_Data_V1alpha_MetricAggregation: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Analytics_Data_V1alpha_MetricAggregation] = [
    .unspecified,
    .total,
    .minimum,
    .maximum,
    .count,
  ]
}

#endif  // swift(>=4.2)

/// A metric's value type.
public enum Google_Analytics_Data_V1alpha_MetricType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Unspecified type.
  case unspecified // = 0

  /// Integer type.
  case typeInteger // = 1

  /// Floating point type.
  case typeFloat // = 2

  /// A duration of seconds; a special floating point type.
  case typeSeconds // = 4

  /// A duration in milliseconds; a special floating point type.
  case typeMilliseconds // = 5

  /// A duration in minutes; a special floating point type.
  case typeMinutes // = 6

  /// A duration in hours; a special floating point type.
  case typeHours // = 7

  /// A custom metric of standard type; a special floating point type.
  case typeStandard // = 8

  /// An amount of money; a special floating point type.
  case typeCurrency // = 9

  /// A length in feet; a special floating point type.
  case typeFeet // = 10

  /// A length in miles; a special floating point type.
  case typeMiles // = 11

  /// A length in meters; a special floating point type.
  case typeMeters // = 12

  /// A length in kilometers; a special floating point type.
  case typeKilometers // = 13
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .typeInteger
    case 2: self = .typeFloat
    case 4: self = .typeSeconds
    case 5: self = .typeMilliseconds
    case 6: self = .typeMinutes
    case 7: self = .typeHours
    case 8: self = .typeStandard
    case 9: self = .typeCurrency
    case 10: self = .typeFeet
    case 11: self = .typeMiles
    case 12: self = .typeMeters
    case 13: self = .typeKilometers
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .typeInteger: return 1
    case .typeFloat: return 2
    case .typeSeconds: return 4
    case .typeMilliseconds: return 5
    case .typeMinutes: return 6
    case .typeHours: return 7
    case .typeStandard: return 8
    case .typeCurrency: return 9
    case .typeFeet: return 10
    case .typeMiles: return 11
    case .typeMeters: return 12
    case .typeKilometers: return 13
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Analytics_Data_V1alpha_MetricType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Analytics_Data_V1alpha_MetricType] = [
    .unspecified,
    .typeInteger,
    .typeFloat,
    .typeSeconds,
    .typeMilliseconds,
    .typeMinutes,
    .typeHours,
    .typeStandard,
    .typeCurrency,
    .typeFeet,
    .typeMiles,
    .typeMeters,
    .typeKilometers,
  ]
}

#endif  // swift(>=4.2)

/// A contiguous set of days: startDate, startDate + 1, ..., endDate. Requests
/// are allowed up to 4 date ranges, and the union of the ranges can cover up to
/// 1 year.
public struct Google_Analytics_Data_V1alpha_DateRange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The inclusive start date for the query in the format `YYYY-MM-DD`. Cannot
  /// be after `end_date`. The format `NdaysAgo`, `yesterday`, or `today` is also
  /// accepted, and in that case, the date is inferred based on the property's
  /// reporting time zone.
  public var startDate: String = String()

  /// The inclusive end date for the query in the format `YYYY-MM-DD`. Cannot
  /// be before `start_date`. The format `NdaysAgo`, `yesterday`, or `today` is
  /// also accepted, and in that case, the date is inferred based on the
  /// property's reporting time zone.
  public var endDate: String = String()

  /// Assigns a name to this date range. The dimension `dateRange` is valued to
  /// this name in a report response. If set, cannot begin with `date_range_` or
  /// `RESERVED_`. If not set, date ranges are named by their zero based index in
  /// the request: `date_range_0`, `date_range_1`, etc.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The unique identifier of the property whose events are tracked.
public struct Google_Analytics_Data_V1alpha_Entity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A Google Analytics GA4 property id. To learn more, see [where to find your
  /// Property
  /// ID](https://developers.google.com/analytics/trusted-testing/analytics-data/property-id).
  public var propertyID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Dimensions are attributes of your data. For example, the dimension city
/// indicates the city from which an event originates. Dimension values in report
/// responses are strings; for example, city could be "Paris" or "New York".
/// Requests are allowed up to 8 dimensions.
public struct Google_Analytics_Data_V1alpha_Dimension {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the dimension. See the [API
  /// Dimensions](https://developers.google.com/analytics/trusted-testing/analytics-data/api-schema#dimensions)
  /// for the list of dimension names.
  ///
  /// If `dimensionExpression` is specified, `name` can be any string that you
  /// would like. For example if a `dimensionExpression` concatenates `country`
  /// and `city`, you could call that dimension `countryAndCity`.
  ///
  /// Dimensions are referenced by `name` in `dimensionFilter`, `orderBys`,
  /// `dimensionExpression`, and `pivots`.
  public var name: String = String()

  /// One dimension can be the result of an expression of multiple dimensions.
  /// For example, dimension "country, city": concatenate(country, ", ", city).
  public var dimensionExpression: Google_Analytics_Data_V1alpha_DimensionExpression {
    get {return _dimensionExpression ?? Google_Analytics_Data_V1alpha_DimensionExpression()}
    set {_dimensionExpression = newValue}
  }
  /// Returns true if `dimensionExpression` has been explicitly set.
  public var hasDimensionExpression: Bool {return self._dimensionExpression != nil}
  /// Clears the value of `dimensionExpression`. Subsequent reads from it will return its default value.
  public mutating func clearDimensionExpression() {self._dimensionExpression = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _dimensionExpression: Google_Analytics_Data_V1alpha_DimensionExpression? = nil
}

/// Used to express a dimension which is the result of a formula of multiple
/// dimensions. Example usages:
/// 1) lower_case(dimension)
/// 2) concatenate(dimension1, symbol, dimension2).
public struct Google_Analytics_Data_V1alpha_DimensionExpression {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specify one type of dimension expression for `DimensionExpression`.
  public var oneExpression: Google_Analytics_Data_V1alpha_DimensionExpression.OneOf_OneExpression? = nil

  /// Used to convert a dimension value to lower case.
  public var lowerCase: Google_Analytics_Data_V1alpha_DimensionExpression.CaseExpression {
    get {
      if case .lowerCase(let v)? = oneExpression {return v}
      return Google_Analytics_Data_V1alpha_DimensionExpression.CaseExpression()
    }
    set {oneExpression = .lowerCase(newValue)}
  }

  /// Used to convert a dimension value to upper case.
  public var upperCase: Google_Analytics_Data_V1alpha_DimensionExpression.CaseExpression {
    get {
      if case .upperCase(let v)? = oneExpression {return v}
      return Google_Analytics_Data_V1alpha_DimensionExpression.CaseExpression()
    }
    set {oneExpression = .upperCase(newValue)}
  }

  /// Used to combine dimension values to a single dimension.
  /// For example, dimension "country, city": concatenate(country, ", ", city).
  public var concatenate: Google_Analytics_Data_V1alpha_DimensionExpression.ConcatenateExpression {
    get {
      if case .concatenate(let v)? = oneExpression {return v}
      return Google_Analytics_Data_V1alpha_DimensionExpression.ConcatenateExpression()
    }
    set {oneExpression = .concatenate(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Specify one type of dimension expression for `DimensionExpression`.
  public enum OneOf_OneExpression: Equatable {
    /// Used to convert a dimension value to lower case.
    case lowerCase(Google_Analytics_Data_V1alpha_DimensionExpression.CaseExpression)
    /// Used to convert a dimension value to upper case.
    case upperCase(Google_Analytics_Data_V1alpha_DimensionExpression.CaseExpression)
    /// Used to combine dimension values to a single dimension.
    /// For example, dimension "country, city": concatenate(country, ", ", city).
    case concatenate(Google_Analytics_Data_V1alpha_DimensionExpression.ConcatenateExpression)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Analytics_Data_V1alpha_DimensionExpression.OneOf_OneExpression, rhs: Google_Analytics_Data_V1alpha_DimensionExpression.OneOf_OneExpression) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.lowerCase, .lowerCase): return {
        guard case .lowerCase(let l) = lhs, case .lowerCase(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.upperCase, .upperCase): return {
        guard case .upperCase(let l) = lhs, case .upperCase(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.concatenate, .concatenate): return {
        guard case .concatenate(let l) = lhs, case .concatenate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Used to convert a dimension value to a single case.
  public struct CaseExpression {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Name of a dimension. The name must refer back to a name in dimensions
    /// field of the request.
    public var dimensionName: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Used to combine dimension values to a single dimension.
  public struct ConcatenateExpression {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Names of dimensions. The names must refer back to names in the dimensions
    /// field of the request.
    public var dimensionNames: [String] = []

    /// The delimiter placed between dimension names.
    ///
    /// Delimiters are often single characters such as "|" or "," but can be
    /// longer strings. If a dimension value contains the delimiter, both will be
    /// present in response with no distinction. For example if dimension 1 value
    /// = "US,FR", dimension 2 value = "JP", and delimiter = ",", then the
    /// response will contain "US,FR,JP".
    public var delimiter: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// The quantitative measurements of a report. For example, the metric
/// `eventCount` is the total number of events. Requests are allowed up to 10
/// metrics.
public struct Google_Analytics_Data_V1alpha_Metric {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the metric. See the [API
  /// Metrics](https://developers.google.com/analytics/trusted-testing/analytics-data/api-schema#metrics)
  /// for the list of metric names.
  ///
  /// If `expression` is specified, `name` can be any string that you would like.
  /// For example if `expression` is `screenPageViews/sessions`, you could call
  /// that metric's name = `viewsPerSession`.
  ///
  /// Metrics are referenced by `name` in `metricFilter`, `orderBys`, and metric
  /// `expression`.
  public var name: String = String()

  /// A mathematical expression for derived metrics. For example, the metric
  /// Event count per user is `eventCount/totalUsers`.
  public var expression: String = String()

  /// Indicates if a metric is invisible in the report response. If a metric is
  /// invisible, the metric will not produce a column in the response, but can be
  /// used in `metricFilter`, `orderBys`, or a metric `expression`.
  public var invisible: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// To express dimension or metric filters.
/// The fields in the same FilterExpression need to be either all dimensions or
/// all metrics.
public struct Google_Analytics_Data_V1alpha_FilterExpression {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specify one type of filter expression for `FilterExpression`.
  public var expr: OneOf_Expr? {
    get {return _storage._expr}
    set {_uniqueStorage()._expr = newValue}
  }

  /// The FilterExpressions in and_group have an AND relationship.
  public var andGroup: Google_Analytics_Data_V1alpha_FilterExpressionList {
    get {
      if case .andGroup(let v)? = _storage._expr {return v}
      return Google_Analytics_Data_V1alpha_FilterExpressionList()
    }
    set {_uniqueStorage()._expr = .andGroup(newValue)}
  }

  /// The FilterExpressions in or_group have an OR relationship.
  public var orGroup: Google_Analytics_Data_V1alpha_FilterExpressionList {
    get {
      if case .orGroup(let v)? = _storage._expr {return v}
      return Google_Analytics_Data_V1alpha_FilterExpressionList()
    }
    set {_uniqueStorage()._expr = .orGroup(newValue)}
  }

  /// The FilterExpression is NOT of not_expression.
  public var notExpression: Google_Analytics_Data_V1alpha_FilterExpression {
    get {
      if case .notExpression(let v)? = _storage._expr {return v}
      return Google_Analytics_Data_V1alpha_FilterExpression()
    }
    set {_uniqueStorage()._expr = .notExpression(newValue)}
  }

  /// A primitive filter.
  /// All fields in filter in same FilterExpression needs to be either all
  /// dimensions or metrics.
  public var filter: Google_Analytics_Data_V1alpha_Filter {
    get {
      if case .filter(let v)? = _storage._expr {return v}
      return Google_Analytics_Data_V1alpha_Filter()
    }
    set {_uniqueStorage()._expr = .filter(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Specify one type of filter expression for `FilterExpression`.
  public enum OneOf_Expr: Equatable {
    /// The FilterExpressions in and_group have an AND relationship.
    case andGroup(Google_Analytics_Data_V1alpha_FilterExpressionList)
    /// The FilterExpressions in or_group have an OR relationship.
    case orGroup(Google_Analytics_Data_V1alpha_FilterExpressionList)
    /// The FilterExpression is NOT of not_expression.
    case notExpression(Google_Analytics_Data_V1alpha_FilterExpression)
    /// A primitive filter.
    /// All fields in filter in same FilterExpression needs to be either all
    /// dimensions or metrics.
    case filter(Google_Analytics_Data_V1alpha_Filter)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Analytics_Data_V1alpha_FilterExpression.OneOf_Expr, rhs: Google_Analytics_Data_V1alpha_FilterExpression.OneOf_Expr) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.andGroup, .andGroup): return {
        guard case .andGroup(let l) = lhs, case .andGroup(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.orGroup, .orGroup): return {
        guard case .orGroup(let l) = lhs, case .orGroup(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.notExpression, .notExpression): return {
        guard case .notExpression(let l) = lhs, case .notExpression(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.filter, .filter): return {
        guard case .filter(let l) = lhs, case .filter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A list of filter expressions.
public struct Google_Analytics_Data_V1alpha_FilterExpressionList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of filter expressions.
  public var expressions: [Google_Analytics_Data_V1alpha_FilterExpression] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// An expression to filter dimension or metric values.
public struct Google_Analytics_Data_V1alpha_Filter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The dimension name or metric name. Must be a name defined in dimensions
  /// or metrics.
  public var fieldName: String = String()

  /// Specify one type of filter for `Filter`.
  public var oneFilter: Google_Analytics_Data_V1alpha_Filter.OneOf_OneFilter? = nil

  /// A filter for null values. If True, a null dimension value is matched by
  /// this filter. Null filter is commonly used inside a NOT filter
  /// expression. For example, a NOT expression of a null filter removes rows
  /// when a dimension is null.
  public var nullFilter: Bool {
    get {
      if case .nullFilter(let v)? = oneFilter {return v}
      return false
    }
    set {oneFilter = .nullFilter(newValue)}
  }

  /// Strings related filter.
  public var stringFilter: Google_Analytics_Data_V1alpha_Filter.StringFilter {
    get {
      if case .stringFilter(let v)? = oneFilter {return v}
      return Google_Analytics_Data_V1alpha_Filter.StringFilter()
    }
    set {oneFilter = .stringFilter(newValue)}
  }

  /// A filter for in list values.
  public var inListFilter: Google_Analytics_Data_V1alpha_Filter.InListFilter {
    get {
      if case .inListFilter(let v)? = oneFilter {return v}
      return Google_Analytics_Data_V1alpha_Filter.InListFilter()
    }
    set {oneFilter = .inListFilter(newValue)}
  }

  /// A filter for numeric or date values.
  public var numericFilter: Google_Analytics_Data_V1alpha_Filter.NumericFilter {
    get {
      if case .numericFilter(let v)? = oneFilter {return v}
      return Google_Analytics_Data_V1alpha_Filter.NumericFilter()
    }
    set {oneFilter = .numericFilter(newValue)}
  }

  /// A filter for two values.
  public var betweenFilter: Google_Analytics_Data_V1alpha_Filter.BetweenFilter {
    get {
      if case .betweenFilter(let v)? = oneFilter {return v}
      return Google_Analytics_Data_V1alpha_Filter.BetweenFilter()
    }
    set {oneFilter = .betweenFilter(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Specify one type of filter for `Filter`.
  public enum OneOf_OneFilter: Equatable {
    /// A filter for null values. If True, a null dimension value is matched by
    /// this filter. Null filter is commonly used inside a NOT filter
    /// expression. For example, a NOT expression of a null filter removes rows
    /// when a dimension is null.
    case nullFilter(Bool)
    /// Strings related filter.
    case stringFilter(Google_Analytics_Data_V1alpha_Filter.StringFilter)
    /// A filter for in list values.
    case inListFilter(Google_Analytics_Data_V1alpha_Filter.InListFilter)
    /// A filter for numeric or date values.
    case numericFilter(Google_Analytics_Data_V1alpha_Filter.NumericFilter)
    /// A filter for two values.
    case betweenFilter(Google_Analytics_Data_V1alpha_Filter.BetweenFilter)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Analytics_Data_V1alpha_Filter.OneOf_OneFilter, rhs: Google_Analytics_Data_V1alpha_Filter.OneOf_OneFilter) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.nullFilter, .nullFilter): return {
        guard case .nullFilter(let l) = lhs, case .nullFilter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stringFilter, .stringFilter): return {
        guard case .stringFilter(let l) = lhs, case .stringFilter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.inListFilter, .inListFilter): return {
        guard case .inListFilter(let l) = lhs, case .inListFilter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.numericFilter, .numericFilter): return {
        guard case .numericFilter(let l) = lhs, case .numericFilter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.betweenFilter, .betweenFilter): return {
        guard case .betweenFilter(let l) = lhs, case .betweenFilter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// The filter for string
  public struct StringFilter {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The match type for this filter.
    public var matchType: Google_Analytics_Data_V1alpha_Filter.StringFilter.MatchType = .unspecified

    /// The string value used for the matching.
    public var value: String = String()

    /// If true, the string value is case sensitive.
    public var caseSensitive: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The match type of a string filter
    public enum MatchType: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// Unspecified
      case unspecified // = 0

      /// Exact match of the string value.
      case exact // = 1

      /// Begins with the string value.
      case beginsWith // = 2

      /// Ends with the string value.
      case endsWith // = 3

      /// Contains the string value.
      case contains // = 4

      /// Full regular expression match with the string value.
      case fullRegexp // = 5

      /// Partial regular expression match with the string value.
      case partialRegexp // = 6
      case UNRECOGNIZED(Int)

      public init() {
        self = .unspecified
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .exact
        case 2: self = .beginsWith
        case 3: self = .endsWith
        case 4: self = .contains
        case 5: self = .fullRegexp
        case 6: self = .partialRegexp
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .exact: return 1
        case .beginsWith: return 2
        case .endsWith: return 3
        case .contains: return 4
        case .fullRegexp: return 5
        case .partialRegexp: return 6
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  /// The result needs to be in a list of string values.
  public struct InListFilter {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The list of string values.
    /// Must be non-empty.
    public var values: [String] = []

    /// If true, the string value is case sensitive.
    public var caseSensitive: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Filters for numeric or date values.
  public struct NumericFilter {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The operation type for this filter.
    public var operation: Google_Analytics_Data_V1alpha_Filter.NumericFilter.Operation = .unspecified

    /// A numeric value or a date value.
    public var value: Google_Analytics_Data_V1alpha_NumericValue {
      get {return _value ?? Google_Analytics_Data_V1alpha_NumericValue()}
      set {_value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    public var hasValue: Bool {return self._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    public mutating func clearValue() {self._value = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The operation applied to a numeric filter
    public enum Operation: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// Unspecified.
      case unspecified // = 0

      /// Equal
      case equal // = 1

      /// Less than
      case lessThan // = 2

      /// Less than or equal
      case lessThanOrEqual // = 3

      /// Greater than
      case greaterThan // = 4

      /// Greater than or equal
      case greaterThanOrEqual // = 5
      case UNRECOGNIZED(Int)

      public init() {
        self = .unspecified
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .equal
        case 2: self = .lessThan
        case 3: self = .lessThanOrEqual
        case 4: self = .greaterThan
        case 5: self = .greaterThanOrEqual
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .equal: return 1
        case .lessThan: return 2
        case .lessThanOrEqual: return 3
        case .greaterThan: return 4
        case .greaterThanOrEqual: return 5
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}

    fileprivate var _value: Google_Analytics_Data_V1alpha_NumericValue? = nil
  }

  /// To express that the result needs to be between two numbers (inclusive).
  public struct BetweenFilter {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Begins with this number.
    public var fromValue: Google_Analytics_Data_V1alpha_NumericValue {
      get {return _fromValue ?? Google_Analytics_Data_V1alpha_NumericValue()}
      set {_fromValue = newValue}
    }
    /// Returns true if `fromValue` has been explicitly set.
    public var hasFromValue: Bool {return self._fromValue != nil}
    /// Clears the value of `fromValue`. Subsequent reads from it will return its default value.
    public mutating func clearFromValue() {self._fromValue = nil}

    /// Ends with this number.
    public var toValue: Google_Analytics_Data_V1alpha_NumericValue {
      get {return _toValue ?? Google_Analytics_Data_V1alpha_NumericValue()}
      set {_toValue = newValue}
    }
    /// Returns true if `toValue` has been explicitly set.
    public var hasToValue: Bool {return self._toValue != nil}
    /// Clears the value of `toValue`. Subsequent reads from it will return its default value.
    public mutating func clearToValue() {self._toValue = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _fromValue: Google_Analytics_Data_V1alpha_NumericValue? = nil
    fileprivate var _toValue: Google_Analytics_Data_V1alpha_NumericValue? = nil
  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Analytics_Data_V1alpha_Filter.StringFilter.MatchType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Analytics_Data_V1alpha_Filter.StringFilter.MatchType] = [
    .unspecified,
    .exact,
    .beginsWith,
    .endsWith,
    .contains,
    .fullRegexp,
    .partialRegexp,
  ]
}

extension Google_Analytics_Data_V1alpha_Filter.NumericFilter.Operation: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Analytics_Data_V1alpha_Filter.NumericFilter.Operation] = [
    .unspecified,
    .equal,
    .lessThan,
    .lessThanOrEqual,
    .greaterThan,
    .greaterThanOrEqual,
  ]
}

#endif  // swift(>=4.2)

/// The sort options.
public struct Google_Analytics_Data_V1alpha_OrderBy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specify one type of order by for `OrderBy`.
  public var oneOrderBy: Google_Analytics_Data_V1alpha_OrderBy.OneOf_OneOrderBy? = nil

  /// Sorts results by a metric's values.
  public var metric: Google_Analytics_Data_V1alpha_OrderBy.MetricOrderBy {
    get {
      if case .metric(let v)? = oneOrderBy {return v}
      return Google_Analytics_Data_V1alpha_OrderBy.MetricOrderBy()
    }
    set {oneOrderBy = .metric(newValue)}
  }

  /// Sorts results by a dimension's values.
  public var dimension: Google_Analytics_Data_V1alpha_OrderBy.DimensionOrderBy {
    get {
      if case .dimension(let v)? = oneOrderBy {return v}
      return Google_Analytics_Data_V1alpha_OrderBy.DimensionOrderBy()
    }
    set {oneOrderBy = .dimension(newValue)}
  }

  /// Sorts results by a metric's values within a pivot column group.
  public var pivot: Google_Analytics_Data_V1alpha_OrderBy.PivotOrderBy {
    get {
      if case .pivot(let v)? = oneOrderBy {return v}
      return Google_Analytics_Data_V1alpha_OrderBy.PivotOrderBy()
    }
    set {oneOrderBy = .pivot(newValue)}
  }

  /// If true, sorts by descending order.
  public var desc: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Specify one type of order by for `OrderBy`.
  public enum OneOf_OneOrderBy: Equatable {
    /// Sorts results by a metric's values.
    case metric(Google_Analytics_Data_V1alpha_OrderBy.MetricOrderBy)
    /// Sorts results by a dimension's values.
    case dimension(Google_Analytics_Data_V1alpha_OrderBy.DimensionOrderBy)
    /// Sorts results by a metric's values within a pivot column group.
    case pivot(Google_Analytics_Data_V1alpha_OrderBy.PivotOrderBy)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Analytics_Data_V1alpha_OrderBy.OneOf_OneOrderBy, rhs: Google_Analytics_Data_V1alpha_OrderBy.OneOf_OneOrderBy) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.metric, .metric): return {
        guard case .metric(let l) = lhs, case .metric(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dimension, .dimension): return {
        guard case .dimension(let l) = lhs, case .dimension(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pivot, .pivot): return {
        guard case .pivot(let l) = lhs, case .pivot(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Sorts by metric values.
  public struct MetricOrderBy {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A metric name in the request to order by.
    public var metricName: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Sorts by dimension values.
  public struct DimensionOrderBy {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A dimension name in the request to order by.
    public var dimensionName: String = String()

    /// Controls the rule for dimension value ordering.
    public var orderType: Google_Analytics_Data_V1alpha_OrderBy.DimensionOrderBy.OrderType = .unspecified

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Rule to order the string dimension values by.
    public enum OrderType: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// Unspecified.
      case unspecified // = 0

      /// Alphanumeric sort by Unicode code point. For example, "2" < "A" < "X" <
      /// "b" < "z".
      case alphanumeric // = 1

      /// Case insensitive alphanumeric sort by lower case Unicode code point.
      /// For example, "2" < "A" < "b" < "X" < "z".
      case caseInsensitiveAlphanumeric // = 2

      /// Dimension values are converted to numbers before sorting. For example
      /// in NUMERIC sort, "25" < "100", and in `ALPHANUMERIC` sort, "100" <
      /// "25". Non-numeric dimension values all have equal ordering value below
      /// all numeric values.
      case numeric // = 3
      case UNRECOGNIZED(Int)

      public init() {
        self = .unspecified
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .alphanumeric
        case 2: self = .caseInsensitiveAlphanumeric
        case 3: self = .numeric
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .alphanumeric: return 1
        case .caseInsensitiveAlphanumeric: return 2
        case .numeric: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  /// Sorts by a pivot column group.
  public struct PivotOrderBy {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// In the response to order by, order rows by this column. Must be a metric
    /// name from the request.
    public var metricName: String = String()

    /// Used to select a dimension name and value pivot. If multiple pivot
    /// selections are given, the sort occurs on rows where all pivot selection
    /// dimension name and value pairs match the row's dimension name and value
    /// pair.
    public var pivotSelections: [Google_Analytics_Data_V1alpha_OrderBy.PivotOrderBy.PivotSelection] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// A pair of dimension names and values. Rows with this dimension pivot pair
    /// are ordered by the metric's value.
    ///
    /// For example if pivots = {{"browser", "Chrome"}} and
    /// metric_name = "Sessions",
    /// then the rows will be sorted based on Sessions in Chrome.
    ///
    ///     ---------|----------|----------------|----------|----------------
    ///              |  Chrome  |    Chrome      |  Safari  |     Safari
    ///     ---------|----------|----------------|----------|----------------
    ///      Country | Sessions | Pages/Sessions | Sessions | Pages/Sessions
    ///     ---------|----------|----------------|----------|----------------
    ///         US   |    2     |       2        |     3    |        1
    ///     ---------|----------|----------------|----------|----------------
    ///       Canada |    3     |       1        |     4    |        1
    ///     ---------|----------|----------------|----------|----------------
    public struct PivotSelection {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Must be a dimension name from the request.
      public var dimensionName: String = String()

      /// Order by only when the named dimension is this value.
      public var dimensionValue: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Analytics_Data_V1alpha_OrderBy.DimensionOrderBy.OrderType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Analytics_Data_V1alpha_OrderBy.DimensionOrderBy.OrderType] = [
    .unspecified,
    .alphanumeric,
    .caseInsensitiveAlphanumeric,
    .numeric,
  ]
}

#endif  // swift(>=4.2)

/// Describes the visible dimension columns and rows in the report response.
public struct Google_Analytics_Data_V1alpha_Pivot {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Dimension names for visible columns in the report response. Including
  /// "dateRange" produces a date range column; for each row in the response,
  /// dimension values in the date range column will indicate the corresponding
  /// date range from the request.
  public var fieldNames: [String] = []

  /// Specifies how dimensions are ordered in the pivot. In the first Pivot, the
  /// OrderBys determine Row and PivotDimensionHeader ordering; in subsequent
  /// Pivots, the OrderBys determine only PivotDimensionHeader ordering.
  /// Dimensions specified in these OrderBys must be a subset of
  /// Pivot.field_names.
  public var orderBys: [Google_Analytics_Data_V1alpha_OrderBy] = []

  /// The row count of the start row. The first row is counted as row 0.
  public var offset: Int64 = 0

  /// The number of rows to return in this pivot. If unspecified, 10 rows are
  /// returned. If -1, all rows are returned.
  public var limit: Int64 = 0

  /// Aggregate the metrics by dimensions in this pivot using the specified
  /// metric_aggregations.
  public var metricAggregations: [Google_Analytics_Data_V1alpha_MetricAggregation] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Specification for a cohort report.
public struct Google_Analytics_Data_V1alpha_CohortSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The definition for the cohorts.
  public var cohorts: [Google_Analytics_Data_V1alpha_Cohort] = []

  /// The data ranges of cohorts.
  public var cohortsRange: Google_Analytics_Data_V1alpha_CohortsRange {
    get {return _cohortsRange ?? Google_Analytics_Data_V1alpha_CohortsRange()}
    set {_cohortsRange = newValue}
  }
  /// Returns true if `cohortsRange` has been explicitly set.
  public var hasCohortsRange: Bool {return self._cohortsRange != nil}
  /// Clears the value of `cohortsRange`. Subsequent reads from it will return its default value.
  public mutating func clearCohortsRange() {self._cohortsRange = nil}

  /// Settings of a cohort report.
  public var cohortReportSettings: Google_Analytics_Data_V1alpha_CohortReportSettings {
    get {return _cohortReportSettings ?? Google_Analytics_Data_V1alpha_CohortReportSettings()}
    set {_cohortReportSettings = newValue}
  }
  /// Returns true if `cohortReportSettings` has been explicitly set.
  public var hasCohortReportSettings: Bool {return self._cohortReportSettings != nil}
  /// Clears the value of `cohortReportSettings`. Subsequent reads from it will return its default value.
  public mutating func clearCohortReportSettings() {self._cohortReportSettings = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _cohortsRange: Google_Analytics_Data_V1alpha_CohortsRange? = nil
  fileprivate var _cohortReportSettings: Google_Analytics_Data_V1alpha_CohortReportSettings? = nil
}

/// Defines a cohort. A cohort is a group of users who share a common
/// characteristic. For example, all users with the same acquisition date
/// belong to the same cohort.
public struct Google_Analytics_Data_V1alpha_Cohort {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Assigns a name to this cohort. The dimension `cohort` is valued to this
  /// name in a report response. If set, cannot begin with `cohort_` or
  /// `RESERVED_`. If not set, cohorts are named by their zero based index
  /// `cohort_0`, `cohort_1`, etc.
  public var name: String = String()

  /// The dimension used by cohort. Only supports `firstTouchDate` for retention
  /// report.
  public var dimension: String = String()

  /// The cohort selects users whose first visit date is between start date
  /// and end date defined in the `dateRange`. In a cohort request, this
  /// `dateRange` is required and the `dateRanges` in the `RunReportRequest` or
  /// `RunPivotReportRequest` must be unspecified.
  ///
  /// The date range should be aligned with the cohort's granularity. If
  /// CohortsRange uses daily granularity, the date range can be aligned to any
  /// day. If CohortsRange uses weekly granularity, the date range should be
  /// aligned to the week boundary, starting at Sunday and ending Saturday. If
  /// CohortsRange uses monthly granularity, the date range should be aligned to
  /// the month, starting at the first and ending on the last day of the month.
  public var dateRange: Google_Analytics_Data_V1alpha_DateRange {
    get {return _dateRange ?? Google_Analytics_Data_V1alpha_DateRange()}
    set {_dateRange = newValue}
  }
  /// Returns true if `dateRange` has been explicitly set.
  public var hasDateRange: Bool {return self._dateRange != nil}
  /// Clears the value of `dateRange`. Subsequent reads from it will return its default value.
  public mutating func clearDateRange() {self._dateRange = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _dateRange: Google_Analytics_Data_V1alpha_DateRange? = nil
}

/// Settings of a cohort report.
public struct Google_Analytics_Data_V1alpha_CohortReportSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If true, accumulates the result from first visit day to the end day. Not
  /// supported in `RunReportRequest`.
  public var accumulate: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Describes date range for a cohort report.
public struct Google_Analytics_Data_V1alpha_CohortsRange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Reporting date range for each cohort is calculated based on these three
  /// fields.
  public var granularity: Google_Analytics_Data_V1alpha_CohortsRange.Granularity = .unspecified

  /// For daily cohorts, this will be the start day offset.
  /// For weekly cohorts, this will be the week offset.
  public var startOffset: Int32 = 0

  /// For daily cohorts, this will be the end day offset.
  /// For weekly cohorts, this will be the week offset.
  public var endOffset: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Reporting granularity for the cohorts.
  public enum Granularity: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unspecified.
    case unspecified // = 0

    /// Daily
    case daily // = 1

    /// Weekly
    case weekly // = 2

    /// Monthly
    case monthly // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .daily
      case 2: self = .weekly
      case 3: self = .monthly
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .daily: return 1
      case .weekly: return 2
      case .monthly: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Analytics_Data_V1alpha_CohortsRange.Granularity: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Analytics_Data_V1alpha_CohortsRange.Granularity] = [
    .unspecified,
    .daily,
    .weekly,
    .monthly,
  ]
}

#endif  // swift(>=4.2)

/// Response's metadata carrying additional information about the report content.
public struct Google_Analytics_Data_V1alpha_ResponseMetaData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If true, indicates some buckets of dimension combinations are rolled into
  /// "(other)" row. This can happen for high cardinality reports.
  public var dataLossFromOtherRow: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Describes a dimension column in the report. Dimensions requested in a report
/// produce column entries within rows and DimensionHeaders. However, dimensions
/// used exclusively within filters or expressions do not produce columns in a
/// report; correspondingly, those dimensions do not produce headers.
public struct Google_Analytics_Data_V1alpha_DimensionHeader {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The dimension's name.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Describes a metric column in the report. Visible metrics requested in a
/// report produce column entries within rows and MetricHeaders. However,
/// metrics used exclusively within filters or expressions do not produce columns
/// in a report; correspondingly, those metrics do not produce headers.
public struct Google_Analytics_Data_V1alpha_MetricHeader {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The metric's name.
  public var name: String = String()

  /// The metric's data type.
  public var type: Google_Analytics_Data_V1alpha_MetricType = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Dimensions' values in a single pivot.
public struct Google_Analytics_Data_V1alpha_PivotHeader {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The size is the same as the cardinality of the corresponding dimension
  /// combinations.
  public var pivotDimensionHeaders: [Google_Analytics_Data_V1alpha_PivotDimensionHeader] = []

  /// The cardinality of the pivot as if offset = 0 and limit = -1. The total
  /// number of rows for this pivot's fields regardless of how the parameters
  /// offset and limit are specified in the request.
  public var rowCount: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Summarizes dimension values from a row for this pivot.
public struct Google_Analytics_Data_V1alpha_PivotDimensionHeader {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Values of multiple dimensions in a pivot.
  public var dimensionValues: [Google_Analytics_Data_V1alpha_DimensionValue] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Report data for each row.
/// For example if RunReportRequest contains:
///
/// ```none
/// "dimensions": [
///   {
///     "name": "eventName"
///   },
///   {
///     "name": "countryId"
///   }
/// ],
/// "metrics": [
///   {
///     "name": "eventCount"
///   }
/// ]
/// ```
///
/// One row with 'in_app_purchase' as the eventName, 'JP' as the countryId, and
/// 15 as the eventCount, would be:
///
/// ```none
/// "dimensionValues": [
///   {
///     "value": "in_app_purchase"
///   },
///   {
///     "value": "JP"
///   }
/// ],
/// "metricValues": [
///   {
///     "value": "15"
///   }
/// ]
/// ```
public struct Google_Analytics_Data_V1alpha_Row {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of requested dimension values. In a PivotReport, dimension_values
  /// are only listed for dimensions included in a pivot.
  public var dimensionValues: [Google_Analytics_Data_V1alpha_DimensionValue] = []

  /// List of requested visible metric values.
  public var metricValues: [Google_Analytics_Data_V1alpha_MetricValue] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The value of a dimension.
public struct Google_Analytics_Data_V1alpha_DimensionValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// One kind of dimension value
  public var oneValue: Google_Analytics_Data_V1alpha_DimensionValue.OneOf_OneValue? = nil

  /// Value as a string if the dimension type is a string.
  public var value: String {
    get {
      if case .value(let v)? = oneValue {return v}
      return String()
    }
    set {oneValue = .value(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// One kind of dimension value
  public enum OneOf_OneValue: Equatable {
    /// Value as a string if the dimension type is a string.
    case value(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Analytics_Data_V1alpha_DimensionValue.OneOf_OneValue, rhs: Google_Analytics_Data_V1alpha_DimensionValue.OneOf_OneValue) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.value, .value): return {
        guard case .value(let l) = lhs, case .value(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

/// The value of a metric.
public struct Google_Analytics_Data_V1alpha_MetricValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// One of metric value
  public var oneValue: Google_Analytics_Data_V1alpha_MetricValue.OneOf_OneValue? = nil

  /// Measurement value. See MetricHeader for type.
  public var value: String {
    get {
      if case .value(let v)? = oneValue {return v}
      return String()
    }
    set {oneValue = .value(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// One of metric value
  public enum OneOf_OneValue: Equatable {
    /// Measurement value. See MetricHeader for type.
    case value(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Analytics_Data_V1alpha_MetricValue.OneOf_OneValue, rhs: Google_Analytics_Data_V1alpha_MetricValue.OneOf_OneValue) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.value, .value): return {
        guard case .value(let l) = lhs, case .value(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

/// To represent a number.
public struct Google_Analytics_Data_V1alpha_NumericValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// One of a numeric value
  public var oneValue: Google_Analytics_Data_V1alpha_NumericValue.OneOf_OneValue? = nil

  /// Integer value
  public var int64Value: Int64 {
    get {
      if case .int64Value(let v)? = oneValue {return v}
      return 0
    }
    set {oneValue = .int64Value(newValue)}
  }

  /// Double value
  public var doubleValue: Double {
    get {
      if case .doubleValue(let v)? = oneValue {return v}
      return 0
    }
    set {oneValue = .doubleValue(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// One of a numeric value
  public enum OneOf_OneValue: Equatable {
    /// Integer value
    case int64Value(Int64)
    /// Double value
    case doubleValue(Double)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Analytics_Data_V1alpha_NumericValue.OneOf_OneValue, rhs: Google_Analytics_Data_V1alpha_NumericValue.OneOf_OneValue) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.int64Value, .int64Value): return {
        guard case .int64Value(let l) = lhs, case .int64Value(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.doubleValue, .doubleValue): return {
        guard case .doubleValue(let l) = lhs, case .doubleValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Current state of all quotas for this Analytics Property. If any quota for a
/// property is exhausted, all requests to that property will return Resource
/// Exhausted errors.
public struct Google_Analytics_Data_V1alpha_PropertyQuota {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard Analytics Properties can use up to 25,000 tokens per day;
  /// Analytics 360 Properties can use 250,000 tokens per day. Most requests
  /// consume fewer than 10 tokens.
  public var tokensPerDay: Google_Analytics_Data_V1alpha_QuotaStatus {
    get {return _tokensPerDay ?? Google_Analytics_Data_V1alpha_QuotaStatus()}
    set {_tokensPerDay = newValue}
  }
  /// Returns true if `tokensPerDay` has been explicitly set.
  public var hasTokensPerDay: Bool {return self._tokensPerDay != nil}
  /// Clears the value of `tokensPerDay`. Subsequent reads from it will return its default value.
  public mutating func clearTokensPerDay() {self._tokensPerDay = nil}

  /// Standard Analytics Properties can use up to 5,000 tokens per day; Analytics
  /// 360 Properties can use 50,000 tokens per day. An API request consumes a
  /// single number of tokens, and that number is deducted from both the hourly
  /// and daily quotas.
  public var tokensPerHour: Google_Analytics_Data_V1alpha_QuotaStatus {
    get {return _tokensPerHour ?? Google_Analytics_Data_V1alpha_QuotaStatus()}
    set {_tokensPerHour = newValue}
  }
  /// Returns true if `tokensPerHour` has been explicitly set.
  public var hasTokensPerHour: Bool {return self._tokensPerHour != nil}
  /// Clears the value of `tokensPerHour`. Subsequent reads from it will return its default value.
  public mutating func clearTokensPerHour() {self._tokensPerHour = nil}

  /// Standard Analytics Properties can send up to 10 concurrent requests;
  /// Analytics 360 Properties can use up to 50 concurrent requests.
  public var concurrentRequests: Google_Analytics_Data_V1alpha_QuotaStatus {
    get {return _concurrentRequests ?? Google_Analytics_Data_V1alpha_QuotaStatus()}
    set {_concurrentRequests = newValue}
  }
  /// Returns true if `concurrentRequests` has been explicitly set.
  public var hasConcurrentRequests: Bool {return self._concurrentRequests != nil}
  /// Clears the value of `concurrentRequests`. Subsequent reads from it will return its default value.
  public mutating func clearConcurrentRequests() {self._concurrentRequests = nil}

  /// Standard Analytics Properties and cloud project pairs can have up to 10
  /// server errors per hour; Analytics 360 Properties and cloud project pairs
  /// can have up to 50 server errors per hour.
  public var serverErrorsPerProjectPerHour: Google_Analytics_Data_V1alpha_QuotaStatus {
    get {return _serverErrorsPerProjectPerHour ?? Google_Analytics_Data_V1alpha_QuotaStatus()}
    set {_serverErrorsPerProjectPerHour = newValue}
  }
  /// Returns true if `serverErrorsPerProjectPerHour` has been explicitly set.
  public var hasServerErrorsPerProjectPerHour: Bool {return self._serverErrorsPerProjectPerHour != nil}
  /// Clears the value of `serverErrorsPerProjectPerHour`. Subsequent reads from it will return its default value.
  public mutating func clearServerErrorsPerProjectPerHour() {self._serverErrorsPerProjectPerHour = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _tokensPerDay: Google_Analytics_Data_V1alpha_QuotaStatus? = nil
  fileprivate var _tokensPerHour: Google_Analytics_Data_V1alpha_QuotaStatus? = nil
  fileprivate var _concurrentRequests: Google_Analytics_Data_V1alpha_QuotaStatus? = nil
  fileprivate var _serverErrorsPerProjectPerHour: Google_Analytics_Data_V1alpha_QuotaStatus? = nil
}

/// Current state for a particular quota group.
public struct Google_Analytics_Data_V1alpha_QuotaStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Quota consumed by this request.
  public var consumed: Int32 = 0

  /// Quota remaining after this request.
  public var remaining: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Explains a dimension.
public struct Google_Analytics_Data_V1alpha_DimensionMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This dimension's name. Useable in [Dimension](#Dimension)'s `name`. For
  /// example, `eventName`.
  public var apiName: String = String()

  /// This dimension's name within the Google Analytics user interface. For
  /// example, `Event name`.
  public var uiName: String = String()

  /// Description of how this dimension is used and calculated.
  public var description_p: String = String()

  /// Still usable but deprecated names for this dimension. If populated, this
  /// dimension is available by either `apiName` or one of `deprecatedApiNames`
  /// for a period of time. After the deprecation period, the dimension will be
  /// available only by `apiName`.
  public var deprecatedApiNames: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Explains a metric.
public struct Google_Analytics_Data_V1alpha_MetricMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A metric name. Useable in [Metric](#Metric)'s `name`. For example,
  /// `eventCount`.
  public var apiName: String = String()

  /// This metric's name within the Google Analytics user interface. For example,
  /// `Event count`.
  public var uiName: String = String()

  /// Description of how this metric is used and calculated.
  public var description_p: String = String()

  /// Still usable but deprecated names for this metric. If populated, this
  /// metric is available by either `apiName` or one of `deprecatedApiNames`
  /// for a period of time. After the deprecation period, the metric will be
  /// available only by `apiName`.
  public var deprecatedApiNames: [String] = []

  /// The type of this metric.
  public var type: Google_Analytics_Data_V1alpha_MetricType = .unspecified

  /// The mathematical expression for this derived metric. Can be used in
  /// [Metric](#Metric)'s `expression` field for equivalent reports. Most metrics
  /// are not expressions, and for non-expressions, this field is empty.
  public var expression: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.analytics.data.v1alpha"

extension Google_Analytics_Data_V1alpha_MetricAggregation: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "METRIC_AGGREGATION_UNSPECIFIED"),
    1: .same(proto: "TOTAL"),
    4: .same(proto: "COUNT"),
    5: .same(proto: "MINIMUM"),
    6: .same(proto: "MAXIMUM"),
  ]
}

extension Google_Analytics_Data_V1alpha_MetricType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "METRIC_TYPE_UNSPECIFIED"),
    1: .same(proto: "TYPE_INTEGER"),
    2: .same(proto: "TYPE_FLOAT"),
    4: .same(proto: "TYPE_SECONDS"),
    5: .same(proto: "TYPE_MILLISECONDS"),
    6: .same(proto: "TYPE_MINUTES"),
    7: .same(proto: "TYPE_HOURS"),
    8: .same(proto: "TYPE_STANDARD"),
    9: .same(proto: "TYPE_CURRENCY"),
    10: .same(proto: "TYPE_FEET"),
    11: .same(proto: "TYPE_MILES"),
    12: .same(proto: "TYPE_METERS"),
    13: .same(proto: "TYPE_KILOMETERS"),
  ]
}

extension Google_Analytics_Data_V1alpha_DateRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DateRange"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_date"),
    2: .standard(proto: "end_date"),
    3: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.startDate) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.endDate) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.startDate.isEmpty {
      try visitor.visitSingularStringField(value: self.startDate, fieldNumber: 1)
    }
    if !self.endDate.isEmpty {
      try visitor.visitSingularStringField(value: self.endDate, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Analytics_Data_V1alpha_DateRange, rhs: Google_Analytics_Data_V1alpha_DateRange) -> Bool {
    if lhs.startDate != rhs.startDate {return false}
    if lhs.endDate != rhs.endDate {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Analytics_Data_V1alpha_Entity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Entity"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "property_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.propertyID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.propertyID.isEmpty {
      try visitor.visitSingularStringField(value: self.propertyID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Analytics_Data_V1alpha_Entity, rhs: Google_Analytics_Data_V1alpha_Entity) -> Bool {
    if lhs.propertyID != rhs.propertyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Analytics_Data_V1alpha_Dimension: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Dimension"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "dimension_expression"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._dimensionExpression) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._dimensionExpression {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Analytics_Data_V1alpha_Dimension, rhs: Google_Analytics_Data_V1alpha_Dimension) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._dimensionExpression != rhs._dimensionExpression {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Analytics_Data_V1alpha_DimensionExpression: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DimensionExpression"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .standard(proto: "lower_case"),
    5: .standard(proto: "upper_case"),
    6: .same(proto: "concatenate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 4: try {
        var v: Google_Analytics_Data_V1alpha_DimensionExpression.CaseExpression?
        if let current = self.oneExpression {
          try decoder.handleConflictingOneOf()
          if case .lowerCase(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.oneExpression = .lowerCase(v)}
      }()
      case 5: try {
        var v: Google_Analytics_Data_V1alpha_DimensionExpression.CaseExpression?
        if let current = self.oneExpression {
          try decoder.handleConflictingOneOf()
          if case .upperCase(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.oneExpression = .upperCase(v)}
      }()
      case 6: try {
        var v: Google_Analytics_Data_V1alpha_DimensionExpression.ConcatenateExpression?
        if let current = self.oneExpression {
          try decoder.handleConflictingOneOf()
          if case .concatenate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.oneExpression = .concatenate(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.oneExpression {
    case .lowerCase?: try {
      guard case .lowerCase(let v)? = self.oneExpression else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .upperCase?: try {
      guard case .upperCase(let v)? = self.oneExpression else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .concatenate?: try {
      guard case .concatenate(let v)? = self.oneExpression else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Analytics_Data_V1alpha_DimensionExpression, rhs: Google_Analytics_Data_V1alpha_DimensionExpression) -> Bool {
    if lhs.oneExpression != rhs.oneExpression {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Analytics_Data_V1alpha_DimensionExpression.CaseExpression: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Analytics_Data_V1alpha_DimensionExpression.protoMessageName + ".CaseExpression"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dimension_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.dimensionName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dimensionName.isEmpty {
      try visitor.visitSingularStringField(value: self.dimensionName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Analytics_Data_V1alpha_DimensionExpression.CaseExpression, rhs: Google_Analytics_Data_V1alpha_DimensionExpression.CaseExpression) -> Bool {
    if lhs.dimensionName != rhs.dimensionName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Analytics_Data_V1alpha_DimensionExpression.ConcatenateExpression: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Analytics_Data_V1alpha_DimensionExpression.protoMessageName + ".ConcatenateExpression"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dimension_names"),
    2: .same(proto: "delimiter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.dimensionNames) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.delimiter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dimensionNames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.dimensionNames, fieldNumber: 1)
    }
    if !self.delimiter.isEmpty {
      try visitor.visitSingularStringField(value: self.delimiter, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Analytics_Data_V1alpha_DimensionExpression.ConcatenateExpression, rhs: Google_Analytics_Data_V1alpha_DimensionExpression.ConcatenateExpression) -> Bool {
    if lhs.dimensionNames != rhs.dimensionNames {return false}
    if lhs.delimiter != rhs.delimiter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Analytics_Data_V1alpha_Metric: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Metric"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "expression"),
    3: .same(proto: "invisible"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.expression) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.invisible) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.expression.isEmpty {
      try visitor.visitSingularStringField(value: self.expression, fieldNumber: 2)
    }
    if self.invisible != false {
      try visitor.visitSingularBoolField(value: self.invisible, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Analytics_Data_V1alpha_Metric, rhs: Google_Analytics_Data_V1alpha_Metric) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.expression != rhs.expression {return false}
    if lhs.invisible != rhs.invisible {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Analytics_Data_V1alpha_FilterExpression: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FilterExpression"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "and_group"),
    2: .standard(proto: "or_group"),
    3: .standard(proto: "not_expression"),
    4: .same(proto: "filter"),
  ]

  fileprivate class _StorageClass {
    var _expr: Google_Analytics_Data_V1alpha_FilterExpression.OneOf_Expr?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _expr = source._expr
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try {
          var v: Google_Analytics_Data_V1alpha_FilterExpressionList?
          if let current = _storage._expr {
            try decoder.handleConflictingOneOf()
            if case .andGroup(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._expr = .andGroup(v)}
        }()
        case 2: try {
          var v: Google_Analytics_Data_V1alpha_FilterExpressionList?
          if let current = _storage._expr {
            try decoder.handleConflictingOneOf()
            if case .orGroup(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._expr = .orGroup(v)}
        }()
        case 3: try {
          var v: Google_Analytics_Data_V1alpha_FilterExpression?
          if let current = _storage._expr {
            try decoder.handleConflictingOneOf()
            if case .notExpression(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._expr = .notExpression(v)}
        }()
        case 4: try {
          var v: Google_Analytics_Data_V1alpha_Filter?
          if let current = _storage._expr {
            try decoder.handleConflictingOneOf()
            if case .filter(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._expr = .filter(v)}
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._expr {
      case .andGroup?: try {
        guard case .andGroup(let v)? = _storage._expr else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }()
      case .orGroup?: try {
        guard case .orGroup(let v)? = _storage._expr else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }()
      case .notExpression?: try {
        guard case .notExpression(let v)? = _storage._expr else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case .filter?: try {
        guard case .filter(let v)? = _storage._expr else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Analytics_Data_V1alpha_FilterExpression, rhs: Google_Analytics_Data_V1alpha_FilterExpression) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._expr != rhs_storage._expr {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Analytics_Data_V1alpha_FilterExpressionList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FilterExpressionList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "expressions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.expressions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.expressions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.expressions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Analytics_Data_V1alpha_FilterExpressionList, rhs: Google_Analytics_Data_V1alpha_FilterExpressionList) -> Bool {
    if lhs.expressions != rhs.expressions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Analytics_Data_V1alpha_Filter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Filter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "field_name"),
    2: .standard(proto: "null_filter"),
    3: .standard(proto: "string_filter"),
    4: .standard(proto: "in_list_filter"),
    5: .standard(proto: "numeric_filter"),
    6: .standard(proto: "between_filter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fieldName) }()
      case 2: try {
        if self.oneFilter != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.oneFilter = .nullFilter(v)}
      }()
      case 3: try {
        var v: Google_Analytics_Data_V1alpha_Filter.StringFilter?
        if let current = self.oneFilter {
          try decoder.handleConflictingOneOf()
          if case .stringFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.oneFilter = .stringFilter(v)}
      }()
      case 4: try {
        var v: Google_Analytics_Data_V1alpha_Filter.InListFilter?
        if let current = self.oneFilter {
          try decoder.handleConflictingOneOf()
          if case .inListFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.oneFilter = .inListFilter(v)}
      }()
      case 5: try {
        var v: Google_Analytics_Data_V1alpha_Filter.NumericFilter?
        if let current = self.oneFilter {
          try decoder.handleConflictingOneOf()
          if case .numericFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.oneFilter = .numericFilter(v)}
      }()
      case 6: try {
        var v: Google_Analytics_Data_V1alpha_Filter.BetweenFilter?
        if let current = self.oneFilter {
          try decoder.handleConflictingOneOf()
          if case .betweenFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.oneFilter = .betweenFilter(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fieldName.isEmpty {
      try visitor.visitSingularStringField(value: self.fieldName, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.oneFilter {
    case .nullFilter?: try {
      guard case .nullFilter(let v)? = self.oneFilter else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }()
    case .stringFilter?: try {
      guard case .stringFilter(let v)? = self.oneFilter else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .inListFilter?: try {
      guard case .inListFilter(let v)? = self.oneFilter else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .numericFilter?: try {
      guard case .numericFilter(let v)? = self.oneFilter else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .betweenFilter?: try {
      guard case .betweenFilter(let v)? = self.oneFilter else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Analytics_Data_V1alpha_Filter, rhs: Google_Analytics_Data_V1alpha_Filter) -> Bool {
    if lhs.fieldName != rhs.fieldName {return false}
    if lhs.oneFilter != rhs.oneFilter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Analytics_Data_V1alpha_Filter.StringFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Analytics_Data_V1alpha_Filter.protoMessageName + ".StringFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "match_type"),
    2: .same(proto: "value"),
    3: .standard(proto: "case_sensitive"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.matchType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.caseSensitive) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.matchType != .unspecified {
      try visitor.visitSingularEnumField(value: self.matchType, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    if self.caseSensitive != false {
      try visitor.visitSingularBoolField(value: self.caseSensitive, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Analytics_Data_V1alpha_Filter.StringFilter, rhs: Google_Analytics_Data_V1alpha_Filter.StringFilter) -> Bool {
    if lhs.matchType != rhs.matchType {return false}
    if lhs.value != rhs.value {return false}
    if lhs.caseSensitive != rhs.caseSensitive {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Analytics_Data_V1alpha_Filter.StringFilter.MatchType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MATCH_TYPE_UNSPECIFIED"),
    1: .same(proto: "EXACT"),
    2: .same(proto: "BEGINS_WITH"),
    3: .same(proto: "ENDS_WITH"),
    4: .same(proto: "CONTAINS"),
    5: .same(proto: "FULL_REGEXP"),
    6: .same(proto: "PARTIAL_REGEXP"),
  ]
}

extension Google_Analytics_Data_V1alpha_Filter.InListFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Analytics_Data_V1alpha_Filter.protoMessageName + ".InListFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
    2: .standard(proto: "case_sensitive"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.values) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.caseSensitive) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitRepeatedStringField(value: self.values, fieldNumber: 1)
    }
    if self.caseSensitive != false {
      try visitor.visitSingularBoolField(value: self.caseSensitive, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Analytics_Data_V1alpha_Filter.InListFilter, rhs: Google_Analytics_Data_V1alpha_Filter.InListFilter) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.caseSensitive != rhs.caseSensitive {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Analytics_Data_V1alpha_Filter.NumericFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Analytics_Data_V1alpha_Filter.protoMessageName + ".NumericFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operation"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operation) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operation != .unspecified {
      try visitor.visitSingularEnumField(value: self.operation, fieldNumber: 1)
    }
    if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Analytics_Data_V1alpha_Filter.NumericFilter, rhs: Google_Analytics_Data_V1alpha_Filter.NumericFilter) -> Bool {
    if lhs.operation != rhs.operation {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Analytics_Data_V1alpha_Filter.NumericFilter.Operation: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OPERATION_UNSPECIFIED"),
    1: .same(proto: "EQUAL"),
    2: .same(proto: "LESS_THAN"),
    3: .same(proto: "LESS_THAN_OR_EQUAL"),
    4: .same(proto: "GREATER_THAN"),
    5: .same(proto: "GREATER_THAN_OR_EQUAL"),
  ]
}

extension Google_Analytics_Data_V1alpha_Filter.BetweenFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Analytics_Data_V1alpha_Filter.protoMessageName + ".BetweenFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "from_value"),
    2: .standard(proto: "to_value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._fromValue) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._toValue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._fromValue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._toValue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Analytics_Data_V1alpha_Filter.BetweenFilter, rhs: Google_Analytics_Data_V1alpha_Filter.BetweenFilter) -> Bool {
    if lhs._fromValue != rhs._fromValue {return false}
    if lhs._toValue != rhs._toValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Analytics_Data_V1alpha_OrderBy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OrderBy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metric"),
    2: .same(proto: "dimension"),
    3: .same(proto: "pivot"),
    4: .same(proto: "desc"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Analytics_Data_V1alpha_OrderBy.MetricOrderBy?
        if let current = self.oneOrderBy {
          try decoder.handleConflictingOneOf()
          if case .metric(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.oneOrderBy = .metric(v)}
      }()
      case 2: try {
        var v: Google_Analytics_Data_V1alpha_OrderBy.DimensionOrderBy?
        if let current = self.oneOrderBy {
          try decoder.handleConflictingOneOf()
          if case .dimension(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.oneOrderBy = .dimension(v)}
      }()
      case 3: try {
        var v: Google_Analytics_Data_V1alpha_OrderBy.PivotOrderBy?
        if let current = self.oneOrderBy {
          try decoder.handleConflictingOneOf()
          if case .pivot(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.oneOrderBy = .pivot(v)}
      }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.desc) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.oneOrderBy {
    case .metric?: try {
      guard case .metric(let v)? = self.oneOrderBy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .dimension?: try {
      guard case .dimension(let v)? = self.oneOrderBy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .pivot?: try {
      guard case .pivot(let v)? = self.oneOrderBy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if self.desc != false {
      try visitor.visitSingularBoolField(value: self.desc, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Analytics_Data_V1alpha_OrderBy, rhs: Google_Analytics_Data_V1alpha_OrderBy) -> Bool {
    if lhs.oneOrderBy != rhs.oneOrderBy {return false}
    if lhs.desc != rhs.desc {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Analytics_Data_V1alpha_OrderBy.MetricOrderBy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Analytics_Data_V1alpha_OrderBy.protoMessageName + ".MetricOrderBy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "metric_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.metricName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.metricName.isEmpty {
      try visitor.visitSingularStringField(value: self.metricName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Analytics_Data_V1alpha_OrderBy.MetricOrderBy, rhs: Google_Analytics_Data_V1alpha_OrderBy.MetricOrderBy) -> Bool {
    if lhs.metricName != rhs.metricName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Analytics_Data_V1alpha_OrderBy.DimensionOrderBy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Analytics_Data_V1alpha_OrderBy.protoMessageName + ".DimensionOrderBy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dimension_name"),
    2: .standard(proto: "order_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.dimensionName) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.orderType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dimensionName.isEmpty {
      try visitor.visitSingularStringField(value: self.dimensionName, fieldNumber: 1)
    }
    if self.orderType != .unspecified {
      try visitor.visitSingularEnumField(value: self.orderType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Analytics_Data_V1alpha_OrderBy.DimensionOrderBy, rhs: Google_Analytics_Data_V1alpha_OrderBy.DimensionOrderBy) -> Bool {
    if lhs.dimensionName != rhs.dimensionName {return false}
    if lhs.orderType != rhs.orderType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Analytics_Data_V1alpha_OrderBy.DimensionOrderBy.OrderType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ORDER_TYPE_UNSPECIFIED"),
    1: .same(proto: "ALPHANUMERIC"),
    2: .same(proto: "CASE_INSENSITIVE_ALPHANUMERIC"),
    3: .same(proto: "NUMERIC"),
  ]
}

extension Google_Analytics_Data_V1alpha_OrderBy.PivotOrderBy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Analytics_Data_V1alpha_OrderBy.protoMessageName + ".PivotOrderBy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "metric_name"),
    2: .standard(proto: "pivot_selections"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.metricName) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.pivotSelections) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.metricName.isEmpty {
      try visitor.visitSingularStringField(value: self.metricName, fieldNumber: 1)
    }
    if !self.pivotSelections.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pivotSelections, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Analytics_Data_V1alpha_OrderBy.PivotOrderBy, rhs: Google_Analytics_Data_V1alpha_OrderBy.PivotOrderBy) -> Bool {
    if lhs.metricName != rhs.metricName {return false}
    if lhs.pivotSelections != rhs.pivotSelections {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Analytics_Data_V1alpha_OrderBy.PivotOrderBy.PivotSelection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Analytics_Data_V1alpha_OrderBy.PivotOrderBy.protoMessageName + ".PivotSelection"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dimension_name"),
    2: .standard(proto: "dimension_value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.dimensionName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.dimensionValue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dimensionName.isEmpty {
      try visitor.visitSingularStringField(value: self.dimensionName, fieldNumber: 1)
    }
    if !self.dimensionValue.isEmpty {
      try visitor.visitSingularStringField(value: self.dimensionValue, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Analytics_Data_V1alpha_OrderBy.PivotOrderBy.PivotSelection, rhs: Google_Analytics_Data_V1alpha_OrderBy.PivotOrderBy.PivotSelection) -> Bool {
    if lhs.dimensionName != rhs.dimensionName {return false}
    if lhs.dimensionValue != rhs.dimensionValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Analytics_Data_V1alpha_Pivot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Pivot"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "field_names"),
    2: .standard(proto: "order_bys"),
    3: .same(proto: "offset"),
    4: .same(proto: "limit"),
    5: .standard(proto: "metric_aggregations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.fieldNames) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.orderBys) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.limit) }()
      case 5: try { try decoder.decodeRepeatedEnumField(value: &self.metricAggregations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fieldNames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.fieldNames, fieldNumber: 1)
    }
    if !self.orderBys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.orderBys, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 3)
    }
    if self.limit != 0 {
      try visitor.visitSingularInt64Field(value: self.limit, fieldNumber: 4)
    }
    if !self.metricAggregations.isEmpty {
      try visitor.visitPackedEnumField(value: self.metricAggregations, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Analytics_Data_V1alpha_Pivot, rhs: Google_Analytics_Data_V1alpha_Pivot) -> Bool {
    if lhs.fieldNames != rhs.fieldNames {return false}
    if lhs.orderBys != rhs.orderBys {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.metricAggregations != rhs.metricAggregations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Analytics_Data_V1alpha_CohortSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CohortSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cohorts"),
    2: .standard(proto: "cohorts_range"),
    3: .standard(proto: "cohort_report_settings"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.cohorts) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._cohortsRange) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._cohortReportSettings) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cohorts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cohorts, fieldNumber: 1)
    }
    if let v = self._cohortsRange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._cohortReportSettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Analytics_Data_V1alpha_CohortSpec, rhs: Google_Analytics_Data_V1alpha_CohortSpec) -> Bool {
    if lhs.cohorts != rhs.cohorts {return false}
    if lhs._cohortsRange != rhs._cohortsRange {return false}
    if lhs._cohortReportSettings != rhs._cohortReportSettings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Analytics_Data_V1alpha_Cohort: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Cohort"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "dimension"),
    3: .standard(proto: "date_range"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.dimension) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._dateRange) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.dimension.isEmpty {
      try visitor.visitSingularStringField(value: self.dimension, fieldNumber: 2)
    }
    if let v = self._dateRange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Analytics_Data_V1alpha_Cohort, rhs: Google_Analytics_Data_V1alpha_Cohort) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.dimension != rhs.dimension {return false}
    if lhs._dateRange != rhs._dateRange {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Analytics_Data_V1alpha_CohortReportSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CohortReportSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accumulate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.accumulate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.accumulate != false {
      try visitor.visitSingularBoolField(value: self.accumulate, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Analytics_Data_V1alpha_CohortReportSettings, rhs: Google_Analytics_Data_V1alpha_CohortReportSettings) -> Bool {
    if lhs.accumulate != rhs.accumulate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Analytics_Data_V1alpha_CohortsRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CohortsRange"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "granularity"),
    2: .standard(proto: "start_offset"),
    3: .standard(proto: "end_offset"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.granularity) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.startOffset) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.endOffset) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.granularity != .unspecified {
      try visitor.visitSingularEnumField(value: self.granularity, fieldNumber: 1)
    }
    if self.startOffset != 0 {
      try visitor.visitSingularInt32Field(value: self.startOffset, fieldNumber: 2)
    }
    if self.endOffset != 0 {
      try visitor.visitSingularInt32Field(value: self.endOffset, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Analytics_Data_V1alpha_CohortsRange, rhs: Google_Analytics_Data_V1alpha_CohortsRange) -> Bool {
    if lhs.granularity != rhs.granularity {return false}
    if lhs.startOffset != rhs.startOffset {return false}
    if lhs.endOffset != rhs.endOffset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Analytics_Data_V1alpha_CohortsRange.Granularity: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GRANULARITY_UNSPECIFIED"),
    1: .same(proto: "DAILY"),
    2: .same(proto: "WEEKLY"),
    3: .same(proto: "MONTHLY"),
  ]
}

extension Google_Analytics_Data_V1alpha_ResponseMetaData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseMetaData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .standard(proto: "data_loss_from_other_row"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularBoolField(value: &self.dataLossFromOtherRow) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.dataLossFromOtherRow != false {
      try visitor.visitSingularBoolField(value: self.dataLossFromOtherRow, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Analytics_Data_V1alpha_ResponseMetaData, rhs: Google_Analytics_Data_V1alpha_ResponseMetaData) -> Bool {
    if lhs.dataLossFromOtherRow != rhs.dataLossFromOtherRow {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Analytics_Data_V1alpha_DimensionHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DimensionHeader"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Analytics_Data_V1alpha_DimensionHeader, rhs: Google_Analytics_Data_V1alpha_DimensionHeader) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Analytics_Data_V1alpha_MetricHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MetricHeader"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Analytics_Data_V1alpha_MetricHeader, rhs: Google_Analytics_Data_V1alpha_MetricHeader) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Analytics_Data_V1alpha_PivotHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PivotHeader"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pivot_dimension_headers"),
    2: .standard(proto: "row_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.pivotDimensionHeaders) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.rowCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pivotDimensionHeaders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pivotDimensionHeaders, fieldNumber: 1)
    }
    if self.rowCount != 0 {
      try visitor.visitSingularInt32Field(value: self.rowCount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Analytics_Data_V1alpha_PivotHeader, rhs: Google_Analytics_Data_V1alpha_PivotHeader) -> Bool {
    if lhs.pivotDimensionHeaders != rhs.pivotDimensionHeaders {return false}
    if lhs.rowCount != rhs.rowCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Analytics_Data_V1alpha_PivotDimensionHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PivotDimensionHeader"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dimension_values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.dimensionValues) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dimensionValues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dimensionValues, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Analytics_Data_V1alpha_PivotDimensionHeader, rhs: Google_Analytics_Data_V1alpha_PivotDimensionHeader) -> Bool {
    if lhs.dimensionValues != rhs.dimensionValues {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Analytics_Data_V1alpha_Row: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Row"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dimension_values"),
    2: .standard(proto: "metric_values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.dimensionValues) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.metricValues) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dimensionValues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dimensionValues, fieldNumber: 1)
    }
    if !self.metricValues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.metricValues, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Analytics_Data_V1alpha_Row, rhs: Google_Analytics_Data_V1alpha_Row) -> Bool {
    if lhs.dimensionValues != rhs.dimensionValues {return false}
    if lhs.metricValues != rhs.metricValues {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Analytics_Data_V1alpha_DimensionValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DimensionValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.oneValue != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.oneValue = .value(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .value(let v)? = self.oneValue {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Analytics_Data_V1alpha_DimensionValue, rhs: Google_Analytics_Data_V1alpha_DimensionValue) -> Bool {
    if lhs.oneValue != rhs.oneValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Analytics_Data_V1alpha_MetricValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MetricValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 4: try {
        if self.oneValue != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.oneValue = .value(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .value(let v)? = self.oneValue {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Analytics_Data_V1alpha_MetricValue, rhs: Google_Analytics_Data_V1alpha_MetricValue) -> Bool {
    if lhs.oneValue != rhs.oneValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Analytics_Data_V1alpha_NumericValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NumericValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "int64_value"),
    2: .standard(proto: "double_value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.oneValue != nil {try decoder.handleConflictingOneOf()}
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {self.oneValue = .int64Value(v)}
      }()
      case 2: try {
        if self.oneValue != nil {try decoder.handleConflictingOneOf()}
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {self.oneValue = .doubleValue(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.oneValue {
    case .int64Value?: try {
      guard case .int64Value(let v)? = self.oneValue else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    }()
    case .doubleValue?: try {
      guard case .doubleValue(let v)? = self.oneValue else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Analytics_Data_V1alpha_NumericValue, rhs: Google_Analytics_Data_V1alpha_NumericValue) -> Bool {
    if lhs.oneValue != rhs.oneValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Analytics_Data_V1alpha_PropertyQuota: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PropertyQuota"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tokens_per_day"),
    2: .standard(proto: "tokens_per_hour"),
    3: .standard(proto: "concurrent_requests"),
    4: .standard(proto: "server_errors_per_project_per_hour"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tokensPerDay) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._tokensPerHour) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._concurrentRequests) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._serverErrorsPerProjectPerHour) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._tokensPerDay {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._tokensPerHour {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._concurrentRequests {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._serverErrorsPerProjectPerHour {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Analytics_Data_V1alpha_PropertyQuota, rhs: Google_Analytics_Data_V1alpha_PropertyQuota) -> Bool {
    if lhs._tokensPerDay != rhs._tokensPerDay {return false}
    if lhs._tokensPerHour != rhs._tokensPerHour {return false}
    if lhs._concurrentRequests != rhs._concurrentRequests {return false}
    if lhs._serverErrorsPerProjectPerHour != rhs._serverErrorsPerProjectPerHour {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Analytics_Data_V1alpha_QuotaStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QuotaStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "consumed"),
    2: .same(proto: "remaining"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.consumed) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.remaining) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.consumed != 0 {
      try visitor.visitSingularInt32Field(value: self.consumed, fieldNumber: 1)
    }
    if self.remaining != 0 {
      try visitor.visitSingularInt32Field(value: self.remaining, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Analytics_Data_V1alpha_QuotaStatus, rhs: Google_Analytics_Data_V1alpha_QuotaStatus) -> Bool {
    if lhs.consumed != rhs.consumed {return false}
    if lhs.remaining != rhs.remaining {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Analytics_Data_V1alpha_DimensionMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DimensionMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "api_name"),
    2: .standard(proto: "ui_name"),
    3: .same(proto: "description"),
    4: .standard(proto: "deprecated_api_names"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.apiName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.uiName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.deprecatedApiNames) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.apiName.isEmpty {
      try visitor.visitSingularStringField(value: self.apiName, fieldNumber: 1)
    }
    if !self.uiName.isEmpty {
      try visitor.visitSingularStringField(value: self.uiName, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if !self.deprecatedApiNames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.deprecatedApiNames, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Analytics_Data_V1alpha_DimensionMetadata, rhs: Google_Analytics_Data_V1alpha_DimensionMetadata) -> Bool {
    if lhs.apiName != rhs.apiName {return false}
    if lhs.uiName != rhs.uiName {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.deprecatedApiNames != rhs.deprecatedApiNames {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Analytics_Data_V1alpha_MetricMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MetricMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "api_name"),
    2: .standard(proto: "ui_name"),
    3: .same(proto: "description"),
    4: .standard(proto: "deprecated_api_names"),
    5: .same(proto: "type"),
    6: .same(proto: "expression"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.apiName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.uiName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.deprecatedApiNames) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.expression) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.apiName.isEmpty {
      try visitor.visitSingularStringField(value: self.apiName, fieldNumber: 1)
    }
    if !self.uiName.isEmpty {
      try visitor.visitSingularStringField(value: self.uiName, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if !self.deprecatedApiNames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.deprecatedApiNames, fieldNumber: 4)
    }
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 5)
    }
    if !self.expression.isEmpty {
      try visitor.visitSingularStringField(value: self.expression, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Analytics_Data_V1alpha_MetricMetadata, rhs: Google_Analytics_Data_V1alpha_MetricMetadata) -> Bool {
    if lhs.apiName != rhs.apiName {return false}
    if lhs.uiName != rhs.uiName {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.deprecatedApiNames != rhs.deprecatedApiNames {return false}
    if lhs.type != rhs.type {return false}
    if lhs.expression != rhs.expression {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

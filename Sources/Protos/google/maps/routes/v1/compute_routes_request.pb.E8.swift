// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/maps/routes/v1/compute_routes_request.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A set of values used to specify the mode of travel.
public enum Google_Maps_Routes_V1_RouteTravelMode: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// No travel mode specified. Defaults to `DRIVE`.
  case travelModeUnspecified // = 0

  /// Travel by passenger car.
  case drive // = 1

  /// Travel by bicycle.
  case bicycle // = 2

  /// Travel by walking.
  case walk // = 3

  /// Two-wheeled, motorized vehicle. For example, motorcycle. Note that this
  /// differs from the `BICYCLE` travel mode which covers human-powered mode.
  case twoWheeler // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .travelModeUnspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .travelModeUnspecified
    case 1: self = .drive
    case 2: self = .bicycle
    case 3: self = .walk
    case 4: self = .twoWheeler
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .travelModeUnspecified: return 0
    case .drive: return 1
    case .bicycle: return 2
    case .walk: return 3
    case .twoWheeler: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Maps_Routes_V1_RouteTravelMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Maps_Routes_V1_RouteTravelMode] = [
    .travelModeUnspecified,
    .drive,
    .bicycle,
    .walk,
    .twoWheeler,
  ]
}

#endif  // swift(>=4.2)

/// A set of values that specify factors to take into consideration when
/// calculating the route.
public enum Google_Maps_Routes_V1_RoutingPreference: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// No routing preference specified. Default to `TRAFFIC_AWARE`.
  case unspecified // = 0

  /// Computes routes without taking traffic conditions into consideration.
  /// Suitable when traffic conditions don't matter. Using this value produces
  /// the lowest latency.
  case trafficUnaware // = 1

  /// Calculates routes taking traffic conditions into consideration. In contrast
  /// to `TRAFFIC_AWARE_OPTIMAL`, some optimizations are applied to significantly
  /// reduce latency.
  case trafficAware // = 2

  /// Calculates the routes taking traffic conditions into consideration,
  /// without applying most performance optimizations. Using this value produces
  /// the highest latency.
  case trafficAwareOptimal // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .trafficUnaware
    case 2: self = .trafficAware
    case 3: self = .trafficAwareOptimal
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .trafficUnaware: return 1
    case .trafficAware: return 2
    case .trafficAwareOptimal: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Maps_Routes_V1_RoutingPreference: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Maps_Routes_V1_RoutingPreference] = [
    .unspecified,
    .trafficUnaware,
    .trafficAware,
    .trafficAwareOptimal,
  ]
}

#endif  // swift(>=4.2)

/// A set of values that specify the unit of measure used in the display.
public enum Google_Maps_Routes_V1_Units: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Units of measure not specified. Defaults to the unit of measure inferred
  /// from the request.
  case unspecified // = 0

  /// Metric units of measure.
  case metric // = 1

  /// Imperial (English) units of measure.
  case imperial // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .metric
    case 2: self = .imperial
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .metric: return 1
    case .imperial: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Maps_Routes_V1_Units: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Maps_Routes_V1_Units] = [
    .unspecified,
    .metric,
    .imperial,
  ]
}

#endif  // swift(>=4.2)

/// ComputeRoutes request message.
public struct Google_Maps_Routes_V1_ComputeRoutesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Origin waypoint.
  public var origin: Google_Maps_Routes_V1_Waypoint {
    get {return _storage._origin ?? Google_Maps_Routes_V1_Waypoint()}
    set {_uniqueStorage()._origin = newValue}
  }
  /// Returns true if `origin` has been explicitly set.
  public var hasOrigin: Bool {return _storage._origin != nil}
  /// Clears the value of `origin`. Subsequent reads from it will return its default value.
  public mutating func clearOrigin() {_uniqueStorage()._origin = nil}

  /// Required. Destination waypoint.
  public var destination: Google_Maps_Routes_V1_Waypoint {
    get {return _storage._destination ?? Google_Maps_Routes_V1_Waypoint()}
    set {_uniqueStorage()._destination = newValue}
  }
  /// Returns true if `destination` has been explicitly set.
  public var hasDestination: Bool {return _storage._destination != nil}
  /// Clears the value of `destination`. Subsequent reads from it will return its default value.
  public mutating func clearDestination() {_uniqueStorage()._destination = nil}

  /// Optional. A set of waypoints along the route (excluding terminal points),
  /// for either stopping at or passing by. Up to 25 intermediate waypoints are
  /// supported.
  public var intermediates: [Google_Maps_Routes_V1_Waypoint] {
    get {return _storage._intermediates}
    set {_uniqueStorage()._intermediates = newValue}
  }

  /// Optional. Specifies the mode of transportation.
  public var travelMode: Google_Maps_Routes_V1_RouteTravelMode {
    get {return _storage._travelMode}
    set {_uniqueStorage()._travelMode = newValue}
  }

  /// Optional. Specifies how to compute the route. The server
  /// attempts to use the selected routing preference to compute the route. If
  ///  the routing preference results in an error or an extra long latency, then
  /// an error is returned. In the future, we might implement a fallback
  /// mechanism to use a different option when the preferred option does not give
  /// a valid result. You can specify this option only when the `travel_mode` is
  /// `DRIVE` or `TWO_WHEELER`, otherwise the request fails.
  public var routingPreference: Google_Maps_Routes_V1_RoutingPreference {
    get {return _storage._routingPreference}
    set {_uniqueStorage()._routingPreference = newValue}
  }

  /// Optional. Specifies your preference for the quality of the polyline.
  public var polylineQuality: Google_Maps_Routes_V1_PolylineQuality {
    get {return _storage._polylineQuality}
    set {_uniqueStorage()._polylineQuality = newValue}
  }

  /// Optional. The departure time. If you don't set this value, then this value
  /// defaults to the time that you made the request. If you set this value to a
  /// time that has already occurred, then the request fails.
  public var departureTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._departureTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._departureTime = newValue}
  }
  /// Returns true if `departureTime` has been explicitly set.
  public var hasDepartureTime: Bool {return _storage._departureTime != nil}
  /// Clears the value of `departureTime`. Subsequent reads from it will return its default value.
  public mutating func clearDepartureTime() {_uniqueStorage()._departureTime = nil}

  /// Specifies whether to calculate alternate routes in addition to the route.
  public var computeAlternativeRoutes: Bool {
    get {return _storage._computeAlternativeRoutes}
    set {_uniqueStorage()._computeAlternativeRoutes = newValue}
  }

  /// Optional. A set of conditions to satisfy that affect the way routes are
  /// calculated.
  public var routeModifiers: Google_Maps_Routes_V1_RouteModifiers {
    get {return _storage._routeModifiers ?? Google_Maps_Routes_V1_RouteModifiers()}
    set {_uniqueStorage()._routeModifiers = newValue}
  }
  /// Returns true if `routeModifiers` has been explicitly set.
  public var hasRouteModifiers: Bool {return _storage._routeModifiers != nil}
  /// Clears the value of `routeModifiers`. Subsequent reads from it will return its default value.
  public mutating func clearRouteModifiers() {_uniqueStorage()._routeModifiers = nil}

  /// Optional. The BCP-47 language code, such as "en-US" or "sr-Latn". For more
  /// information, see
  /// http://www.unicode.org/reports/tr35/#Unicode_locale_identifier. See
  /// [Language Support](https://developers.google.com/maps/faq#languagesupport)
  /// for the list of supported languages. When you don't provide this value, the
  /// display language is inferred from the location of the route request.
  public var languageCode: String {
    get {return _storage._languageCode}
    set {_uniqueStorage()._languageCode = newValue}
  }

  /// Optional. Specifies the units of measure for the display fields. This
  /// includes the `instruction` field in `NavigationInstruction`. The units of
  /// measure used for the route, leg, step distance, and duration are not
  /// affected by this value. If you don't provide this value, then the display
  /// units are inferred from the location of the request.
  public var units: Google_Maps_Routes_V1_Units {
    get {return _storage._units}
    set {_uniqueStorage()._units = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Encapsulates a set of optional conditions to satisfy when calculating the
/// routes.
public struct Google_Maps_Routes_V1_RouteModifiers {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies whether to avoid toll roads where reasonable. Preference will be
  /// given to routes not containing toll roads. Applies only to the `DRIVE` and
  /// `TWO_WHEELER` travel modes.
  public var avoidTolls: Bool = false

  /// Specifies whether to avoid highways where reasonable. Preference will be
  /// given to routes not containing highways. Applies only to the `DRIVE` and
  /// `TWO_WHEELER` travel modes.
  public var avoidHighways: Bool = false

  /// Specifies whether to avoid ferries where reasonable. Preference will be
  /// given to routes not containing travel by ferries.
  /// Applies only to the `DRIVE` and`TWO_WHEELER` travel modes.
  public var avoidFerries: Bool = false

  /// Specifies whether to avoid navigating indoors where reasonable. Preference
  /// will be given to routes not containing indoor navigation.
  /// Applies only to the `WALK` travel mode.
  public var avoidIndoor: Bool = false

  /// Optional. Specifies the vehicle information.
  public var vehicleInfo: Google_Maps_Routes_V1_VehicleInfo {
    get {return _vehicleInfo ?? Google_Maps_Routes_V1_VehicleInfo()}
    set {_vehicleInfo = newValue}
  }
  /// Returns true if `vehicleInfo` has been explicitly set.
  public var hasVehicleInfo: Bool {return self._vehicleInfo != nil}
  /// Clears the value of `vehicleInfo`. Subsequent reads from it will return its default value.
  public mutating func clearVehicleInfo() {self._vehicleInfo = nil}

  /// Encapsulates information about toll passes.
  /// TollPass is unset means no available pass.
  /// Applies only to the DRIVE and TWO_WHEELER travel modes.
  public var tollPasses: [Google_Maps_Routes_V1_TollPass] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _vehicleInfo: Google_Maps_Routes_V1_VehicleInfo? = nil
}

/// Encapsulates the vehicle information, such as the license plate last
/// character.
public struct Google_Maps_Routes_V1_VehicleInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies the license plate last character. Could be a digit or a letter.
  public var licensePlateLastCharacter: String = String()

  /// Describes the vehicle's emission type.
  /// Applies only to the DRIVE travel mode.
  public var emissionType: Google_Maps_Routes_V1_VehicleEmissionType = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.maps.routes.v1"

extension Google_Maps_Routes_V1_RouteTravelMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TRAVEL_MODE_UNSPECIFIED"),
    1: .same(proto: "DRIVE"),
    2: .same(proto: "BICYCLE"),
    3: .same(proto: "WALK"),
    4: .same(proto: "TWO_WHEELER"),
  ]
}

extension Google_Maps_Routes_V1_RoutingPreference: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ROUTING_PREFERENCE_UNSPECIFIED"),
    1: .same(proto: "TRAFFIC_UNAWARE"),
    2: .same(proto: "TRAFFIC_AWARE"),
    3: .same(proto: "TRAFFIC_AWARE_OPTIMAL"),
  ]
}

extension Google_Maps_Routes_V1_Units: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNITS_UNSPECIFIED"),
    1: .same(proto: "METRIC"),
    2: .same(proto: "IMPERIAL"),
  ]
}

extension Google_Maps_Routes_V1_ComputeRoutesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ComputeRoutesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "origin"),
    2: .same(proto: "destination"),
    3: .same(proto: "intermediates"),
    4: .standard(proto: "travel_mode"),
    5: .standard(proto: "routing_preference"),
    6: .standard(proto: "polyline_quality"),
    7: .standard(proto: "departure_time"),
    8: .standard(proto: "compute_alternative_routes"),
    9: .standard(proto: "route_modifiers"),
    10: .standard(proto: "language_code"),
    11: .same(proto: "units"),
  ]

  fileprivate class _StorageClass {
    var _origin: Google_Maps_Routes_V1_Waypoint? = nil
    var _destination: Google_Maps_Routes_V1_Waypoint? = nil
    var _intermediates: [Google_Maps_Routes_V1_Waypoint] = []
    var _travelMode: Google_Maps_Routes_V1_RouteTravelMode = .travelModeUnspecified
    var _routingPreference: Google_Maps_Routes_V1_RoutingPreference = .unspecified
    var _polylineQuality: Google_Maps_Routes_V1_PolylineQuality = .unspecified
    var _departureTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _computeAlternativeRoutes: Bool = false
    var _routeModifiers: Google_Maps_Routes_V1_RouteModifiers? = nil
    var _languageCode: String = String()
    var _units: Google_Maps_Routes_V1_Units = .unspecified

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _origin = source._origin
      _destination = source._destination
      _intermediates = source._intermediates
      _travelMode = source._travelMode
      _routingPreference = source._routingPreference
      _polylineQuality = source._polylineQuality
      _departureTime = source._departureTime
      _computeAlternativeRoutes = source._computeAlternativeRoutes
      _routeModifiers = source._routeModifiers
      _languageCode = source._languageCode
      _units = source._units
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._origin) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._destination) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._intermediates) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._travelMode) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._routingPreference) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._polylineQuality) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._departureTime) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._computeAlternativeRoutes) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._routeModifiers) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._languageCode) }()
        case 11: try { try decoder.decodeSingularEnumField(value: &_storage._units) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._origin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._destination {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._intermediates.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._intermediates, fieldNumber: 3)
      }
      if _storage._travelMode != .travelModeUnspecified {
        try visitor.visitSingularEnumField(value: _storage._travelMode, fieldNumber: 4)
      }
      if _storage._routingPreference != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._routingPreference, fieldNumber: 5)
      }
      if _storage._polylineQuality != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._polylineQuality, fieldNumber: 6)
      }
      if let v = _storage._departureTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if _storage._computeAlternativeRoutes != false {
        try visitor.visitSingularBoolField(value: _storage._computeAlternativeRoutes, fieldNumber: 8)
      }
      if let v = _storage._routeModifiers {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if !_storage._languageCode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._languageCode, fieldNumber: 10)
      }
      if _storage._units != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._units, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Maps_Routes_V1_ComputeRoutesRequest, rhs: Google_Maps_Routes_V1_ComputeRoutesRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._origin != rhs_storage._origin {return false}
        if _storage._destination != rhs_storage._destination {return false}
        if _storage._intermediates != rhs_storage._intermediates {return false}
        if _storage._travelMode != rhs_storage._travelMode {return false}
        if _storage._routingPreference != rhs_storage._routingPreference {return false}
        if _storage._polylineQuality != rhs_storage._polylineQuality {return false}
        if _storage._departureTime != rhs_storage._departureTime {return false}
        if _storage._computeAlternativeRoutes != rhs_storage._computeAlternativeRoutes {return false}
        if _storage._routeModifiers != rhs_storage._routeModifiers {return false}
        if _storage._languageCode != rhs_storage._languageCode {return false}
        if _storage._units != rhs_storage._units {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Maps_Routes_V1_RouteModifiers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RouteModifiers"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "avoid_tolls"),
    2: .standard(proto: "avoid_highways"),
    3: .standard(proto: "avoid_ferries"),
    4: .standard(proto: "avoid_indoor"),
    5: .standard(proto: "vehicle_info"),
    6: .standard(proto: "toll_passes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.avoidTolls) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.avoidHighways) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.avoidFerries) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.avoidIndoor) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._vehicleInfo) }()
      case 6: try { try decoder.decodeRepeatedEnumField(value: &self.tollPasses) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.avoidTolls != false {
      try visitor.visitSingularBoolField(value: self.avoidTolls, fieldNumber: 1)
    }
    if self.avoidHighways != false {
      try visitor.visitSingularBoolField(value: self.avoidHighways, fieldNumber: 2)
    }
    if self.avoidFerries != false {
      try visitor.visitSingularBoolField(value: self.avoidFerries, fieldNumber: 3)
    }
    if self.avoidIndoor != false {
      try visitor.visitSingularBoolField(value: self.avoidIndoor, fieldNumber: 4)
    }
    if let v = self._vehicleInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.tollPasses.isEmpty {
      try visitor.visitPackedEnumField(value: self.tollPasses, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Maps_Routes_V1_RouteModifiers, rhs: Google_Maps_Routes_V1_RouteModifiers) -> Bool {
    if lhs.avoidTolls != rhs.avoidTolls {return false}
    if lhs.avoidHighways != rhs.avoidHighways {return false}
    if lhs.avoidFerries != rhs.avoidFerries {return false}
    if lhs.avoidIndoor != rhs.avoidIndoor {return false}
    if lhs._vehicleInfo != rhs._vehicleInfo {return false}
    if lhs.tollPasses != rhs.tollPasses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Maps_Routes_V1_VehicleInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VehicleInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "license_plate_last_character"),
    2: .standard(proto: "emission_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.licensePlateLastCharacter) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.emissionType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.licensePlateLastCharacter.isEmpty {
      try visitor.visitSingularStringField(value: self.licensePlateLastCharacter, fieldNumber: 1)
    }
    if self.emissionType != .unspecified {
      try visitor.visitSingularEnumField(value: self.emissionType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Maps_Routes_V1_VehicleInfo, rhs: Google_Maps_Routes_V1_VehicleInfo) -> Bool {
    if lhs.licensePlateLastCharacter != rhs.licensePlateLastCharacter {return false}
    if lhs.emissionType != rhs.emissionType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

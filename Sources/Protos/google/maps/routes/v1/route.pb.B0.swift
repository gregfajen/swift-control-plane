// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/maps/routes/v1/route.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A set of values that specify the navigation action to take for the current
/// step (e.g., turn left, merge, straight, etc.).
public enum Google_Maps_Routes_V1_Maneuver: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Not used.
  case unspecified // = 0

  /// Turn slightly to the left.
  case turnSlightLeft // = 1

  /// Turn sharply to the left.
  case turnSharpLeft // = 2

  /// Make a left u-turn.
  case uturnLeft // = 3

  /// Turn left.
  case turnLeft // = 4

  /// Turn slightly to the right.
  case turnSlightRight // = 5

  /// Turn sharply to the right.
  case turnSharpRight // = 6

  /// Make a right u-turn.
  case uturnRight // = 7

  /// Turn right.
  case turnRight // = 8

  /// Go straight.
  case straight // = 9

  /// Take the left ramp.
  case rampLeft // = 10

  /// Take the right ramp.
  case rampRight // = 11

  /// Merge into traffic.
  case merge // = 12

  /// Take the left fork.
  case forkLeft // = 13

  /// Take the right fork.
  case forkRight // = 14

  /// Take the ferry.
  case ferry // = 15

  /// Take the train leading onto the ferry.
  case ferryTrain // = 16

  /// Turn left at the roundabout.
  case roundaboutLeft // = 17

  /// Turn right at the roundabout.
  case roundaboutRight // = 18
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .turnSlightLeft
    case 2: self = .turnSharpLeft
    case 3: self = .uturnLeft
    case 4: self = .turnLeft
    case 5: self = .turnSlightRight
    case 6: self = .turnSharpRight
    case 7: self = .uturnRight
    case 8: self = .turnRight
    case 9: self = .straight
    case 10: self = .rampLeft
    case 11: self = .rampRight
    case 12: self = .merge
    case 13: self = .forkLeft
    case 14: self = .forkRight
    case 15: self = .ferry
    case 16: self = .ferryTrain
    case 17: self = .roundaboutLeft
    case 18: self = .roundaboutRight
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .turnSlightLeft: return 1
    case .turnSharpLeft: return 2
    case .uturnLeft: return 3
    case .turnLeft: return 4
    case .turnSlightRight: return 5
    case .turnSharpRight: return 6
    case .uturnRight: return 7
    case .turnRight: return 8
    case .straight: return 9
    case .rampLeft: return 10
    case .rampRight: return 11
    case .merge: return 12
    case .forkLeft: return 13
    case .forkRight: return 14
    case .ferry: return 15
    case .ferryTrain: return 16
    case .roundaboutLeft: return 17
    case .roundaboutRight: return 18
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Maps_Routes_V1_Maneuver: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Maps_Routes_V1_Maneuver] = [
    .unspecified,
    .turnSlightLeft,
    .turnSharpLeft,
    .uturnLeft,
    .turnLeft,
    .turnSlightRight,
    .turnSharpRight,
    .uturnRight,
    .turnRight,
    .straight,
    .rampLeft,
    .rampRight,
    .merge,
    .forkLeft,
    .forkRight,
    .ferry,
    .ferryTrain,
    .roundaboutLeft,
    .roundaboutRight,
  ]
}

#endif  // swift(>=4.2)

/// Encapsulates a route, which consists of a series of connected road segments
/// that join beginning, ending, and intermediate waypoints.
public struct Google_Maps_Routes_V1_Route {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A collection of legs (path segments between waypoints) that make-up the
  /// route. Each leg corresponds to the trip between two non-`via` Waypoints.
  /// For example, a route with no intermediate waypoints has only one leg. A
  /// route that includes one non-`via` intermediate waypoint has two legs. A
  /// route that includes one `via` intermediate waypoint has one leg. The order
  /// of the legs matches the order of Waypoints from `origin` to `intermediates`
  /// to `destination`.
  public var legs: [Google_Maps_Routes_V1_RouteLeg] = []

  /// The travel distance of the route, in meters.
  public var distanceMeters: Int32 = 0

  /// The length of time needed to navigate the route. If you set the
  /// `route_preference` to `TRAFFIC_UNAWARE`, then this value is the same as
  /// `static_duration`. If you set the `route_preference` to either
  /// `TRAFFIC_AWARE` or `TRAFFIC_AWARE_OPTIMAL`, then this value is calculated
  /// taking traffic conditions into account.
  public var duration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _duration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_duration = newValue}
  }
  /// Returns true if `duration` has been explicitly set.
  public var hasDuration: Bool {return self._duration != nil}
  /// Clears the value of `duration`. Subsequent reads from it will return its default value.
  public mutating func clearDuration() {self._duration = nil}

  /// The duration of traveling through the route without taking traffic
  /// conditions into consideration.
  public var staticDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _staticDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_staticDuration = newValue}
  }
  /// Returns true if `staticDuration` has been explicitly set.
  public var hasStaticDuration: Bool {return self._staticDuration != nil}
  /// Clears the value of `staticDuration`. Subsequent reads from it will return its default value.
  public mutating func clearStaticDuration() {self._staticDuration = nil}

  /// The overall route polyline. This polyline will be the combined polyline of
  /// all `legs`.
  public var polyline: Google_Maps_Routes_V1_Polyline {
    get {return _polyline ?? Google_Maps_Routes_V1_Polyline()}
    set {_polyline = newValue}
  }
  /// Returns true if `polyline` has been explicitly set.
  public var hasPolyline: Bool {return self._polyline != nil}
  /// Clears the value of `polyline`. Subsequent reads from it will return its default value.
  public mutating func clearPolyline() {self._polyline = nil}

  /// A description of the route.
  public var description_p: String = String()

  /// An array of warnings to show when displaying the route.
  public var warnings: [String] = []

  /// The viewport bounding box of the polyline.
  public var viewport: Google_Geo_Type_Viewport {
    get {return _viewport ?? Google_Geo_Type_Viewport()}
    set {_viewport = newValue}
  }
  /// Returns true if `viewport` has been explicitly set.
  public var hasViewport: Bool {return self._viewport != nil}
  /// Clears the value of `viewport`. Subsequent reads from it will return its default value.
  public mutating func clearViewport() {self._viewport = nil}

  /// Additional information about the route.
  public var travelAdvisory: Google_Maps_Routes_V1_RouteTravelAdvisory {
    get {return _travelAdvisory ?? Google_Maps_Routes_V1_RouteTravelAdvisory()}
    set {_travelAdvisory = newValue}
  }
  /// Returns true if `travelAdvisory` has been explicitly set.
  public var hasTravelAdvisory: Bool {return self._travelAdvisory != nil}
  /// Clears the value of `travelAdvisory`. Subsequent reads from it will return its default value.
  public mutating func clearTravelAdvisory() {self._travelAdvisory = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _duration: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _staticDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _polyline: Google_Maps_Routes_V1_Polyline? = nil
  fileprivate var _viewport: Google_Geo_Type_Viewport? = nil
  fileprivate var _travelAdvisory: Google_Maps_Routes_V1_RouteTravelAdvisory? = nil
}

/// Encapsulates the additional information that the user should be informed
/// about, such as possible traffic zone restriction etc.
public struct Google_Maps_Routes_V1_RouteTravelAdvisory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The traffic restriction that applies to the route. A vehicle that is
  /// subject to the restriction is not allowed to travel on the route. As of
  /// October 2019, only Jakarta, Indonesia takes into consideration.
  public var trafficRestriction: Google_Maps_Routes_V1_TrafficRestriction {
    get {return _trafficRestriction ?? Google_Maps_Routes_V1_TrafficRestriction()}
    set {_trafficRestriction = newValue}
  }
  /// Returns true if `trafficRestriction` has been explicitly set.
  public var hasTrafficRestriction: Bool {return self._trafficRestriction != nil}
  /// Clears the value of `trafficRestriction`. Subsequent reads from it will return its default value.
  public mutating func clearTrafficRestriction() {self._trafficRestriction = nil}

  /// Encapsulates information about tolls on the Route.
  /// This field is only populated if we expect there are tolls on the Route.
  /// If this field is set but the estimated_price subfield is not populated,
  /// we expect that road contains tolls but we do not know an estimated price.
  /// If this field is not set, then we expect there is no toll on the Route.
  public var tollInfo: Google_Maps_Routes_V1_TollInfo {
    get {return _tollInfo ?? Google_Maps_Routes_V1_TollInfo()}
    set {_tollInfo = newValue}
  }
  /// Returns true if `tollInfo` has been explicitly set.
  public var hasTollInfo: Bool {return self._tollInfo != nil}
  /// Clears the value of `tollInfo`. Subsequent reads from it will return its default value.
  public mutating func clearTollInfo() {self._tollInfo = nil}

  /// Speed reading intervals detailing traffic density. Applicable in case of
  /// TRAFFIC_AWARE and TRAFFIC_AWARE_OPTIMAL routing preferences.
  /// The intervals cover the entire polyline of the route without overlaps, i.e.
  /// the start point of a given interval coincides with the end point of the
  /// preceding interval.
  /// Example:
  ///   polyline: A ---- B ---- C ---- D ---- E ---- F ---- G
  ///   speed_reading_intervals: [A,C),  [C,D), [D,G).
  public var speedReadingIntervals: [Google_Maps_Routes_V1_SpeedReadingInterval] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _trafficRestriction: Google_Maps_Routes_V1_TrafficRestriction? = nil
  fileprivate var _tollInfo: Google_Maps_Routes_V1_TollInfo? = nil
}

/// Encapsulates the additional information that the user should be informed
/// about, such as possible traffic zone restriction etc. on a route leg.
public struct Google_Maps_Routes_V1_RouteLegTravelAdvisory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Encapsulates information about tolls on the specific RouteLeg.
  /// This field is only populated if we expect there are tolls on the RouteLeg.
  /// If this field is set but the estimated_price subfield is not populated,
  /// we expect that road contains tolls but we do not know an estimated price.
  /// If this field does not exist, then there is no toll on the RouteLeg.
  public var tollInfo: Google_Maps_Routes_V1_TollInfo {
    get {return _tollInfo ?? Google_Maps_Routes_V1_TollInfo()}
    set {_tollInfo = newValue}
  }
  /// Returns true if `tollInfo` has been explicitly set.
  public var hasTollInfo: Bool {return self._tollInfo != nil}
  /// Clears the value of `tollInfo`. Subsequent reads from it will return its default value.
  public mutating func clearTollInfo() {self._tollInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _tollInfo: Google_Maps_Routes_V1_TollInfo? = nil
}

/// Encapsulates the traffic restriction applied to the route. As of October
/// 2019, only Jakarta, Indonesia takes into consideration.
public struct Google_Maps_Routes_V1_TrafficRestriction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The restriction based on the vehicle's license plate last character. If
  /// this field does not exist, then no restriction on route.
  public var licensePlateLastCharacterRestriction: Google_Maps_Routes_V1_LicensePlateLastCharacterRestriction {
    get {return _licensePlateLastCharacterRestriction ?? Google_Maps_Routes_V1_LicensePlateLastCharacterRestriction()}
    set {_licensePlateLastCharacterRestriction = newValue}
  }
  /// Returns true if `licensePlateLastCharacterRestriction` has been explicitly set.
  public var hasLicensePlateLastCharacterRestriction: Bool {return self._licensePlateLastCharacterRestriction != nil}
  /// Clears the value of `licensePlateLastCharacterRestriction`. Subsequent reads from it will return its default value.
  public mutating func clearLicensePlateLastCharacterRestriction() {self._licensePlateLastCharacterRestriction = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _licensePlateLastCharacterRestriction: Google_Maps_Routes_V1_LicensePlateLastCharacterRestriction? = nil
}

/// Encapsulates the license plate last character restriction.
public struct Google_Maps_Routes_V1_LicensePlateLastCharacterRestriction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The allowed last character of a license plate of a vehicle. Only vehicles
  /// whose license plate's last characters match these are allowed to travel on
  /// the route. If empty, no vehicle is allowed.
  public var allowedLastCharacters: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Encapsulates a segment between non-`via` waypoints.
public struct Google_Maps_Routes_V1_RouteLeg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The travel distance of the route leg, in meters.
  public var distanceMeters: Int32 = 0

  /// The length of time needed to navigate the leg. If the `route_preference`
  /// is set to `TRAFFIC_UNAWARE`, then this value is the same as
  /// `static_duration`. If the `route_preference` is either `TRAFFIC_AWARE` or
  /// `TRAFFIC_AWARE_OPTIMAL`, then this value is calculated taking traffic
  /// conditions into account.
  public var duration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _duration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_duration = newValue}
  }
  /// Returns true if `duration` has been explicitly set.
  public var hasDuration: Bool {return self._duration != nil}
  /// Clears the value of `duration`. Subsequent reads from it will return its default value.
  public mutating func clearDuration() {self._duration = nil}

  /// The duration of traveling through the leg, calculated without taking
  /// traffic conditions into consideration.
  public var staticDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _staticDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_staticDuration = newValue}
  }
  /// Returns true if `staticDuration` has been explicitly set.
  public var hasStaticDuration: Bool {return self._staticDuration != nil}
  /// Clears the value of `staticDuration`. Subsequent reads from it will return its default value.
  public mutating func clearStaticDuration() {self._staticDuration = nil}

  /// The overall polyline for this leg. This includes that each `step`'s
  /// polyline.
  public var polyline: Google_Maps_Routes_V1_Polyline {
    get {return _polyline ?? Google_Maps_Routes_V1_Polyline()}
    set {_polyline = newValue}
  }
  /// Returns true if `polyline` has been explicitly set.
  public var hasPolyline: Bool {return self._polyline != nil}
  /// Clears the value of `polyline`. Subsequent reads from it will return its default value.
  public mutating func clearPolyline() {self._polyline = nil}

  /// The start location of this leg. This might be different from the provided
  /// `origin`. For example, when the provided `origin` is not near a road, this
  /// is a point on the road.
  public var startLocation: Google_Maps_Routes_V1_Location {
    get {return _startLocation ?? Google_Maps_Routes_V1_Location()}
    set {_startLocation = newValue}
  }
  /// Returns true if `startLocation` has been explicitly set.
  public var hasStartLocation: Bool {return self._startLocation != nil}
  /// Clears the value of `startLocation`. Subsequent reads from it will return its default value.
  public mutating func clearStartLocation() {self._startLocation = nil}

  /// The end location of this leg. This might be different from the provided
  /// `destination`. For example, when the provided `destination` is not near a
  /// road, this is a point on the road.
  public var endLocation: Google_Maps_Routes_V1_Location {
    get {return _endLocation ?? Google_Maps_Routes_V1_Location()}
    set {_endLocation = newValue}
  }
  /// Returns true if `endLocation` has been explicitly set.
  public var hasEndLocation: Bool {return self._endLocation != nil}
  /// Clears the value of `endLocation`. Subsequent reads from it will return its default value.
  public mutating func clearEndLocation() {self._endLocation = nil}

  /// An array of steps denoting segments within this leg. Each step represents
  /// one navigation instruction.
  public var steps: [Google_Maps_Routes_V1_RouteLegStep] = []

  /// Encapsulates the additional information that the user should be informed
  /// about, such as possible traffic zone restriction etc. on a route leg.
  public var travelAdvisory: Google_Maps_Routes_V1_RouteLegTravelAdvisory {
    get {return _travelAdvisory ?? Google_Maps_Routes_V1_RouteLegTravelAdvisory()}
    set {_travelAdvisory = newValue}
  }
  /// Returns true if `travelAdvisory` has been explicitly set.
  public var hasTravelAdvisory: Bool {return self._travelAdvisory != nil}
  /// Clears the value of `travelAdvisory`. Subsequent reads from it will return its default value.
  public mutating func clearTravelAdvisory() {self._travelAdvisory = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _duration: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _staticDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _polyline: Google_Maps_Routes_V1_Polyline? = nil
  fileprivate var _startLocation: Google_Maps_Routes_V1_Location? = nil
  fileprivate var _endLocation: Google_Maps_Routes_V1_Location? = nil
  fileprivate var _travelAdvisory: Google_Maps_Routes_V1_RouteLegTravelAdvisory? = nil
}

/// Encapsulates toll information on a `Route` or on a `RouteLeg`.
public struct Google_Maps_Routes_V1_TollInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The monetary amount of tolls for the corresponding Route or RouteLeg.
  /// This list contains a money amount for each currency that is expected
  /// to be charged by the toll stations. Typically this list will contain only
  /// one item for routes with tolls in one currency. For international trips,
  /// this list may contain multiple items to reflect tolls in different
  /// currencies.
  public var estimatedPrice: [Google_Type_Money] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Encapsulates a segment of a `RouteLeg`. A step corresponds to a single
/// navigation instruction. Route legs are made up of steps.
public struct Google_Maps_Routes_V1_RouteLegStep {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The travel distance of this step, in meters. In some circumstances, this
  /// field might not have a value.
  public var distanceMeters: Int32 = 0

  /// The duration of travel through this step without taking traffic conditions
  /// into consideration. In some circumstances, this field might not have a
  /// value.
  public var staticDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _staticDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_staticDuration = newValue}
  }
  /// Returns true if `staticDuration` has been explicitly set.
  public var hasStaticDuration: Bool {return self._staticDuration != nil}
  /// Clears the value of `staticDuration`. Subsequent reads from it will return its default value.
  public mutating func clearStaticDuration() {self._staticDuration = nil}

  /// The polyline associated with this step.
  public var polyline: Google_Maps_Routes_V1_Polyline {
    get {return _polyline ?? Google_Maps_Routes_V1_Polyline()}
    set {_polyline = newValue}
  }
  /// Returns true if `polyline` has been explicitly set.
  public var hasPolyline: Bool {return self._polyline != nil}
  /// Clears the value of `polyline`. Subsequent reads from it will return its default value.
  public mutating func clearPolyline() {self._polyline = nil}

  /// The start location of this step.
  public var startLocation: Google_Maps_Routes_V1_Location {
    get {return _startLocation ?? Google_Maps_Routes_V1_Location()}
    set {_startLocation = newValue}
  }
  /// Returns true if `startLocation` has been explicitly set.
  public var hasStartLocation: Bool {return self._startLocation != nil}
  /// Clears the value of `startLocation`. Subsequent reads from it will return its default value.
  public mutating func clearStartLocation() {self._startLocation = nil}

  /// The end location of this step.
  public var endLocation: Google_Maps_Routes_V1_Location {
    get {return _endLocation ?? Google_Maps_Routes_V1_Location()}
    set {_endLocation = newValue}
  }
  /// Returns true if `endLocation` has been explicitly set.
  public var hasEndLocation: Bool {return self._endLocation != nil}
  /// Clears the value of `endLocation`. Subsequent reads from it will return its default value.
  public mutating func clearEndLocation() {self._endLocation = nil}

  /// Navigation instructions.
  public var navigationInstruction: Google_Maps_Routes_V1_NavigationInstruction {
    get {return _navigationInstruction ?? Google_Maps_Routes_V1_NavigationInstruction()}
    set {_navigationInstruction = newValue}
  }
  /// Returns true if `navigationInstruction` has been explicitly set.
  public var hasNavigationInstruction: Bool {return self._navigationInstruction != nil}
  /// Clears the value of `navigationInstruction`. Subsequent reads from it will return its default value.
  public mutating func clearNavigationInstruction() {self._navigationInstruction = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _staticDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _polyline: Google_Maps_Routes_V1_Polyline? = nil
  fileprivate var _startLocation: Google_Maps_Routes_V1_Location? = nil
  fileprivate var _endLocation: Google_Maps_Routes_V1_Location? = nil
  fileprivate var _navigationInstruction: Google_Maps_Routes_V1_NavigationInstruction? = nil
}

public struct Google_Maps_Routes_V1_NavigationInstruction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Encapsulates the navigation instructions for the current step (e.g., turn
  /// left, merge, straight, etc.). This field determines which icon to display.
  public var maneuver: Google_Maps_Routes_V1_Maneuver = .unspecified

  /// Instructions for navigating this step.
  public var instructions: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Traffic density indicator on a contiguous segment of a polyline or path.
/// Given a path with points P_0, P_1, ... , P_N (zero-based index), the
/// SpeedReadingInterval defines an interval and describes its traffic using the
/// following categories.
public struct Google_Maps_Routes_V1_SpeedReadingInterval {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The starting index of this interval in the polyline.
  /// In JSON, when the index is 0, the field will appear to be unpopulated.
  public var startPolylinePointIndex: Int32 = 0

  /// The ending index of this interval in the polyline.
  /// In JSON, when the index is 0, the field will appear to be unpopulated.
  public var endPolylinePointIndex: Int32 = 0

  /// Traffic speed in this interval.
  public var speed: Google_Maps_Routes_V1_SpeedReadingInterval.Speed = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The classification of polyline speed based on traffic data.
  public enum Speed: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Default value. This value is unused.
    case unspecified // = 0

    /// Normal speed, no slowdown is detected.
    case normal // = 1

    /// Slowdown detected, but no traffic jam formed.
    case slow // = 2

    /// Traffic jam detected.
    case trafficJam // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .normal
      case 2: self = .slow
      case 3: self = .trafficJam
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .normal: return 1
      case .slow: return 2
      case .trafficJam: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Maps_Routes_V1_SpeedReadingInterval.Speed: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Maps_Routes_V1_SpeedReadingInterval.Speed] = [
    .unspecified,
    .normal,
    .slow,
    .trafficJam,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.maps.routes.v1"

extension Google_Maps_Routes_V1_Maneuver: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MANEUVER_UNSPECIFIED"),
    1: .same(proto: "TURN_SLIGHT_LEFT"),
    2: .same(proto: "TURN_SHARP_LEFT"),
    3: .same(proto: "UTURN_LEFT"),
    4: .same(proto: "TURN_LEFT"),
    5: .same(proto: "TURN_SLIGHT_RIGHT"),
    6: .same(proto: "TURN_SHARP_RIGHT"),
    7: .same(proto: "UTURN_RIGHT"),
    8: .same(proto: "TURN_RIGHT"),
    9: .same(proto: "STRAIGHT"),
    10: .same(proto: "RAMP_LEFT"),
    11: .same(proto: "RAMP_RIGHT"),
    12: .same(proto: "MERGE"),
    13: .same(proto: "FORK_LEFT"),
    14: .same(proto: "FORK_RIGHT"),
    15: .same(proto: "FERRY"),
    16: .same(proto: "FERRY_TRAIN"),
    17: .same(proto: "ROUNDABOUT_LEFT"),
    18: .same(proto: "ROUNDABOUT_RIGHT"),
  ]
}

extension Google_Maps_Routes_V1_Route: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Route"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "legs"),
    2: .standard(proto: "distance_meters"),
    3: .same(proto: "duration"),
    4: .standard(proto: "static_duration"),
    5: .same(proto: "polyline"),
    6: .same(proto: "description"),
    7: .same(proto: "warnings"),
    8: .same(proto: "viewport"),
    9: .standard(proto: "travel_advisory"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.legs) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.distanceMeters) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._duration) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._staticDuration) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._polyline) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 7: try { try decoder.decodeRepeatedStringField(value: &self.warnings) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._viewport) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._travelAdvisory) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.legs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.legs, fieldNumber: 1)
    }
    if self.distanceMeters != 0 {
      try visitor.visitSingularInt32Field(value: self.distanceMeters, fieldNumber: 2)
    }
    if let v = self._duration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._staticDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._polyline {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 6)
    }
    if !self.warnings.isEmpty {
      try visitor.visitRepeatedStringField(value: self.warnings, fieldNumber: 7)
    }
    if let v = self._viewport {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    if let v = self._travelAdvisory {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Maps_Routes_V1_Route, rhs: Google_Maps_Routes_V1_Route) -> Bool {
    if lhs.legs != rhs.legs {return false}
    if lhs.distanceMeters != rhs.distanceMeters {return false}
    if lhs._duration != rhs._duration {return false}
    if lhs._staticDuration != rhs._staticDuration {return false}
    if lhs._polyline != rhs._polyline {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.warnings != rhs.warnings {return false}
    if lhs._viewport != rhs._viewport {return false}
    if lhs._travelAdvisory != rhs._travelAdvisory {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Maps_Routes_V1_RouteTravelAdvisory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RouteTravelAdvisory"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "traffic_restriction"),
    2: .standard(proto: "toll_info"),
    3: .standard(proto: "speed_reading_intervals"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._trafficRestriction) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._tollInfo) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.speedReadingIntervals) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._trafficRestriction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._tollInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.speedReadingIntervals.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.speedReadingIntervals, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Maps_Routes_V1_RouteTravelAdvisory, rhs: Google_Maps_Routes_V1_RouteTravelAdvisory) -> Bool {
    if lhs._trafficRestriction != rhs._trafficRestriction {return false}
    if lhs._tollInfo != rhs._tollInfo {return false}
    if lhs.speedReadingIntervals != rhs.speedReadingIntervals {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Maps_Routes_V1_RouteLegTravelAdvisory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RouteLegTravelAdvisory"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "toll_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tollInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._tollInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Maps_Routes_V1_RouteLegTravelAdvisory, rhs: Google_Maps_Routes_V1_RouteLegTravelAdvisory) -> Bool {
    if lhs._tollInfo != rhs._tollInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Maps_Routes_V1_TrafficRestriction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TrafficRestriction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "license_plate_last_character_restriction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._licensePlateLastCharacterRestriction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._licensePlateLastCharacterRestriction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Maps_Routes_V1_TrafficRestriction, rhs: Google_Maps_Routes_V1_TrafficRestriction) -> Bool {
    if lhs._licensePlateLastCharacterRestriction != rhs._licensePlateLastCharacterRestriction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Maps_Routes_V1_LicensePlateLastCharacterRestriction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LicensePlateLastCharacterRestriction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "allowed_last_characters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.allowedLastCharacters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.allowedLastCharacters.isEmpty {
      try visitor.visitRepeatedStringField(value: self.allowedLastCharacters, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Maps_Routes_V1_LicensePlateLastCharacterRestriction, rhs: Google_Maps_Routes_V1_LicensePlateLastCharacterRestriction) -> Bool {
    if lhs.allowedLastCharacters != rhs.allowedLastCharacters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Maps_Routes_V1_RouteLeg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RouteLeg"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "distance_meters"),
    2: .same(proto: "duration"),
    3: .standard(proto: "static_duration"),
    4: .same(proto: "polyline"),
    5: .standard(proto: "start_location"),
    6: .standard(proto: "end_location"),
    7: .same(proto: "steps"),
    8: .standard(proto: "travel_advisory"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.distanceMeters) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._duration) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._staticDuration) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._polyline) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._startLocation) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._endLocation) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.steps) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._travelAdvisory) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.distanceMeters != 0 {
      try visitor.visitSingularInt32Field(value: self.distanceMeters, fieldNumber: 1)
    }
    if let v = self._duration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._staticDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._polyline {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._startLocation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._endLocation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if !self.steps.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.steps, fieldNumber: 7)
    }
    if let v = self._travelAdvisory {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Maps_Routes_V1_RouteLeg, rhs: Google_Maps_Routes_V1_RouteLeg) -> Bool {
    if lhs.distanceMeters != rhs.distanceMeters {return false}
    if lhs._duration != rhs._duration {return false}
    if lhs._staticDuration != rhs._staticDuration {return false}
    if lhs._polyline != rhs._polyline {return false}
    if lhs._startLocation != rhs._startLocation {return false}
    if lhs._endLocation != rhs._endLocation {return false}
    if lhs.steps != rhs.steps {return false}
    if lhs._travelAdvisory != rhs._travelAdvisory {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Maps_Routes_V1_TollInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TollInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "estimated_price"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.estimatedPrice) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.estimatedPrice.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.estimatedPrice, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Maps_Routes_V1_TollInfo, rhs: Google_Maps_Routes_V1_TollInfo) -> Bool {
    if lhs.estimatedPrice != rhs.estimatedPrice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Maps_Routes_V1_RouteLegStep: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RouteLegStep"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "distance_meters"),
    2: .standard(proto: "static_duration"),
    3: .same(proto: "polyline"),
    4: .standard(proto: "start_location"),
    5: .standard(proto: "end_location"),
    6: .standard(proto: "navigation_instruction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.distanceMeters) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._staticDuration) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._polyline) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._startLocation) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._endLocation) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._navigationInstruction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.distanceMeters != 0 {
      try visitor.visitSingularInt32Field(value: self.distanceMeters, fieldNumber: 1)
    }
    if let v = self._staticDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._polyline {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._startLocation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._endLocation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._navigationInstruction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Maps_Routes_V1_RouteLegStep, rhs: Google_Maps_Routes_V1_RouteLegStep) -> Bool {
    if lhs.distanceMeters != rhs.distanceMeters {return false}
    if lhs._staticDuration != rhs._staticDuration {return false}
    if lhs._polyline != rhs._polyline {return false}
    if lhs._startLocation != rhs._startLocation {return false}
    if lhs._endLocation != rhs._endLocation {return false}
    if lhs._navigationInstruction != rhs._navigationInstruction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Maps_Routes_V1_NavigationInstruction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NavigationInstruction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "maneuver"),
    2: .same(proto: "instructions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.maneuver) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.instructions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maneuver != .unspecified {
      try visitor.visitSingularEnumField(value: self.maneuver, fieldNumber: 1)
    }
    if !self.instructions.isEmpty {
      try visitor.visitSingularStringField(value: self.instructions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Maps_Routes_V1_NavigationInstruction, rhs: Google_Maps_Routes_V1_NavigationInstruction) -> Bool {
    if lhs.maneuver != rhs.maneuver {return false}
    if lhs.instructions != rhs.instructions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Maps_Routes_V1_SpeedReadingInterval: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SpeedReadingInterval"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_polyline_point_index"),
    2: .standard(proto: "end_polyline_point_index"),
    3: .same(proto: "speed"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.startPolylinePointIndex) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.endPolylinePointIndex) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.speed) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.startPolylinePointIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.startPolylinePointIndex, fieldNumber: 1)
    }
    if self.endPolylinePointIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.endPolylinePointIndex, fieldNumber: 2)
    }
    if self.speed != .unspecified {
      try visitor.visitSingularEnumField(value: self.speed, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Maps_Routes_V1_SpeedReadingInterval, rhs: Google_Maps_Routes_V1_SpeedReadingInterval) -> Bool {
    if lhs.startPolylinePointIndex != rhs.startPolylinePointIndex {return false}
    if lhs.endPolylinePointIndex != rhs.endPolylinePointIndex {return false}
    if lhs.speed != rhs.speed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Maps_Routes_V1_SpeedReadingInterval.Speed: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SPEED_UNSPECIFIED"),
    1: .same(proto: "NORMAL"),
    2: .same(proto: "SLOW"),
    3: .same(proto: "TRAFFIC_JAM"),
  ]
}

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/maps/routes/v1/waypoint.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Encapsulates a waypoint. Waypoints mark both the beginning and end of a
/// route, and include intermediate stops along the route.
public struct Google_Maps_Routes_V1_Waypoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Different ways to represent a location.
  public var locationType: Google_Maps_Routes_V1_Waypoint.OneOf_LocationType? = nil

  /// A point specified using geographic coordinates, including an optional
  /// heading.
  public var location: Google_Maps_Routes_V1_Location {
    get {
      if case .location(let v)? = locationType {return v}
      return Google_Maps_Routes_V1_Location()
    }
    set {locationType = .location(newValue)}
  }

  /// The POI Place ID associated with the waypoint.
  public var placeID: String {
    get {
      if case .placeID(let v)? = locationType {return v}
      return String()
    }
    set {locationType = .placeID(newValue)}
  }

  /// Marks this waypoint as a milestone, as opposed to a stopping point. For
  /// each non-via waypoint in the request, the response appends an entry to the
  /// `legs` array to provide the details for stopovers on that leg of the
  /// trip. Set this value to true when you want the route to pass through this
  /// waypoint without stopping over. Via waypoints don't cause an entry to be
  /// added to the `legs` array, but they do route the journey through the
  /// waypoint. You can only set this value on waypoints that are intermediates.
  /// If you set this field on terminal waypoints, then the request fails.
  public var via: Bool = false

  /// Indicates that the waypoint is meant for vehicles to stop at, where the
  /// intention is to either pickup or drop-off. When you set this value, the
  /// calculated route won't include non-`via` waypoints on roads that are
  /// unsuitable for pickup and drop-off. This option works only for `DRIVE` and
  /// `TWO_WHEELER` travel modes, and when the `location_type` is `location`.
  public var vehicleStopover: Bool = false

  /// Indicates that the location of this waypoint is meant to have a preference
  /// for the vehicle to stop at a particular side of road. When you set this
  /// value, the route will pass through the location so that the vehicle can
  /// stop at the side of road that the location is biased towards from the
  /// center of the road. This option works only for 'DRIVE' and 'TWO_WHEELER'
  /// travel modes, and when the 'location_type' is set to 'location'.
  public var sideOfRoad: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Different ways to represent a location.
  public enum OneOf_LocationType: Equatable {
    /// A point specified using geographic coordinates, including an optional
    /// heading.
    case location(Google_Maps_Routes_V1_Location)
    /// The POI Place ID associated with the waypoint.
    case placeID(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Maps_Routes_V1_Waypoint.OneOf_LocationType, rhs: Google_Maps_Routes_V1_Waypoint.OneOf_LocationType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.location, .location): return {
        guard case .location(let l) = lhs, case .location(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.placeID, .placeID): return {
        guard case .placeID(let l) = lhs, case .placeID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Encapsulates a location (a geographic point, and an optional heading).
public struct Google_Maps_Routes_V1_Location {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The waypoint's geographic coordinates.
  public var latLng: Google_Type_LatLng {
    get {return _latLng ?? Google_Type_LatLng()}
    set {_latLng = newValue}
  }
  /// Returns true if `latLng` has been explicitly set.
  public var hasLatLng: Bool {return self._latLng != nil}
  /// Clears the value of `latLng`. Subsequent reads from it will return its default value.
  public mutating func clearLatLng() {self._latLng = nil}

  /// The compass heading associated with the direction of the flow of traffic.
  /// This value is used to specify the side of the road to use for pickup and
  /// drop-off. Heading values can be from 0 to 360, where 0 specifies a heading
  /// of due North, 90 specifies a heading of due East, etc. You can use this
  /// field only for `DRIVE` and `TWO_WHEELER` travel modes.
  public var heading: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _heading ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_heading = newValue}
  }
  /// Returns true if `heading` has been explicitly set.
  public var hasHeading: Bool {return self._heading != nil}
  /// Clears the value of `heading`. Subsequent reads from it will return its default value.
  public mutating func clearHeading() {self._heading = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _latLng: Google_Type_LatLng? = nil
  fileprivate var _heading: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.maps.routes.v1"

extension Google_Maps_Routes_V1_Waypoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Waypoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "location"),
    2: .standard(proto: "place_id"),
    3: .same(proto: "via"),
    4: .standard(proto: "vehicle_stopover"),
    5: .standard(proto: "side_of_road"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Maps_Routes_V1_Location?
        if let current = self.locationType {
          try decoder.handleConflictingOneOf()
          if case .location(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.locationType = .location(v)}
      }()
      case 2: try {
        if self.locationType != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.locationType = .placeID(v)}
      }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.via) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.vehicleStopover) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.sideOfRoad) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.locationType {
    case .location?: try {
      guard case .location(let v)? = self.locationType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .placeID?: try {
      guard case .placeID(let v)? = self.locationType else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if self.via != false {
      try visitor.visitSingularBoolField(value: self.via, fieldNumber: 3)
    }
    if self.vehicleStopover != false {
      try visitor.visitSingularBoolField(value: self.vehicleStopover, fieldNumber: 4)
    }
    if self.sideOfRoad != false {
      try visitor.visitSingularBoolField(value: self.sideOfRoad, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Maps_Routes_V1_Waypoint, rhs: Google_Maps_Routes_V1_Waypoint) -> Bool {
    if lhs.locationType != rhs.locationType {return false}
    if lhs.via != rhs.via {return false}
    if lhs.vehicleStopover != rhs.vehicleStopover {return false}
    if lhs.sideOfRoad != rhs.sideOfRoad {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Maps_Routes_V1_Location: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Location"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "lat_lng"),
    2: .same(proto: "heading"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._latLng) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._heading) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._latLng {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._heading {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Maps_Routes_V1_Location, rhs: Google_Maps_Routes_V1_Location) -> Bool {
    if lhs._latLng != rhs._latLng {return false}
    if lhs._heading != rhs._heading {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

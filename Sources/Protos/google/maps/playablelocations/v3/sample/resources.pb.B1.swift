// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/maps/playablelocations/v3/sample/resources.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A geographical point suitable for placing game objects in location-based
/// games.
public struct Google_Maps_Playablelocations_V3_Sample_PlayableLocation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of this playable location.
  public var name: String = String()

  /// Required.
  /// Each location has one of the following identifiers:
  public var locationID: Google_Maps_Playablelocations_V3_Sample_PlayableLocation.OneOf_LocationID? = nil

  /// A [place ID] (https://developers.google.com/places/place-id)
  public var placeID: String {
    get {
      if case .placeID(let v)? = locationID {return v}
      return String()
    }
    set {locationID = .placeID(newValue)}
  }

  /// A [plus code] (http://openlocationcode.com)
  public var plusCode: String {
    get {
      if case .plusCode(let v)? = locationID {return v}
      return String()
    }
    set {locationID = .plusCode(newValue)}
  }

  /// A collection of [Playable Location Types](/maps/tt/games/types) for this
  /// playable location. The first type in the collection is the primary type.
  ///
  /// Type information might not be available for all playable locations.
  public var types: [String] = []

  /// Required. The latitude and longitude associated with the center of the
  /// playable location.
  ///
  /// By default, the set of playable locations returned from
  /// [SamplePlayableLocations][google.maps.playablelocations.v3.PlayableLocations.SamplePlayableLocations]
  /// use center-point coordinates.
  public var centerPoint: Google_Type_LatLng {
    get {return _centerPoint ?? Google_Type_LatLng()}
    set {_centerPoint = newValue}
  }
  /// Returns true if `centerPoint` has been explicitly set.
  public var hasCenterPoint: Bool {return self._centerPoint != nil}
  /// Clears the value of `centerPoint`. Subsequent reads from it will return its default value.
  public mutating func clearCenterPoint() {self._centerPoint = nil}

  /// The playable location's coordinates, snapped to the sidewalk of the
  /// nearest road, if a nearby road exists.
  public var snappedPoint: Google_Type_LatLng {
    get {return _snappedPoint ?? Google_Type_LatLng()}
    set {_snappedPoint = newValue}
  }
  /// Returns true if `snappedPoint` has been explicitly set.
  public var hasSnappedPoint: Bool {return self._snappedPoint != nil}
  /// Clears the value of `snappedPoint`. Subsequent reads from it will return its default value.
  public mutating func clearSnappedPoint() {self._snappedPoint = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required.
  /// Each location has one of the following identifiers:
  public enum OneOf_LocationID: Equatable {
    /// A [place ID] (https://developers.google.com/places/place-id)
    case placeID(String)
    /// A [plus code] (http://openlocationcode.com)
    case plusCode(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Maps_Playablelocations_V3_Sample_PlayableLocation.OneOf_LocationID, rhs: Google_Maps_Playablelocations_V3_Sample_PlayableLocation.OneOf_LocationID) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.placeID, .placeID): return {
        guard case .placeID(let l) = lhs, case .placeID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.plusCode, .plusCode): return {
        guard case .plusCode(let l) = lhs, case .plusCode(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _centerPoint: Google_Type_LatLng? = nil
  fileprivate var _snappedPoint: Google_Type_LatLng? = nil
}

/// A set of options that specifies the separation between playable locations.
public struct Google_Maps_Playablelocations_V3_Sample_SpacingOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The minimum spacing between any two playable locations, measured
  /// in meters. The minimum value is 30. The maximum value is 1000.
  ///
  /// Inputs will be rounded up to the next 10 meter interval.
  ///
  /// The default value is 200m.
  ///
  /// Set this field to remove tight clusters of playable locations.
  ///
  /// Note:
  ///
  /// The spacing is a greedy algorithm. It optimizes for selecting the highest
  /// ranking locations first, not to maximize the number of locations selected.
  /// Consider the following scenario:
  ///
  ///   * Rank: A: 2, B: 1, C: 3.
  ///   * Distance: A--200m--B--200m--C
  ///
  /// If spacing=250, it will pick the highest ranked location [B], not [A, C].
  ///
  ///
  /// Note:
  ///
  /// Spacing works within the game object type itself, as well as the previous
  /// ones.
  /// Suppose three game object types, each with the following spacing:
  ///
  ///   * X: 400m, Y: undefined, Z: 200m.
  ///
  /// 1. Add locations for X, within 400m of each other.
  /// 2. Add locations for Y, without any spacing.
  /// 3. Finally, add locations for Z within 200m of each other as well X and Y.
  ///
  /// The distance diagram between those locations end up as:
  ///
  ///   * From->To.
  ///   * X->X: 400m
  ///   * Y->X, Y->Y: unspecified.
  ///   * Z->X, Z->Y, Z->Z: 200m.
  public var minSpacingMeters: Double = 0

  /// Specifies whether the minimum spacing constraint applies to the
  /// center-point or to the snapped point of playable locations. The default
  /// value is `CENTER_POINT`.
  ///
  /// If a snapped point is not available for a playable location, its
  /// center-point is used instead.
  ///
  /// Set this to the point type used in your game.
  public var pointType: Google_Maps_Playablelocations_V3_Sample_SpacingOptions.PointType = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Specifies whether the playable location's geographic coordinates (latitude
  /// and longitude) correspond to its center-point, or to its location snapped
  /// to the sidewalk of the nearest road.
  public enum PointType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unspecified point type. Do not use this value.
    case unspecified // = 0

    /// The geographic coordinates correspond to the center of the location.
    case centerPoint // = 1

    /// The geographic coordinates correspond to the location snapped to the
    /// sidewalk of the nearest road (when a nearby road exists).
    case snappedPoint // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .centerPoint
      case 2: self = .snappedPoint
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .centerPoint: return 1
      case .snappedPoint: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Maps_Playablelocations_V3_Sample_SpacingOptions.PointType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Maps_Playablelocations_V3_Sample_SpacingOptions.PointType] = [
    .unspecified,
    .centerPoint,
    .snappedPoint,
  ]
}

#endif  // swift(>=4.2)

/// Specifies the filters to use when searching for playable locations.
public struct Google_Maps_Playablelocations_V3_Sample_Filter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies the maximum number of playable locations to return. This value
  /// must not be greater than 1000. The default value is 100.
  ///
  /// Only the top-ranking playable locations are returned.
  public var maxLocationCount: Int32 = 0

  /// A set of options that control the spacing between playable locations. By
  /// default the minimum distance between locations is 200m.
  public var spacing: Google_Maps_Playablelocations_V3_Sample_SpacingOptions {
    get {return _spacing ?? Google_Maps_Playablelocations_V3_Sample_SpacingOptions()}
    set {_spacing = newValue}
  }
  /// Returns true if `spacing` has been explicitly set.
  public var hasSpacing: Bool {return self._spacing != nil}
  /// Clears the value of `spacing`. Subsequent reads from it will return its default value.
  public mutating func clearSpacing() {self._spacing = nil}

  /// Restricts the set of playable locations to just the
  /// [types](/maps/tt/games/types) that you want.
  public var includedTypes: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _spacing: Google_Maps_Playablelocations_V3_Sample_SpacingOptions? = nil
}

/// Encapsulates a filter criterion for searching for a set of playable
/// locations.
public struct Google_Maps_Playablelocations_V3_Sample_Criterion {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. An arbitrary, developer-defined identifier of the type of game
  /// object that the playable location is used for. This field allows you to
  /// specify criteria per game object type when searching for playable
  /// locations.
  ///
  /// You should assign a unique `game_object_type` ID across all
  /// `request_criteria` to represent a distinct type of game object. For
  /// example, 1=monster location, 2=powerup location.
  ///
  /// The response contains a map<game_object_type, Response>.
  public var gameObjectType: Int32 = 0

  /// Specifies filtering options, and specifies what will be included in the
  /// result set.
  public var filter: Google_Maps_Playablelocations_V3_Sample_Filter {
    get {return _filter ?? Google_Maps_Playablelocations_V3_Sample_Filter()}
    set {_filter = newValue}
  }
  /// Returns true if `filter` has been explicitly set.
  public var hasFilter: Bool {return self._filter != nil}
  /// Clears the value of `filter`. Subsequent reads from it will return its default value.
  public mutating func clearFilter() {self._filter = nil}

  /// Specifies which `PlayableLocation` fields are returned.
  ///
  /// `name` (which is used for logging impressions), `center_point` and
  /// `place_id` (or `plus_code`) are always returned.
  ///
  /// The following fields are omitted unless you specify them here:
  ///
  ///   * snapped_point
  ///   * types
  ///
  /// Note: The more fields you include, the more expensive in terms of data and
  /// associated latency your query will be.
  public var fieldsToReturn: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _fieldsToReturn ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_fieldsToReturn = newValue}
  }
  /// Returns true if `fieldsToReturn` has been explicitly set.
  public var hasFieldsToReturn: Bool {return self._fieldsToReturn != nil}
  /// Clears the value of `fieldsToReturn`. Subsequent reads from it will return its default value.
  public mutating func clearFieldsToReturn() {self._fieldsToReturn = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _filter: Google_Maps_Playablelocations_V3_Sample_Filter? = nil
  fileprivate var _fieldsToReturn: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Specifies the area to search for playable locations.
public struct Google_Maps_Playablelocations_V3_Sample_AreaFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The S2 cell ID of the area you want. This must be between cell
  /// level 11 and 14 (inclusive).
  ///
  /// S2 cells are 64-bit integers that identify areas on the Earth. They are
  /// hierarchical, and can therefore be used for spatial indexing.
  ///
  /// The S2 geometry library is available in a number of languages:
  ///
  ///   * [C++](https://github.com/google/s2geometry)
  ///   * [Java](https://github.com/google/s2-geometry-library-java)
  ///   * [Go](https://github.com/golang/geo)
  ///   * [Python](https://github.com/google/s2geometry/tree/master/src/python)
  public var s2CellID: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A list of PlayableLocation objects that satisfies a single Criterion.
public struct Google_Maps_Playablelocations_V3_Sample_PlayableLocationList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of playable locations for this game object type.
  public var locations: [Google_Maps_Playablelocations_V3_Sample_PlayableLocation] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.maps.playablelocations.v3.sample"

extension Google_Maps_Playablelocations_V3_Sample_PlayableLocation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlayableLocation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "place_id"),
    3: .standard(proto: "plus_code"),
    4: .same(proto: "types"),
    5: .standard(proto: "center_point"),
    6: .standard(proto: "snapped_point"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try {
        if self.locationID != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.locationID = .placeID(v)}
      }()
      case 3: try {
        if self.locationID != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.locationID = .plusCode(v)}
      }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.types) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._centerPoint) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._snappedPoint) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.locationID {
    case .placeID?: try {
      guard case .placeID(let v)? = self.locationID else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .plusCode?: try {
      guard case .plusCode(let v)? = self.locationID else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if !self.types.isEmpty {
      try visitor.visitRepeatedStringField(value: self.types, fieldNumber: 4)
    }
    if let v = self._centerPoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._snappedPoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Maps_Playablelocations_V3_Sample_PlayableLocation, rhs: Google_Maps_Playablelocations_V3_Sample_PlayableLocation) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.locationID != rhs.locationID {return false}
    if lhs.types != rhs.types {return false}
    if lhs._centerPoint != rhs._centerPoint {return false}
    if lhs._snappedPoint != rhs._snappedPoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Maps_Playablelocations_V3_Sample_SpacingOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SpacingOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "min_spacing_meters"),
    2: .standard(proto: "point_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.minSpacingMeters) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.pointType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.minSpacingMeters != 0 {
      try visitor.visitSingularDoubleField(value: self.minSpacingMeters, fieldNumber: 1)
    }
    if self.pointType != .unspecified {
      try visitor.visitSingularEnumField(value: self.pointType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Maps_Playablelocations_V3_Sample_SpacingOptions, rhs: Google_Maps_Playablelocations_V3_Sample_SpacingOptions) -> Bool {
    if lhs.minSpacingMeters != rhs.minSpacingMeters {return false}
    if lhs.pointType != rhs.pointType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Maps_Playablelocations_V3_Sample_SpacingOptions.PointType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "POINT_TYPE_UNSPECIFIED"),
    1: .same(proto: "CENTER_POINT"),
    2: .same(proto: "SNAPPED_POINT"),
  ]
}

extension Google_Maps_Playablelocations_V3_Sample_Filter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Filter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_location_count"),
    2: .same(proto: "spacing"),
    3: .standard(proto: "included_types"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.maxLocationCount) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._spacing) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.includedTypes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxLocationCount != 0 {
      try visitor.visitSingularInt32Field(value: self.maxLocationCount, fieldNumber: 1)
    }
    if let v = self._spacing {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.includedTypes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.includedTypes, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Maps_Playablelocations_V3_Sample_Filter, rhs: Google_Maps_Playablelocations_V3_Sample_Filter) -> Bool {
    if lhs.maxLocationCount != rhs.maxLocationCount {return false}
    if lhs._spacing != rhs._spacing {return false}
    if lhs.includedTypes != rhs.includedTypes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Maps_Playablelocations_V3_Sample_Criterion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Criterion"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "game_object_type"),
    2: .same(proto: "filter"),
    3: .standard(proto: "fields_to_return"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.gameObjectType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._filter) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._fieldsToReturn) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.gameObjectType != 0 {
      try visitor.visitSingularInt32Field(value: self.gameObjectType, fieldNumber: 1)
    }
    if let v = self._filter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._fieldsToReturn {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Maps_Playablelocations_V3_Sample_Criterion, rhs: Google_Maps_Playablelocations_V3_Sample_Criterion) -> Bool {
    if lhs.gameObjectType != rhs.gameObjectType {return false}
    if lhs._filter != rhs._filter {return false}
    if lhs._fieldsToReturn != rhs._fieldsToReturn {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Maps_Playablelocations_V3_Sample_AreaFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AreaFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "s2_cell_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self.s2CellID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.s2CellID != 0 {
      try visitor.visitSingularFixed64Field(value: self.s2CellID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Maps_Playablelocations_V3_Sample_AreaFilter, rhs: Google_Maps_Playablelocations_V3_Sample_AreaFilter) -> Bool {
    if lhs.s2CellID != rhs.s2CellID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Maps_Playablelocations_V3_Sample_PlayableLocationList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlayableLocationList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "locations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.locations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.locations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.locations, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Maps_Playablelocations_V3_Sample_PlayableLocationList, rhs: Google_Maps_Playablelocations_V3_Sample_PlayableLocationList) -> Bool {
    if lhs.locations != rhs.locations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

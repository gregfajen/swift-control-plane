// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/genomics/v1/reads.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2016 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The read group set search request.
public struct Google_Genomics_V1_SearchReadGroupSetsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Restricts this query to read group sets within the given datasets. At least
  /// one ID must be provided.
  public var datasetIds: [String] = []

  /// Only return read group sets for which a substring of the name matches this
  /// string.
  public var name: String = String()

  /// The continuation token, which is used to page through large result sets.
  /// To get the next page of results, set this parameter to the value of
  /// `nextPageToken` from the previous response.
  public var pageToken: String = String()

  /// The maximum number of results to return in a single page. If unspecified,
  /// defaults to 256. The maximum value is 1024.
  public var pageSize: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The read group set search response.
public struct Google_Genomics_V1_SearchReadGroupSetsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of matching read group sets.
  public var readGroupSets: [Google_Genomics_V1_ReadGroupSet] = []

  /// The continuation token, which is used to page through large result sets.
  /// Provide this value in a subsequent request to return the next page of
  /// results. This field will be empty if there aren't any additional results.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The read group set import request.
public struct Google_Genomics_V1_ImportReadGroupSetsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The ID of the dataset these read group sets will belong to. The
  /// caller must have WRITE permissions to this dataset.
  public var datasetID: String = String()

  /// The reference set to which the imported read group sets are aligned to, if
  /// any. The reference names of this reference set must be a superset of those
  /// found in the imported file headers. If no reference set id is provided, a
  /// best effort is made to associate with a matching reference set.
  public var referenceSetID: String = String()

  /// A list of URIs pointing at [BAM
  /// files](https://samtools.github.io/hts-specs/SAMv1.pdf)
  /// in Google Cloud Storage.
  /// Those URIs can include wildcards (*), but do not add or remove
  /// matching files before import has completed.
  ///
  /// Note that Google Cloud Storage object listing is only eventually
  /// consistent: files added may be not be immediately visible to
  /// everyone. Thus, if using a wildcard it is preferable not to start
  /// the import immediately after the files are created.
  public var sourceUris: [String] = []

  /// The partition strategy describes how read groups are partitioned into read
  /// group sets.
  public var partitionStrategy: Google_Genomics_V1_ImportReadGroupSetsRequest.PartitionStrategy = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum PartitionStrategy: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unspecified // = 0

    /// In most cases, this strategy yields one read group set per file. This is
    /// the default behavior.
    ///
    /// Allocate one read group set per file per sample. For BAM files, read
    /// groups are considered to share a sample if they have identical sample
    /// names. Furthermore, all reads for each file which do not belong to a read
    /// group, if any, will be grouped into a single read group set per-file.
    case perFilePerSample // = 1

    /// Includes all read groups in all imported files into a single read group
    /// set. Requires that the headers for all imported files are equivalent. All
    /// reads which do not belong to a read group, if any, will be grouped into a
    /// separate read group set.
    case mergeAll // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .perFilePerSample
      case 2: self = .mergeAll
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .perFilePerSample: return 1
      case .mergeAll: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Genomics_V1_ImportReadGroupSetsRequest.PartitionStrategy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Genomics_V1_ImportReadGroupSetsRequest.PartitionStrategy] = [
    .unspecified,
    .perFilePerSample,
    .mergeAll,
  ]
}

#endif  // swift(>=4.2)

/// The read group set import response.
public struct Google_Genomics_V1_ImportReadGroupSetsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// IDs of the read group sets that were created.
  public var readGroupSetIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The read group set export request.
public struct Google_Genomics_V1_ExportReadGroupSetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The Google Cloud project ID that owns this
  /// export. The caller must have WRITE access to this project.
  public var projectID: String = String()

  /// Required. A Google Cloud Storage URI for the exported BAM file.
  /// The currently authenticated user must have write access to the new file.
  /// An error will be returned if the URI already contains data.
  public var exportUri: String = String()

  /// Required. The ID of the read group set to export. The caller must have
  /// READ access to this read group set.
  public var readGroupSetID: String = String()

  /// The reference names to export. If this is not specified, all reference
  /// sequences, including unmapped reads, are exported.
  /// Use `*` to export only unmapped reads.
  public var referenceNames: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Google_Genomics_V1_UpdateReadGroupSetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the read group set to be updated. The caller must have WRITE
  /// permissions to the dataset associated with this read group set.
  public var readGroupSetID: String = String()

  /// The new read group set data. See `updateMask` for details on mutability of
  /// fields.
  public var readGroupSet: Google_Genomics_V1_ReadGroupSet {
    get {return _readGroupSet ?? Google_Genomics_V1_ReadGroupSet()}
    set {_readGroupSet = newValue}
  }
  /// Returns true if `readGroupSet` has been explicitly set.
  public var hasReadGroupSet: Bool {return self._readGroupSet != nil}
  /// Clears the value of `readGroupSet`. Subsequent reads from it will return its default value.
  public mutating func clearReadGroupSet() {self._readGroupSet = nil}

  /// An optional mask specifying which fields to update. Supported fields:
  ///
  /// * [name][google.genomics.v1.ReadGroupSet.name].
  /// * [referenceSetId][google.genomics.v1.ReadGroupSet.reference_set_id].
  ///
  /// Leaving `updateMask` unset is equivalent to specifying all mutable
  /// fields.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _readGroupSet: Google_Genomics_V1_ReadGroupSet? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

public struct Google_Genomics_V1_DeleteReadGroupSetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the read group set to be deleted. The caller must have WRITE
  /// permissions to the dataset associated with this read group set.
  public var readGroupSetID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Google_Genomics_V1_GetReadGroupSetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the read group set.
  public var readGroupSetID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Google_Genomics_V1_ListCoverageBucketsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The ID of the read group set over which coverage is requested.
  public var readGroupSetID: String = String()

  /// The name of the reference to query, within the reference set associated
  /// with this query. Optional.
  public var referenceName: String = String()

  /// The start position of the range on the reference, 0-based inclusive. If
  /// specified, `referenceName` must also be specified. Defaults to 0.
  public var start: Int64 = 0

  /// The end position of the range on the reference, 0-based exclusive. If
  /// specified, `referenceName` must also be specified. If unset or 0, defaults
  /// to the length of the reference.
  public var end: Int64 = 0

  /// The desired width of each reported coverage bucket in base pairs. This
  /// will be rounded down to the nearest precomputed bucket width; the value
  /// of which is returned as `bucketWidth` in the response. Defaults
  /// to infinity (each bucket spans an entire reference sequence) or the length
  /// of the target range, if specified. The smallest precomputed
  /// `bucketWidth` is currently 2048 base pairs; this is subject to
  /// change.
  public var targetBucketWidth: Int64 = 0

  /// The continuation token, which is used to page through large result sets.
  /// To get the next page of results, set this parameter to the value of
  /// `nextPageToken` from the previous response.
  public var pageToken: String = String()

  /// The maximum number of results to return in a single page. If unspecified,
  /// defaults to 1024. The maximum value is 2048.
  public var pageSize: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A bucket over which read coverage has been precomputed. A bucket corresponds
/// to a specific range of the reference sequence.
public struct Google_Genomics_V1_CoverageBucket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The genomic coordinate range spanned by this bucket.
  public var range: Google_Genomics_V1_Range {
    get {return _range ?? Google_Genomics_V1_Range()}
    set {_range = newValue}
  }
  /// Returns true if `range` has been explicitly set.
  public var hasRange: Bool {return self._range != nil}
  /// Clears the value of `range`. Subsequent reads from it will return its default value.
  public mutating func clearRange() {self._range = nil}

  /// The average number of reads which are aligned to each individual
  /// reference base in this bucket.
  public var meanCoverage: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _range: Google_Genomics_V1_Range? = nil
}

public struct Google_Genomics_V1_ListCoverageBucketsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The length of each coverage bucket in base pairs. Note that buckets at the
  /// end of a reference sequence may be shorter. This value is omitted if the
  /// bucket width is infinity (the default behaviour, with no range or
  /// `targetBucketWidth`).
  public var bucketWidth: Int64 = 0

  /// The coverage buckets. The list of buckets is sparse; a bucket with 0
  /// overlapping reads is not returned. A bucket never crosses more than one
  /// reference sequence. Each bucket has width `bucketWidth`, unless
  /// its end is the end of the reference sequence.
  public var coverageBuckets: [Google_Genomics_V1_CoverageBucket] = []

  /// The continuation token, which is used to page through large result sets.
  /// Provide this value in a subsequent request to return the next page of
  /// results. This field will be empty if there aren't any additional results.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The read search request.
public struct Google_Genomics_V1_SearchReadsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The IDs of the read groups sets within which to search for reads. All
  /// specified read group sets must be aligned against a common set of reference
  /// sequences; this defines the genomic coordinates for the query. Must specify
  /// one of `readGroupSetIds` or `readGroupIds`.
  public var readGroupSetIds: [String] = []

  /// The IDs of the read groups within which to search for reads. All specified
  /// read groups must belong to the same read group sets. Must specify one of
  /// `readGroupSetIds` or `readGroupIds`.
  public var readGroupIds: [String] = []

  /// The reference sequence name, for example `chr1`, `1`, or `chrX`. If set to
  /// `*`, only unmapped reads are returned. If unspecified, all reads (mapped
  /// and unmapped) are returned.
  public var referenceName: String = String()

  /// The start position of the range on the reference, 0-based inclusive. If
  /// specified, `referenceName` must also be specified.
  public var start: Int64 = 0

  /// The end position of the range on the reference, 0-based exclusive. If
  /// specified, `referenceName` must also be specified.
  public var end: Int64 = 0

  /// The continuation token, which is used to page through large result sets.
  /// To get the next page of results, set this parameter to the value of
  /// `nextPageToken` from the previous response.
  public var pageToken: String = String()

  /// The maximum number of results to return in a single page. If unspecified,
  /// defaults to 256. The maximum value is 2048.
  public var pageSize: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The read search response.
public struct Google_Genomics_V1_SearchReadsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of matching alignments sorted by mapped genomic coordinate,
  /// if any, ascending in position within the same reference. Unmapped reads,
  /// which have no position, are returned contiguously and are sorted in
  /// ascending lexicographic order by fragment name.
  public var alignments: [Google_Genomics_V1_Read] = []

  /// The continuation token, which is used to page through large result sets.
  /// Provide this value in a subsequent request to return the next page of
  /// results. This field will be empty if there aren't any additional results.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The stream reads request.
public struct Google_Genomics_V1_StreamReadsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Google Cloud project ID which will be billed
  /// for this access. The caller must have WRITE access to this project.
  /// Required.
  public var projectID: String = String()

  /// The ID of the read group set from which to stream reads.
  public var readGroupSetID: String = String()

  /// The reference sequence name, for example `chr1`,
  /// `1`, or `chrX`. If set to *, only unmapped reads are
  /// returned.
  public var referenceName: String = String()

  /// The start position of the range on the reference, 0-based inclusive. If
  /// specified, `referenceName` must also be specified.
  public var start: Int64 = 0

  /// The end position of the range on the reference, 0-based exclusive. If
  /// specified, `referenceName` must also be specified.
  public var end: Int64 = 0

  /// Restricts results to a shard containing approximately `1/totalShards`
  /// of the normal response payload for this query. Results from a sharded
  /// request are disjoint from those returned by all queries which differ only
  /// in their shard parameter. A shard may yield 0 results; this is especially
  /// likely for large values of `totalShards`.
  ///
  /// Valid values are `[0, totalShards)`.
  public var shard: Int32 = 0

  /// Specifying `totalShards` causes a disjoint subset of the normal response
  /// payload to be returned for each query with a unique `shard` parameter
  /// specified. A best effort is made to yield equally sized shards. Sharding
  /// can be used to distribute processing amongst workers, where each worker is
  /// assigned a unique `shard` number and all workers specify the same
  /// `totalShards` number. The union of reads returned for all sharded queries
  /// `[0, totalShards)` is equal to those returned by a single unsharded query.
  ///
  /// Queries for different values of `totalShards` with common divisors will
  /// share shard boundaries. For example, streaming `shard` 2 of 5
  /// `totalShards` yields the same results as streaming `shard`s 4 and 5 of 10
  /// `totalShards`. This property can be leveraged for adaptive retries.
  public var totalShards: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Google_Genomics_V1_StreamReadsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var alignments: [Google_Genomics_V1_Read] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.genomics.v1"

extension Google_Genomics_V1_SearchReadGroupSetsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchReadGroupSetsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dataset_ids"),
    3: .same(proto: "name"),
    2: .standard(proto: "page_token"),
    4: .standard(proto: "page_size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.datasetIds) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.datasetIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.datasetIds, fieldNumber: 1)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_SearchReadGroupSetsRequest, rhs: Google_Genomics_V1_SearchReadGroupSetsRequest) -> Bool {
    if lhs.datasetIds != rhs.datasetIds {return false}
    if lhs.name != rhs.name {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_SearchReadGroupSetsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchReadGroupSetsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "read_group_sets"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.readGroupSets) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.readGroupSets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.readGroupSets, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_SearchReadGroupSetsResponse, rhs: Google_Genomics_V1_SearchReadGroupSetsResponse) -> Bool {
    if lhs.readGroupSets != rhs.readGroupSets {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_ImportReadGroupSetsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ImportReadGroupSetsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dataset_id"),
    4: .standard(proto: "reference_set_id"),
    2: .standard(proto: "source_uris"),
    5: .standard(proto: "partition_strategy"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.datasetID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.sourceUris) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.referenceSetID) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.partitionStrategy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.datasetID.isEmpty {
      try visitor.visitSingularStringField(value: self.datasetID, fieldNumber: 1)
    }
    if !self.sourceUris.isEmpty {
      try visitor.visitRepeatedStringField(value: self.sourceUris, fieldNumber: 2)
    }
    if !self.referenceSetID.isEmpty {
      try visitor.visitSingularStringField(value: self.referenceSetID, fieldNumber: 4)
    }
    if self.partitionStrategy != .unspecified {
      try visitor.visitSingularEnumField(value: self.partitionStrategy, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_ImportReadGroupSetsRequest, rhs: Google_Genomics_V1_ImportReadGroupSetsRequest) -> Bool {
    if lhs.datasetID != rhs.datasetID {return false}
    if lhs.referenceSetID != rhs.referenceSetID {return false}
    if lhs.sourceUris != rhs.sourceUris {return false}
    if lhs.partitionStrategy != rhs.partitionStrategy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_ImportReadGroupSetsRequest.PartitionStrategy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PARTITION_STRATEGY_UNSPECIFIED"),
    1: .same(proto: "PER_FILE_PER_SAMPLE"),
    2: .same(proto: "MERGE_ALL"),
  ]
}

extension Google_Genomics_V1_ImportReadGroupSetsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ImportReadGroupSetsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "read_group_set_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.readGroupSetIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.readGroupSetIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.readGroupSetIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_ImportReadGroupSetsResponse, rhs: Google_Genomics_V1_ImportReadGroupSetsResponse) -> Bool {
    if lhs.readGroupSetIds != rhs.readGroupSetIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_ExportReadGroupSetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExportReadGroupSetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .standard(proto: "export_uri"),
    3: .standard(proto: "read_group_set_id"),
    4: .standard(proto: "reference_names"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.exportUri) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.readGroupSetID) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.referenceNames) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.exportUri.isEmpty {
      try visitor.visitSingularStringField(value: self.exportUri, fieldNumber: 2)
    }
    if !self.readGroupSetID.isEmpty {
      try visitor.visitSingularStringField(value: self.readGroupSetID, fieldNumber: 3)
    }
    if !self.referenceNames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.referenceNames, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_ExportReadGroupSetRequest, rhs: Google_Genomics_V1_ExportReadGroupSetRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.exportUri != rhs.exportUri {return false}
    if lhs.readGroupSetID != rhs.readGroupSetID {return false}
    if lhs.referenceNames != rhs.referenceNames {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_UpdateReadGroupSetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateReadGroupSetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "read_group_set_id"),
    2: .standard(proto: "read_group_set"),
    3: .standard(proto: "update_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.readGroupSetID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._readGroupSet) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.readGroupSetID.isEmpty {
      try visitor.visitSingularStringField(value: self.readGroupSetID, fieldNumber: 1)
    }
    if let v = self._readGroupSet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_UpdateReadGroupSetRequest, rhs: Google_Genomics_V1_UpdateReadGroupSetRequest) -> Bool {
    if lhs.readGroupSetID != rhs.readGroupSetID {return false}
    if lhs._readGroupSet != rhs._readGroupSet {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_DeleteReadGroupSetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteReadGroupSetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "read_group_set_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.readGroupSetID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.readGroupSetID.isEmpty {
      try visitor.visitSingularStringField(value: self.readGroupSetID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_DeleteReadGroupSetRequest, rhs: Google_Genomics_V1_DeleteReadGroupSetRequest) -> Bool {
    if lhs.readGroupSetID != rhs.readGroupSetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_GetReadGroupSetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetReadGroupSetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "read_group_set_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.readGroupSetID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.readGroupSetID.isEmpty {
      try visitor.visitSingularStringField(value: self.readGroupSetID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_GetReadGroupSetRequest, rhs: Google_Genomics_V1_GetReadGroupSetRequest) -> Bool {
    if lhs.readGroupSetID != rhs.readGroupSetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_ListCoverageBucketsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListCoverageBucketsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "read_group_set_id"),
    3: .standard(proto: "reference_name"),
    4: .same(proto: "start"),
    5: .same(proto: "end"),
    6: .standard(proto: "target_bucket_width"),
    7: .standard(proto: "page_token"),
    8: .standard(proto: "page_size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.readGroupSetID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.referenceName) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.start) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.end) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.targetBucketWidth) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.readGroupSetID.isEmpty {
      try visitor.visitSingularStringField(value: self.readGroupSetID, fieldNumber: 1)
    }
    if !self.referenceName.isEmpty {
      try visitor.visitSingularStringField(value: self.referenceName, fieldNumber: 3)
    }
    if self.start != 0 {
      try visitor.visitSingularInt64Field(value: self.start, fieldNumber: 4)
    }
    if self.end != 0 {
      try visitor.visitSingularInt64Field(value: self.end, fieldNumber: 5)
    }
    if self.targetBucketWidth != 0 {
      try visitor.visitSingularInt64Field(value: self.targetBucketWidth, fieldNumber: 6)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 7)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_ListCoverageBucketsRequest, rhs: Google_Genomics_V1_ListCoverageBucketsRequest) -> Bool {
    if lhs.readGroupSetID != rhs.readGroupSetID {return false}
    if lhs.referenceName != rhs.referenceName {return false}
    if lhs.start != rhs.start {return false}
    if lhs.end != rhs.end {return false}
    if lhs.targetBucketWidth != rhs.targetBucketWidth {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_CoverageBucket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CoverageBucket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "range"),
    2: .standard(proto: "mean_coverage"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._range) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.meanCoverage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._range {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.meanCoverage != 0 {
      try visitor.visitSingularFloatField(value: self.meanCoverage, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_CoverageBucket, rhs: Google_Genomics_V1_CoverageBucket) -> Bool {
    if lhs._range != rhs._range {return false}
    if lhs.meanCoverage != rhs.meanCoverage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_ListCoverageBucketsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListCoverageBucketsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bucket_width"),
    2: .standard(proto: "coverage_buckets"),
    3: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.bucketWidth) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.coverageBuckets) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.bucketWidth != 0 {
      try visitor.visitSingularInt64Field(value: self.bucketWidth, fieldNumber: 1)
    }
    if !self.coverageBuckets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.coverageBuckets, fieldNumber: 2)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_ListCoverageBucketsResponse, rhs: Google_Genomics_V1_ListCoverageBucketsResponse) -> Bool {
    if lhs.bucketWidth != rhs.bucketWidth {return false}
    if lhs.coverageBuckets != rhs.coverageBuckets {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_SearchReadsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchReadsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "read_group_set_ids"),
    5: .standard(proto: "read_group_ids"),
    7: .standard(proto: "reference_name"),
    8: .same(proto: "start"),
    9: .same(proto: "end"),
    3: .standard(proto: "page_token"),
    4: .standard(proto: "page_size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.readGroupSetIds) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.readGroupIds) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.referenceName) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.start) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.end) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.readGroupSetIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.readGroupSetIds, fieldNumber: 1)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 4)
    }
    if !self.readGroupIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.readGroupIds, fieldNumber: 5)
    }
    if !self.referenceName.isEmpty {
      try visitor.visitSingularStringField(value: self.referenceName, fieldNumber: 7)
    }
    if self.start != 0 {
      try visitor.visitSingularInt64Field(value: self.start, fieldNumber: 8)
    }
    if self.end != 0 {
      try visitor.visitSingularInt64Field(value: self.end, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_SearchReadsRequest, rhs: Google_Genomics_V1_SearchReadsRequest) -> Bool {
    if lhs.readGroupSetIds != rhs.readGroupSetIds {return false}
    if lhs.readGroupIds != rhs.readGroupIds {return false}
    if lhs.referenceName != rhs.referenceName {return false}
    if lhs.start != rhs.start {return false}
    if lhs.end != rhs.end {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_SearchReadsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchReadsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alignments"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.alignments) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.alignments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.alignments, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_SearchReadsResponse, rhs: Google_Genomics_V1_SearchReadsResponse) -> Bool {
    if lhs.alignments != rhs.alignments {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_StreamReadsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StreamReadsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .standard(proto: "read_group_set_id"),
    3: .standard(proto: "reference_name"),
    4: .same(proto: "start"),
    5: .same(proto: "end"),
    6: .same(proto: "shard"),
    7: .standard(proto: "total_shards"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.readGroupSetID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.referenceName) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.start) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.end) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.shard) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.totalShards) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.readGroupSetID.isEmpty {
      try visitor.visitSingularStringField(value: self.readGroupSetID, fieldNumber: 2)
    }
    if !self.referenceName.isEmpty {
      try visitor.visitSingularStringField(value: self.referenceName, fieldNumber: 3)
    }
    if self.start != 0 {
      try visitor.visitSingularInt64Field(value: self.start, fieldNumber: 4)
    }
    if self.end != 0 {
      try visitor.visitSingularInt64Field(value: self.end, fieldNumber: 5)
    }
    if self.shard != 0 {
      try visitor.visitSingularInt32Field(value: self.shard, fieldNumber: 6)
    }
    if self.totalShards != 0 {
      try visitor.visitSingularInt32Field(value: self.totalShards, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_StreamReadsRequest, rhs: Google_Genomics_V1_StreamReadsRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.readGroupSetID != rhs.readGroupSetID {return false}
    if lhs.referenceName != rhs.referenceName {return false}
    if lhs.start != rhs.start {return false}
    if lhs.end != rhs.end {return false}
    if lhs.shard != rhs.shard {return false}
    if lhs.totalShards != rhs.totalShards {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_StreamReadsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StreamReadsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alignments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.alignments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.alignments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.alignments, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_StreamReadsResponse, rhs: Google_Genomics_V1_StreamReadsResponse) -> Bool {
    if lhs.alignments != rhs.alignments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

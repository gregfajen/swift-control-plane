// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/genomics/v1/readgroup.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2016 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A read group is all the data that's processed the same way by the sequencer.
public struct Google_Genomics_V1_ReadGroup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The server-generated read group ID, unique for all read groups.
  /// Note: This is different than the @RG ID field in the SAM spec. For that
  /// value, see [name][google.genomics.v1.ReadGroup.name].
  public var id: String = String()

  /// The dataset to which this read group belongs.
  public var datasetID: String = String()

  /// The read group name. This corresponds to the @RG ID field in the SAM spec.
  public var name: String = String()

  /// A free-form text description of this read group.
  public var description_p: String = String()

  /// A client-supplied sample identifier for the reads in this read group.
  public var sampleID: String = String()

  /// The experiment used to generate this read group.
  public var experiment: Google_Genomics_V1_ReadGroup.Experiment {
    get {return _experiment ?? Google_Genomics_V1_ReadGroup.Experiment()}
    set {_experiment = newValue}
  }
  /// Returns true if `experiment` has been explicitly set.
  public var hasExperiment: Bool {return self._experiment != nil}
  /// Clears the value of `experiment`. Subsequent reads from it will return its default value.
  public mutating func clearExperiment() {self._experiment = nil}

  /// The predicted insert size of this read group. The insert size is the length
  /// the sequenced DNA fragment from end-to-end, not including the adapters.
  public var predictedInsertSize: Int32 = 0

  /// The programs used to generate this read group. Programs are always
  /// identical for all read groups within a read group set. For this reason,
  /// only the first read group in a returned set will have this field
  /// populated.
  public var programs: [Google_Genomics_V1_ReadGroup.Program] = []

  /// The reference set the reads in this read group are aligned to.
  public var referenceSetID: String = String()

  /// A map of additional read group information. This must be of the form
  /// map<string, string[]> (string key mapping to a list of string values).
  public var info: Dictionary<String,SwiftProtobuf.Google_Protobuf_ListValue> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Experiment {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A client-supplied library identifier; a library is a collection of DNA
    /// fragments which have been prepared for sequencing from a sample. This
    /// field is important for quality control as error or bias can be introduced
    /// during sample preparation.
    public var libraryID: String = String()

    /// The platform unit used as part of this experiment, for example
    /// flowcell-barcode.lane for Illumina or slide for SOLiD. Corresponds to the
    /// @RG PU field in the SAM spec.
    public var platformUnit: String = String()

    /// The sequencing center used as part of this experiment.
    public var sequencingCenter: String = String()

    /// The instrument model used as part of this experiment. This maps to
    /// sequencing technology in the SAM spec.
    public var instrumentModel: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Program {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The command line used to run this program.
    public var commandLine: String = String()

    /// The user specified locally unique ID of the program. Used along with
    /// `prevProgramId` to define an ordering between programs.
    public var id: String = String()

    /// The display name of the program. This is typically the colloquial name of
    /// the tool used, for example 'bwa' or 'picard'.
    public var name: String = String()

    /// The ID of the program run before this one.
    public var prevProgramID: String = String()

    /// The version of the program run.
    public var version: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _experiment: Google_Genomics_V1_ReadGroup.Experiment? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.genomics.v1"

extension Google_Genomics_V1_ReadGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReadGroup"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "dataset_id"),
    3: .same(proto: "name"),
    4: .same(proto: "description"),
    5: .standard(proto: "sample_id"),
    6: .same(proto: "experiment"),
    7: .standard(proto: "predicted_insert_size"),
    10: .same(proto: "programs"),
    11: .standard(proto: "reference_set_id"),
    12: .same(proto: "info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.datasetID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.sampleID) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._experiment) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.predictedInsertSize) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.programs) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.referenceSetID) }()
      case 12: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_ListValue>.self, value: &self.info) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.datasetID.isEmpty {
      try visitor.visitSingularStringField(value: self.datasetID, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 4)
    }
    if !self.sampleID.isEmpty {
      try visitor.visitSingularStringField(value: self.sampleID, fieldNumber: 5)
    }
    if let v = self._experiment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if self.predictedInsertSize != 0 {
      try visitor.visitSingularInt32Field(value: self.predictedInsertSize, fieldNumber: 7)
    }
    if !self.programs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.programs, fieldNumber: 10)
    }
    if !self.referenceSetID.isEmpty {
      try visitor.visitSingularStringField(value: self.referenceSetID, fieldNumber: 11)
    }
    if !self.info.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_ListValue>.self, value: self.info, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_ReadGroup, rhs: Google_Genomics_V1_ReadGroup) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.datasetID != rhs.datasetID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.sampleID != rhs.sampleID {return false}
    if lhs._experiment != rhs._experiment {return false}
    if lhs.predictedInsertSize != rhs.predictedInsertSize {return false}
    if lhs.programs != rhs.programs {return false}
    if lhs.referenceSetID != rhs.referenceSetID {return false}
    if lhs.info != rhs.info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_ReadGroup.Experiment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Genomics_V1_ReadGroup.protoMessageName + ".Experiment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "library_id"),
    2: .standard(proto: "platform_unit"),
    3: .standard(proto: "sequencing_center"),
    4: .standard(proto: "instrument_model"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.libraryID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.platformUnit) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.sequencingCenter) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.instrumentModel) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.libraryID.isEmpty {
      try visitor.visitSingularStringField(value: self.libraryID, fieldNumber: 1)
    }
    if !self.platformUnit.isEmpty {
      try visitor.visitSingularStringField(value: self.platformUnit, fieldNumber: 2)
    }
    if !self.sequencingCenter.isEmpty {
      try visitor.visitSingularStringField(value: self.sequencingCenter, fieldNumber: 3)
    }
    if !self.instrumentModel.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentModel, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_ReadGroup.Experiment, rhs: Google_Genomics_V1_ReadGroup.Experiment) -> Bool {
    if lhs.libraryID != rhs.libraryID {return false}
    if lhs.platformUnit != rhs.platformUnit {return false}
    if lhs.sequencingCenter != rhs.sequencingCenter {return false}
    if lhs.instrumentModel != rhs.instrumentModel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_ReadGroup.Program: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Genomics_V1_ReadGroup.protoMessageName + ".Program"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "command_line"),
    2: .same(proto: "id"),
    3: .same(proto: "name"),
    4: .standard(proto: "prev_program_id"),
    5: .same(proto: "version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.commandLine) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.prevProgramID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.version) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.commandLine.isEmpty {
      try visitor.visitSingularStringField(value: self.commandLine, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.prevProgramID.isEmpty {
      try visitor.visitSingularStringField(value: self.prevProgramID, fieldNumber: 4)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_ReadGroup.Program, rhs: Google_Genomics_V1_ReadGroup.Program) -> Bool {
    if lhs.commandLine != rhs.commandLine {return false}
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.prevProgramID != rhs.prevProgramID {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

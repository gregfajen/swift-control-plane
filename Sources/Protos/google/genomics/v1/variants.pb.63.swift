// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/genomics/v1/variants.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2016 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Operations to be performed during import on Variant info fields.
/// These operations are set for each info field in the info_merge_config
/// map of ImportVariantsRequest, which is plumbed down to the
/// MergeVariantRequests generated by the import job.
public enum Google_Genomics_V1_InfoMergeOperation: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unspecified // = 0

  /// By default, Variant info fields are persisted if the Variant doesn't
  /// already exist in the variantset.  If the Variant is equivalent to a
  /// Variant already in the variantset, the incoming Variant's info field
  /// is ignored in favor of that of the already persisted Variant.
  case ignoreNew // = 1

  /// This operation removes an info field from the incoming Variant
  /// and persists this info field in each of the incoming Variant's Calls.
  case moveToCalls // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .ignoreNew
    case 2: self = .moveToCalls
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .ignoreNew: return 1
    case .moveToCalls: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Genomics_V1_InfoMergeOperation: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Genomics_V1_InfoMergeOperation] = [
    .unspecified,
    .ignoreNew,
    .moveToCalls,
  ]
}

#endif  // swift(>=4.2)

/// Metadata describes a single piece of variant call metadata.
/// These data include a top level key and either a single value string (value)
/// or a list of key-value pairs (info.)
/// Value and info are mutually exclusive.
public struct Google_Genomics_V1_VariantSetMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The top-level key.
  public var key: String = String()

  /// The value field for simple metadata
  public var value: String = String()

  /// User-provided ID field, not enforced by this API.
  /// Two or more pieces of structured metadata with identical
  /// id and key fields are considered equivalent.
  public var id: String = String()

  /// The type of data. Possible types include: Integer, Float,
  /// Flag, Character, and String.
  public var type: Google_Genomics_V1_VariantSetMetadata.TypeEnum = .unspecified

  /// The number of values that can be included in a field described by this
  /// metadata.
  public var number: String = String()

  /// A textual description of this metadata.
  public var description_p: String = String()

  /// Remaining structured metadata key-value pairs. This must be of the form
  /// map<string, string[]> (string key mapping to a list of string values).
  public var info: Dictionary<String,SwiftProtobuf.Google_Protobuf_ListValue> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unspecified // = 0
    case integer // = 1
    case float // = 2
    case flag // = 3
    case character // = 4
    case string // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .integer
      case 2: self = .float
      case 3: self = .flag
      case 4: self = .character
      case 5: self = .string
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .integer: return 1
      case .float: return 2
      case .flag: return 3
      case .character: return 4
      case .string: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Genomics_V1_VariantSetMetadata.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Genomics_V1_VariantSetMetadata.TypeEnum] = [
    .unspecified,
    .integer,
    .float,
    .flag,
    .character,
    .string,
  ]
}

#endif  // swift(>=4.2)

/// A variant set is a collection of call sets and variants. It contains summary
/// statistics of those contents. A variant set belongs to a dataset.
///
/// For more genomics resource definitions, see [Fundamentals of Google
/// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
public struct Google_Genomics_V1_VariantSet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The dataset to which this variant set belongs.
  public var datasetID: String = String()

  /// The server-generated variant set ID, unique across all variant sets.
  public var id: String = String()

  /// The reference set to which the variant set is mapped. The reference set
  /// describes the alignment provenance of the variant set, while the
  /// `referenceBounds` describe the shape of the actual variant data. The
  /// reference set's reference names are a superset of those found in the
  /// `referenceBounds`.
  ///
  /// For example, given a variant set that is mapped to the GRCh38 reference set
  /// and contains a single variant on reference 'X', `referenceBounds` would
  /// contain only an entry for 'X', while the associated reference set
  /// enumerates all possible references: '1', '2', 'X', 'Y', 'MT', etc.
  public var referenceSetID: String = String()

  /// A list of all references used by the variants in a variant set
  /// with associated coordinate upper bounds for each one.
  public var referenceBounds: [Google_Genomics_V1_ReferenceBound] = []

  /// The metadata associated with this variant set.
  public var metadata: [Google_Genomics_V1_VariantSetMetadata] = []

  /// User-specified, mutable name.
  public var name: String = String()

  /// A textual description of this variant set.
  public var description_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A variant represents a change in DNA sequence relative to a reference
/// sequence. For example, a variant could represent a SNP or an insertion.
/// Variants belong to a variant set.
///
/// For more genomics resource definitions, see [Fundamentals of Google
/// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
///
/// Each of the calls on a variant represent a determination of genotype with
/// respect to that variant. For example, a call might assign probability of 0.32
/// to the occurrence of a SNP named rs1234 in a sample named NA12345. A call
/// belongs to a call set, which contains related calls typically from one
/// sample.
public struct Google_Genomics_V1_Variant {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the variant set this variant belongs to.
  public var variantSetID: String = String()

  /// The server-generated variant ID, unique across all variants.
  public var id: String = String()

  /// Names for the variant, for example a RefSNP ID.
  public var names: [String] = []

  /// The date this variant was created, in milliseconds from the epoch.
  public var created: Int64 = 0

  /// The reference on which this variant occurs.
  /// (such as `chr20` or `X`)
  public var referenceName: String = String()

  /// The position at which this variant occurs (0-based).
  /// This corresponds to the first base of the string of reference bases.
  public var start: Int64 = 0

  /// The end position (0-based) of this variant. This corresponds to the first
  /// base after the last base in the reference allele. So, the length of
  /// the reference allele is (end - start). This is useful for variants
  /// that don't explicitly give alternate bases, for example large deletions.
  public var end: Int64 = 0

  /// The reference bases for this variant. They start at the given
  /// position.
  public var referenceBases: String = String()

  /// The bases that appear instead of the reference bases.
  public var alternateBases: [String] = []

  /// A measure of how likely this variant is to be real.
  /// A higher value is better.
  public var quality: Double = 0

  /// A list of filters (normally quality filters) this variant has failed.
  /// `PASS` indicates this variant has passed all filters.
  public var filter: [String] = []

  /// A map of additional variant information. This must be of the form
  /// map<string, string[]> (string key mapping to a list of string values).
  public var info: Dictionary<String,SwiftProtobuf.Google_Protobuf_ListValue> = [:]

  /// The variant calls for this particular variant. Each one represents the
  /// determination of genotype with respect to this variant.
  public var calls: [Google_Genomics_V1_VariantCall] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A call represents the determination of genotype with respect to a particular
/// variant. It may include associated information such as quality and phasing.
/// For example, a call might assign a probability of 0.32 to the occurrence of
/// a SNP named rs1234 in a call set with the name NA12345.
public struct Google_Genomics_V1_VariantCall {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the call set this variant call belongs to.
  public var callSetID: String = String()

  /// The name of the call set this variant call belongs to.
  public var callSetName: String = String()

  /// The genotype of this variant call. Each value represents either the value
  /// of the `referenceBases` field or a 1-based index into
  /// `alternateBases`. If a variant had a `referenceBases`
  /// value of `T` and an `alternateBases`
  /// value of `["A", "C"]`, and the `genotype` was
  /// `[2, 1]`, that would mean the call
  /// represented the heterozygous value `CA` for this variant.
  /// If the `genotype` was instead `[0, 1]`, the
  /// represented value would be `TA`. Ordering of the
  /// genotype values is important if the `phaseset` is present.
  /// If a genotype is not called (that is, a `.` is present in the
  /// GT string) -1 is returned.
  public var genotype: [Int32] = []

  /// If this field is present, this variant call's genotype ordering implies
  /// the phase of the bases and is consistent with any other variant calls in
  /// the same reference sequence which have the same phaseset value.
  /// When importing data from VCF, if the genotype data was phased but no
  /// phase set was specified this field will be set to `*`.
  public var phaseset: String = String()

  /// The genotype likelihoods for this variant call. Each array entry
  /// represents how likely a specific genotype is for this call. The value
  /// ordering is defined by the GL tag in the VCF spec.
  /// If Phred-scaled genotype likelihood scores (PL) are available and
  /// log10(P) genotype likelihood scores (GL) are not, PL scores are converted
  /// to GL scores.  If both are available, PL scores are stored in `info`.
  public var genotypeLikelihood: [Double] = []

  /// A map of additional variant call information. This must be of the form
  /// map<string, string[]> (string key mapping to a list of string values).
  public var info: Dictionary<String,SwiftProtobuf.Google_Protobuf_ListValue> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A call set is a collection of variant calls, typically for one sample. It
/// belongs to a variant set.
///
/// For more genomics resource definitions, see [Fundamentals of Google
/// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
public struct Google_Genomics_V1_CallSet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The server-generated call set ID, unique across all call sets.
  public var id: String = String()

  /// The call set name.
  public var name: String = String()

  /// The sample ID this call set corresponds to.
  public var sampleID: String = String()

  /// The IDs of the variant sets this call set belongs to. This field must
  /// have exactly length one, as a call set belongs to a single variant set.
  /// This field is repeated for compatibility with the
  /// [GA4GH 0.5.1
  /// API](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/variants.avdl#L76).
  public var variantSetIds: [String] = []

  /// The date this call set was created in milliseconds from the epoch.
  public var created: Int64 = 0

  /// A map of additional call set information. This must be of the form
  /// map<string, string[]> (string key mapping to a list of string values).
  public var info: Dictionary<String,SwiftProtobuf.Google_Protobuf_ListValue> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ReferenceBound records an upper bound for the starting coordinate of
/// variants in a particular reference.
public struct Google_Genomics_V1_ReferenceBound {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the reference associated with this reference bound.
  public var referenceName: String = String()

  /// An upper bound (inclusive) on the starting coordinate of any
  /// variant in the reference sequence.
  public var upperBound: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The variant data import request.
public struct Google_Genomics_V1_ImportVariantsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The variant set to which variant data should be imported.
  public var variantSetID: String = String()

  /// A list of URIs referencing variant files in Google Cloud Storage. URIs can
  /// include wildcards [as described
  /// here](https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames).
  /// Note that recursive wildcards ('**') are not supported.
  public var sourceUris: [String] = []

  /// The format of the variant data being imported. If unspecified, defaults to
  /// to `VCF`.
  public var format: Google_Genomics_V1_ImportVariantsRequest.Format = .unspecified

  /// Convert reference names to the canonical representation.
  /// hg19 haploytypes (those reference names containing "_hap")
  /// are not modified in any way.
  /// All other reference names are modified according to the following rules:
  /// The reference name is capitalized.
  /// The "chr" prefix is dropped for all autosomes and sex chromsomes.
  /// For example "chr17" becomes "17" and "chrX" becomes "X".
  /// All mitochondrial chromosomes ("chrM", "chrMT", etc) become "MT".
  public var normalizeReferenceNames: Bool = false

  /// A mapping between info field keys and the InfoMergeOperations to
  /// be performed on them. This is plumbed down to the MergeVariantRequests
  /// generated by the resulting import job.
  public var infoMergeConfig: Dictionary<String,Google_Genomics_V1_InfoMergeOperation> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Format: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unspecified // = 0

    /// VCF (Variant Call Format). The VCF files may be gzip compressed. gVCF is
    /// also supported.
    case vcf // = 1

    /// Complete Genomics masterVarBeta format. The masterVarBeta files may
    /// be bzip2 compressed.
    case completeGenomics // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .vcf
      case 2: self = .completeGenomics
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .vcf: return 1
      case .completeGenomics: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Genomics_V1_ImportVariantsRequest.Format: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Genomics_V1_ImportVariantsRequest.Format] = [
    .unspecified,
    .vcf,
    .completeGenomics,
  ]
}

#endif  // swift(>=4.2)

/// The variant data import response.
public struct Google_Genomics_V1_ImportVariantsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// IDs of the call sets created during the import.
  public var callSetIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The CreateVariantSet request
public struct Google_Genomics_V1_CreateVariantSetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The variant set to be created. Must have a valid `datasetId`.
  public var variantSet: Google_Genomics_V1_VariantSet {
    get {return _variantSet ?? Google_Genomics_V1_VariantSet()}
    set {_variantSet = newValue}
  }
  /// Returns true if `variantSet` has been explicitly set.
  public var hasVariantSet: Bool {return self._variantSet != nil}
  /// Clears the value of `variantSet`. Subsequent reads from it will return its default value.
  public mutating func clearVariantSet() {self._variantSet = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _variantSet: Google_Genomics_V1_VariantSet? = nil
}

/// The variant data export request.
public struct Google_Genomics_V1_ExportVariantSetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The ID of the variant set that contains variant data which
  /// should be exported. The caller must have READ access to this variant set.
  public var variantSetID: String = String()

  /// If provided, only variant call information from the specified call sets
  /// will be exported. By default all variant calls are exported.
  public var callSetIds: [String] = []

  /// Required. The Google Cloud project ID that owns the destination
  /// BigQuery dataset. The caller must have WRITE access to this project.  This
  /// project will also own the resulting export job.
  public var projectID: String = String()

  /// The format for the exported data.
  public var format: Google_Genomics_V1_ExportVariantSetRequest.Format = .unspecified

  /// Required. The BigQuery dataset to export data to. This dataset must already
  /// exist. Note that this is distinct from the Genomics concept of "dataset".
  public var bigqueryDataset: String = String()

  /// Required. The BigQuery table to export data to.
  /// If the table doesn't exist, it will be created. If it already exists, it
  /// will be overwritten.
  public var bigqueryTable: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Format: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unspecified // = 0

    /// Export the data to Google BigQuery.
    case bigquery // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .bigquery
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .bigquery: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Genomics_V1_ExportVariantSetRequest.Format: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Genomics_V1_ExportVariantSetRequest.Format] = [
    .unspecified,
    .bigquery,
  ]
}

#endif  // swift(>=4.2)

/// The variant set request.
public struct Google_Genomics_V1_GetVariantSetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The ID of the variant set.
  public var variantSetID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The search variant sets request.
public struct Google_Genomics_V1_SearchVariantSetsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Exactly one dataset ID must be provided here. Only variant sets which
  /// belong to this dataset will be returned.
  public var datasetIds: [String] = []

  /// The continuation token, which is used to page through large result sets.
  /// To get the next page of results, set this parameter to the value of
  /// `nextPageToken` from the previous response.
  public var pageToken: String = String()

  /// The maximum number of results to return in a single page. If unspecified,
  /// defaults to 1024.
  public var pageSize: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The search variant sets response.
public struct Google_Genomics_V1_SearchVariantSetsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The variant sets belonging to the requested dataset.
  public var variantSets: [Google_Genomics_V1_VariantSet] = []

  /// The continuation token, which is used to page through large result sets.
  /// Provide this value in a subsequent request to return the next page of
  /// results. This field will be empty if there aren't any additional results.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The delete variant set request.
public struct Google_Genomics_V1_DeleteVariantSetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the variant set to be deleted.
  public var variantSetID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Google_Genomics_V1_UpdateVariantSetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the variant to be updated (must already exist).
  public var variantSetID: String = String()

  /// The new variant data. Only the variant_set.metadata will be considered
  /// for update.
  public var variantSet: Google_Genomics_V1_VariantSet {
    get {return _variantSet ?? Google_Genomics_V1_VariantSet()}
    set {_variantSet = newValue}
  }
  /// Returns true if `variantSet` has been explicitly set.
  public var hasVariantSet: Bool {return self._variantSet != nil}
  /// Clears the value of `variantSet`. Subsequent reads from it will return its default value.
  public mutating func clearVariantSet() {self._variantSet = nil}

  /// An optional mask specifying which fields to update. Supported fields:
  ///
  /// * [metadata][google.genomics.v1.VariantSet.metadata].
  /// * [name][google.genomics.v1.VariantSet.name].
  /// * [description][google.genomics.v1.VariantSet.description].
  ///
  /// Leaving `updateMask` unset is equivalent to specifying all mutable
  /// fields.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _variantSet: Google_Genomics_V1_VariantSet? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// The variant search request.
public struct Google_Genomics_V1_SearchVariantsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// At most one variant set ID must be provided. Only variants from this
  /// variant set will be returned. If omitted, a call set id must be included in
  /// the request.
  public var variantSetIds: [String] = []

  /// Only return variants which have exactly this name.
  public var variantName: String = String()

  /// Only return variant calls which belong to call sets with these ids.
  /// Leaving this blank returns all variant calls. If a variant has no
  /// calls belonging to any of these call sets, it won't be returned at all.
  public var callSetIds: [String] = []

  /// Required. Only return variants in this reference sequence.
  public var referenceName: String = String()

  /// The beginning of the window (0-based, inclusive) for which
  /// overlapping variants should be returned. If unspecified, defaults to 0.
  public var start: Int64 = 0

  /// The end of the window, 0-based exclusive. If unspecified or 0, defaults to
  /// the length of the reference.
  public var end: Int64 = 0

  /// The continuation token, which is used to page through large result sets.
  /// To get the next page of results, set this parameter to the value of
  /// `nextPageToken` from the previous response.
  public var pageToken: String = String()

  /// The maximum number of variants to return in a single page. If unspecified,
  /// defaults to 5000. The maximum value is 10000.
  public var pageSize: Int32 = 0

  /// The maximum number of calls to return in a single page. Note that this
  /// limit may be exceeded in the event that a matching variant contains more
  /// calls than the requested maximum. If unspecified, defaults to 5000. The
  /// maximum value is 10000.
  public var maxCalls: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The variant search response.
public struct Google_Genomics_V1_SearchVariantsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of matching Variants.
  public var variants: [Google_Genomics_V1_Variant] = []

  /// The continuation token, which is used to page through large result sets.
  /// Provide this value in a subsequent request to return the next page of
  /// results. This field will be empty if there aren't any additional results.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Google_Genomics_V1_CreateVariantRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The variant to be created.
  public var variant: Google_Genomics_V1_Variant {
    get {return _variant ?? Google_Genomics_V1_Variant()}
    set {_variant = newValue}
  }
  /// Returns true if `variant` has been explicitly set.
  public var hasVariant: Bool {return self._variant != nil}
  /// Clears the value of `variant`. Subsequent reads from it will return its default value.
  public mutating func clearVariant() {self._variant = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _variant: Google_Genomics_V1_Variant? = nil
}

public struct Google_Genomics_V1_UpdateVariantRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the variant to be updated.
  public var variantID: String = String()

  /// The new variant data.
  public var variant: Google_Genomics_V1_Variant {
    get {return _variant ?? Google_Genomics_V1_Variant()}
    set {_variant = newValue}
  }
  /// Returns true if `variant` has been explicitly set.
  public var hasVariant: Bool {return self._variant != nil}
  /// Clears the value of `variant`. Subsequent reads from it will return its default value.
  public mutating func clearVariant() {self._variant = nil}

  /// An optional mask specifying which fields to update. At this time, mutable
  /// fields are [names][google.genomics.v1.Variant.names] and
  /// [info][google.genomics.v1.Variant.info]. Acceptable values are "names" and
  /// "info". If unspecified, all mutable fields will be updated.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _variant: Google_Genomics_V1_Variant? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

public struct Google_Genomics_V1_DeleteVariantRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the variant to be deleted.
  public var variantID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Google_Genomics_V1_GetVariantRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the variant.
  public var variantID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Google_Genomics_V1_MergeVariantsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The destination variant set.
  public var variantSetID: String = String()

  /// The variants to be merged with existing variants.
  public var variants: [Google_Genomics_V1_Variant] = []

  /// A mapping between info field keys and the InfoMergeOperations to
  /// be performed on them.
  public var infoMergeConfig: Dictionary<String,Google_Genomics_V1_InfoMergeOperation> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The call set search request.
public struct Google_Genomics_V1_SearchCallSetsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Restrict the query to call sets within the given variant sets. At least one
  /// ID must be provided.
  public var variantSetIds: [String] = []

  /// Only return call sets for which a substring of the name matches this
  /// string.
  public var name: String = String()

  /// The continuation token, which is used to page through large result sets.
  /// To get the next page of results, set this parameter to the value of
  /// `nextPageToken` from the previous response.
  public var pageToken: String = String()

  /// The maximum number of results to return in a single page. If unspecified,
  /// defaults to 1024.
  public var pageSize: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The call set search response.
public struct Google_Genomics_V1_SearchCallSetsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of matching call sets.
  public var callSets: [Google_Genomics_V1_CallSet] = []

  /// The continuation token, which is used to page through large result sets.
  /// Provide this value in a subsequent request to return the next page of
  /// results. This field will be empty if there aren't any additional results.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Google_Genomics_V1_CreateCallSetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The call set to be created.
  public var callSet: Google_Genomics_V1_CallSet {
    get {return _callSet ?? Google_Genomics_V1_CallSet()}
    set {_callSet = newValue}
  }
  /// Returns true if `callSet` has been explicitly set.
  public var hasCallSet: Bool {return self._callSet != nil}
  /// Clears the value of `callSet`. Subsequent reads from it will return its default value.
  public mutating func clearCallSet() {self._callSet = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _callSet: Google_Genomics_V1_CallSet? = nil
}

public struct Google_Genomics_V1_UpdateCallSetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the call set to be updated.
  public var callSetID: String = String()

  /// The new call set data.
  public var callSet: Google_Genomics_V1_CallSet {
    get {return _callSet ?? Google_Genomics_V1_CallSet()}
    set {_callSet = newValue}
  }
  /// Returns true if `callSet` has been explicitly set.
  public var hasCallSet: Bool {return self._callSet != nil}
  /// Clears the value of `callSet`. Subsequent reads from it will return its default value.
  public mutating func clearCallSet() {self._callSet = nil}

  /// An optional mask specifying which fields to update. At this time, the only
  /// mutable field is [name][google.genomics.v1.CallSet.name]. The only
  /// acceptable value is "name". If unspecified, all mutable fields will be
  /// updated.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _callSet: Google_Genomics_V1_CallSet? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

public struct Google_Genomics_V1_DeleteCallSetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the call set to be deleted.
  public var callSetID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Google_Genomics_V1_GetCallSetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the call set.
  public var callSetID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The stream variants request.
public struct Google_Genomics_V1_StreamVariantsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Google Cloud project ID which will be billed
  /// for this access. The caller must have WRITE access to this project.
  /// Required.
  public var projectID: String = String()

  /// The variant set ID from which to stream variants.
  public var variantSetID: String = String()

  /// Only return variant calls which belong to call sets with these IDs.
  /// Leaving this blank returns all variant calls.
  public var callSetIds: [String] = []

  /// Required. Only return variants in this reference sequence.
  public var referenceName: String = String()

  /// The beginning of the window (0-based, inclusive) for which
  /// overlapping variants should be returned.
  public var start: Int64 = 0

  /// The end of the window (0-based, exclusive) for which overlapping
  /// variants should be returned.
  public var end: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Google_Genomics_V1_StreamVariantsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var variants: [Google_Genomics_V1_Variant] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.genomics.v1"

extension Google_Genomics_V1_InfoMergeOperation: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INFO_MERGE_OPERATION_UNSPECIFIED"),
    1: .same(proto: "IGNORE_NEW"),
    2: .same(proto: "MOVE_TO_CALLS"),
  ]
}

extension Google_Genomics_V1_VariantSetMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VariantSetMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
    4: .same(proto: "id"),
    5: .same(proto: "type"),
    8: .same(proto: "number"),
    7: .same(proto: "description"),
    3: .same(proto: "info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_ListValue>.self, value: &self.info) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.number) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    if !self.info.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_ListValue>.self, value: self.info, fieldNumber: 3)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 4)
    }
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 5)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 7)
    }
    if !self.number.isEmpty {
      try visitor.visitSingularStringField(value: self.number, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_VariantSetMetadata, rhs: Google_Genomics_V1_VariantSetMetadata) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.id != rhs.id {return false}
    if lhs.type != rhs.type {return false}
    if lhs.number != rhs.number {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.info != rhs.info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_VariantSetMetadata.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNSPECIFIED"),
    1: .same(proto: "INTEGER"),
    2: .same(proto: "FLOAT"),
    3: .same(proto: "FLAG"),
    4: .same(proto: "CHARACTER"),
    5: .same(proto: "STRING"),
  ]
}

extension Google_Genomics_V1_VariantSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VariantSet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dataset_id"),
    2: .same(proto: "id"),
    6: .standard(proto: "reference_set_id"),
    5: .standard(proto: "reference_bounds"),
    4: .same(proto: "metadata"),
    7: .same(proto: "name"),
    8: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.datasetID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.metadata) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.referenceBounds) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.referenceSetID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.datasetID.isEmpty {
      try visitor.visitSingularStringField(value: self.datasetID, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    if !self.metadata.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.metadata, fieldNumber: 4)
    }
    if !self.referenceBounds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.referenceBounds, fieldNumber: 5)
    }
    if !self.referenceSetID.isEmpty {
      try visitor.visitSingularStringField(value: self.referenceSetID, fieldNumber: 6)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 7)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_VariantSet, rhs: Google_Genomics_V1_VariantSet) -> Bool {
    if lhs.datasetID != rhs.datasetID {return false}
    if lhs.id != rhs.id {return false}
    if lhs.referenceSetID != rhs.referenceSetID {return false}
    if lhs.referenceBounds != rhs.referenceBounds {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_Variant: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Variant"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    15: .standard(proto: "variant_set_id"),
    2: .same(proto: "id"),
    3: .same(proto: "names"),
    12: .same(proto: "created"),
    14: .standard(proto: "reference_name"),
    16: .same(proto: "start"),
    13: .same(proto: "end"),
    6: .standard(proto: "reference_bases"),
    7: .standard(proto: "alternate_bases"),
    8: .same(proto: "quality"),
    9: .same(proto: "filter"),
    10: .same(proto: "info"),
    11: .same(proto: "calls"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.names) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.referenceBases) }()
      case 7: try { try decoder.decodeRepeatedStringField(value: &self.alternateBases) }()
      case 8: try { try decoder.decodeSingularDoubleField(value: &self.quality) }()
      case 9: try { try decoder.decodeRepeatedStringField(value: &self.filter) }()
      case 10: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_ListValue>.self, value: &self.info) }()
      case 11: try { try decoder.decodeRepeatedMessageField(value: &self.calls) }()
      case 12: try { try decoder.decodeSingularInt64Field(value: &self.created) }()
      case 13: try { try decoder.decodeSingularInt64Field(value: &self.end) }()
      case 14: try { try decoder.decodeSingularStringField(value: &self.referenceName) }()
      case 15: try { try decoder.decodeSingularStringField(value: &self.variantSetID) }()
      case 16: try { try decoder.decodeSingularInt64Field(value: &self.start) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    if !self.names.isEmpty {
      try visitor.visitRepeatedStringField(value: self.names, fieldNumber: 3)
    }
    if !self.referenceBases.isEmpty {
      try visitor.visitSingularStringField(value: self.referenceBases, fieldNumber: 6)
    }
    if !self.alternateBases.isEmpty {
      try visitor.visitRepeatedStringField(value: self.alternateBases, fieldNumber: 7)
    }
    if self.quality != 0 {
      try visitor.visitSingularDoubleField(value: self.quality, fieldNumber: 8)
    }
    if !self.filter.isEmpty {
      try visitor.visitRepeatedStringField(value: self.filter, fieldNumber: 9)
    }
    if !self.info.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_ListValue>.self, value: self.info, fieldNumber: 10)
    }
    if !self.calls.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.calls, fieldNumber: 11)
    }
    if self.created != 0 {
      try visitor.visitSingularInt64Field(value: self.created, fieldNumber: 12)
    }
    if self.end != 0 {
      try visitor.visitSingularInt64Field(value: self.end, fieldNumber: 13)
    }
    if !self.referenceName.isEmpty {
      try visitor.visitSingularStringField(value: self.referenceName, fieldNumber: 14)
    }
    if !self.variantSetID.isEmpty {
      try visitor.visitSingularStringField(value: self.variantSetID, fieldNumber: 15)
    }
    if self.start != 0 {
      try visitor.visitSingularInt64Field(value: self.start, fieldNumber: 16)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_Variant, rhs: Google_Genomics_V1_Variant) -> Bool {
    if lhs.variantSetID != rhs.variantSetID {return false}
    if lhs.id != rhs.id {return false}
    if lhs.names != rhs.names {return false}
    if lhs.created != rhs.created {return false}
    if lhs.referenceName != rhs.referenceName {return false}
    if lhs.start != rhs.start {return false}
    if lhs.end != rhs.end {return false}
    if lhs.referenceBases != rhs.referenceBases {return false}
    if lhs.alternateBases != rhs.alternateBases {return false}
    if lhs.quality != rhs.quality {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.info != rhs.info {return false}
    if lhs.calls != rhs.calls {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_VariantCall: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VariantCall"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    8: .standard(proto: "call_set_id"),
    9: .standard(proto: "call_set_name"),
    7: .same(proto: "genotype"),
    5: .same(proto: "phaseset"),
    6: .standard(proto: "genotype_likelihood"),
    2: .same(proto: "info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_ListValue>.self, value: &self.info) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.phaseset) }()
      case 6: try { try decoder.decodeRepeatedDoubleField(value: &self.genotypeLikelihood) }()
      case 7: try { try decoder.decodeRepeatedInt32Field(value: &self.genotype) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.callSetID) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.callSetName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.info.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_ListValue>.self, value: self.info, fieldNumber: 2)
    }
    if !self.phaseset.isEmpty {
      try visitor.visitSingularStringField(value: self.phaseset, fieldNumber: 5)
    }
    if !self.genotypeLikelihood.isEmpty {
      try visitor.visitPackedDoubleField(value: self.genotypeLikelihood, fieldNumber: 6)
    }
    if !self.genotype.isEmpty {
      try visitor.visitPackedInt32Field(value: self.genotype, fieldNumber: 7)
    }
    if !self.callSetID.isEmpty {
      try visitor.visitSingularStringField(value: self.callSetID, fieldNumber: 8)
    }
    if !self.callSetName.isEmpty {
      try visitor.visitSingularStringField(value: self.callSetName, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_VariantCall, rhs: Google_Genomics_V1_VariantCall) -> Bool {
    if lhs.callSetID != rhs.callSetID {return false}
    if lhs.callSetName != rhs.callSetName {return false}
    if lhs.genotype != rhs.genotype {return false}
    if lhs.phaseset != rhs.phaseset {return false}
    if lhs.genotypeLikelihood != rhs.genotypeLikelihood {return false}
    if lhs.info != rhs.info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_CallSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CallSet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    7: .standard(proto: "sample_id"),
    6: .standard(proto: "variant_set_ids"),
    5: .same(proto: "created"),
    4: .same(proto: "info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_ListValue>.self, value: &self.info) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.created) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.variantSetIds) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.sampleID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.info.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_ListValue>.self, value: self.info, fieldNumber: 4)
    }
    if self.created != 0 {
      try visitor.visitSingularInt64Field(value: self.created, fieldNumber: 5)
    }
    if !self.variantSetIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.variantSetIds, fieldNumber: 6)
    }
    if !self.sampleID.isEmpty {
      try visitor.visitSingularStringField(value: self.sampleID, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_CallSet, rhs: Google_Genomics_V1_CallSet) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.sampleID != rhs.sampleID {return false}
    if lhs.variantSetIds != rhs.variantSetIds {return false}
    if lhs.created != rhs.created {return false}
    if lhs.info != rhs.info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_ReferenceBound: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReferenceBound"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "reference_name"),
    2: .standard(proto: "upper_bound"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.referenceName) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.upperBound) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.referenceName.isEmpty {
      try visitor.visitSingularStringField(value: self.referenceName, fieldNumber: 1)
    }
    if self.upperBound != 0 {
      try visitor.visitSingularInt64Field(value: self.upperBound, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_ReferenceBound, rhs: Google_Genomics_V1_ReferenceBound) -> Bool {
    if lhs.referenceName != rhs.referenceName {return false}
    if lhs.upperBound != rhs.upperBound {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_ImportVariantsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ImportVariantsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "variant_set_id"),
    2: .standard(proto: "source_uris"),
    3: .same(proto: "format"),
    5: .standard(proto: "normalize_reference_names"),
    6: .standard(proto: "info_merge_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.variantSetID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.sourceUris) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.format) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.normalizeReferenceNames) }()
      case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufEnumMap<SwiftProtobuf.ProtobufString,Google_Genomics_V1_InfoMergeOperation>.self, value: &self.infoMergeConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.variantSetID.isEmpty {
      try visitor.visitSingularStringField(value: self.variantSetID, fieldNumber: 1)
    }
    if !self.sourceUris.isEmpty {
      try visitor.visitRepeatedStringField(value: self.sourceUris, fieldNumber: 2)
    }
    if self.format != .unspecified {
      try visitor.visitSingularEnumField(value: self.format, fieldNumber: 3)
    }
    if self.normalizeReferenceNames != false {
      try visitor.visitSingularBoolField(value: self.normalizeReferenceNames, fieldNumber: 5)
    }
    if !self.infoMergeConfig.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufEnumMap<SwiftProtobuf.ProtobufString,Google_Genomics_V1_InfoMergeOperation>.self, value: self.infoMergeConfig, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_ImportVariantsRequest, rhs: Google_Genomics_V1_ImportVariantsRequest) -> Bool {
    if lhs.variantSetID != rhs.variantSetID {return false}
    if lhs.sourceUris != rhs.sourceUris {return false}
    if lhs.format != rhs.format {return false}
    if lhs.normalizeReferenceNames != rhs.normalizeReferenceNames {return false}
    if lhs.infoMergeConfig != rhs.infoMergeConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_ImportVariantsRequest.Format: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FORMAT_UNSPECIFIED"),
    1: .same(proto: "FORMAT_VCF"),
    2: .same(proto: "FORMAT_COMPLETE_GENOMICS"),
  ]
}

extension Google_Genomics_V1_ImportVariantsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ImportVariantsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_set_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.callSetIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.callSetIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.callSetIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_ImportVariantsResponse, rhs: Google_Genomics_V1_ImportVariantsResponse) -> Bool {
    if lhs.callSetIds != rhs.callSetIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_CreateVariantSetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateVariantSetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "variant_set"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._variantSet) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._variantSet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_CreateVariantSetRequest, rhs: Google_Genomics_V1_CreateVariantSetRequest) -> Bool {
    if lhs._variantSet != rhs._variantSet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_ExportVariantSetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExportVariantSetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "variant_set_id"),
    2: .standard(proto: "call_set_ids"),
    3: .standard(proto: "project_id"),
    4: .same(proto: "format"),
    5: .standard(proto: "bigquery_dataset"),
    6: .standard(proto: "bigquery_table"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.variantSetID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.callSetIds) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.format) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.bigqueryDataset) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.bigqueryTable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.variantSetID.isEmpty {
      try visitor.visitSingularStringField(value: self.variantSetID, fieldNumber: 1)
    }
    if !self.callSetIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.callSetIds, fieldNumber: 2)
    }
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 3)
    }
    if self.format != .unspecified {
      try visitor.visitSingularEnumField(value: self.format, fieldNumber: 4)
    }
    if !self.bigqueryDataset.isEmpty {
      try visitor.visitSingularStringField(value: self.bigqueryDataset, fieldNumber: 5)
    }
    if !self.bigqueryTable.isEmpty {
      try visitor.visitSingularStringField(value: self.bigqueryTable, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_ExportVariantSetRequest, rhs: Google_Genomics_V1_ExportVariantSetRequest) -> Bool {
    if lhs.variantSetID != rhs.variantSetID {return false}
    if lhs.callSetIds != rhs.callSetIds {return false}
    if lhs.projectID != rhs.projectID {return false}
    if lhs.format != rhs.format {return false}
    if lhs.bigqueryDataset != rhs.bigqueryDataset {return false}
    if lhs.bigqueryTable != rhs.bigqueryTable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_ExportVariantSetRequest.Format: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FORMAT_UNSPECIFIED"),
    1: .same(proto: "FORMAT_BIGQUERY"),
  ]
}

extension Google_Genomics_V1_GetVariantSetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetVariantSetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "variant_set_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.variantSetID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.variantSetID.isEmpty {
      try visitor.visitSingularStringField(value: self.variantSetID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_GetVariantSetRequest, rhs: Google_Genomics_V1_GetVariantSetRequest) -> Bool {
    if lhs.variantSetID != rhs.variantSetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_SearchVariantSetsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchVariantSetsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dataset_ids"),
    2: .standard(proto: "page_token"),
    3: .standard(proto: "page_size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.datasetIds) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.datasetIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.datasetIds, fieldNumber: 1)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_SearchVariantSetsRequest, rhs: Google_Genomics_V1_SearchVariantSetsRequest) -> Bool {
    if lhs.datasetIds != rhs.datasetIds {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_SearchVariantSetsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchVariantSetsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "variant_sets"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.variantSets) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.variantSets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.variantSets, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_SearchVariantSetsResponse, rhs: Google_Genomics_V1_SearchVariantSetsResponse) -> Bool {
    if lhs.variantSets != rhs.variantSets {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_DeleteVariantSetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteVariantSetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "variant_set_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.variantSetID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.variantSetID.isEmpty {
      try visitor.visitSingularStringField(value: self.variantSetID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_DeleteVariantSetRequest, rhs: Google_Genomics_V1_DeleteVariantSetRequest) -> Bool {
    if lhs.variantSetID != rhs.variantSetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_UpdateVariantSetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateVariantSetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "variant_set_id"),
    2: .standard(proto: "variant_set"),
    5: .standard(proto: "update_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.variantSetID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._variantSet) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.variantSetID.isEmpty {
      try visitor.visitSingularStringField(value: self.variantSetID, fieldNumber: 1)
    }
    if let v = self._variantSet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_UpdateVariantSetRequest, rhs: Google_Genomics_V1_UpdateVariantSetRequest) -> Bool {
    if lhs.variantSetID != rhs.variantSetID {return false}
    if lhs._variantSet != rhs._variantSet {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_SearchVariantsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchVariantsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "variant_set_ids"),
    2: .standard(proto: "variant_name"),
    3: .standard(proto: "call_set_ids"),
    4: .standard(proto: "reference_name"),
    5: .same(proto: "start"),
    6: .same(proto: "end"),
    7: .standard(proto: "page_token"),
    8: .standard(proto: "page_size"),
    9: .standard(proto: "max_calls"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.variantSetIds) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.variantName) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.callSetIds) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.referenceName) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.start) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.end) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.maxCalls) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.variantSetIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.variantSetIds, fieldNumber: 1)
    }
    if !self.variantName.isEmpty {
      try visitor.visitSingularStringField(value: self.variantName, fieldNumber: 2)
    }
    if !self.callSetIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.callSetIds, fieldNumber: 3)
    }
    if !self.referenceName.isEmpty {
      try visitor.visitSingularStringField(value: self.referenceName, fieldNumber: 4)
    }
    if self.start != 0 {
      try visitor.visitSingularInt64Field(value: self.start, fieldNumber: 5)
    }
    if self.end != 0 {
      try visitor.visitSingularInt64Field(value: self.end, fieldNumber: 6)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 7)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 8)
    }
    if self.maxCalls != 0 {
      try visitor.visitSingularInt32Field(value: self.maxCalls, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_SearchVariantsRequest, rhs: Google_Genomics_V1_SearchVariantsRequest) -> Bool {
    if lhs.variantSetIds != rhs.variantSetIds {return false}
    if lhs.variantName != rhs.variantName {return false}
    if lhs.callSetIds != rhs.callSetIds {return false}
    if lhs.referenceName != rhs.referenceName {return false}
    if lhs.start != rhs.start {return false}
    if lhs.end != rhs.end {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.maxCalls != rhs.maxCalls {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_SearchVariantsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchVariantsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "variants"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.variants) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.variants.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.variants, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_SearchVariantsResponse, rhs: Google_Genomics_V1_SearchVariantsResponse) -> Bool {
    if lhs.variants != rhs.variants {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_CreateVariantRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateVariantRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "variant"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._variant) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._variant {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_CreateVariantRequest, rhs: Google_Genomics_V1_CreateVariantRequest) -> Bool {
    if lhs._variant != rhs._variant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_UpdateVariantRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateVariantRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "variant_id"),
    2: .same(proto: "variant"),
    3: .standard(proto: "update_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.variantID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._variant) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.variantID.isEmpty {
      try visitor.visitSingularStringField(value: self.variantID, fieldNumber: 1)
    }
    if let v = self._variant {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_UpdateVariantRequest, rhs: Google_Genomics_V1_UpdateVariantRequest) -> Bool {
    if lhs.variantID != rhs.variantID {return false}
    if lhs._variant != rhs._variant {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_DeleteVariantRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteVariantRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "variant_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.variantID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.variantID.isEmpty {
      try visitor.visitSingularStringField(value: self.variantID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_DeleteVariantRequest, rhs: Google_Genomics_V1_DeleteVariantRequest) -> Bool {
    if lhs.variantID != rhs.variantID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_GetVariantRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetVariantRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "variant_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.variantID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.variantID.isEmpty {
      try visitor.visitSingularStringField(value: self.variantID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_GetVariantRequest, rhs: Google_Genomics_V1_GetVariantRequest) -> Bool {
    if lhs.variantID != rhs.variantID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_MergeVariantsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MergeVariantsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "variant_set_id"),
    2: .same(proto: "variants"),
    3: .standard(proto: "info_merge_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.variantSetID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.variants) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufEnumMap<SwiftProtobuf.ProtobufString,Google_Genomics_V1_InfoMergeOperation>.self, value: &self.infoMergeConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.variantSetID.isEmpty {
      try visitor.visitSingularStringField(value: self.variantSetID, fieldNumber: 1)
    }
    if !self.variants.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.variants, fieldNumber: 2)
    }
    if !self.infoMergeConfig.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufEnumMap<SwiftProtobuf.ProtobufString,Google_Genomics_V1_InfoMergeOperation>.self, value: self.infoMergeConfig, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_MergeVariantsRequest, rhs: Google_Genomics_V1_MergeVariantsRequest) -> Bool {
    if lhs.variantSetID != rhs.variantSetID {return false}
    if lhs.variants != rhs.variants {return false}
    if lhs.infoMergeConfig != rhs.infoMergeConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_SearchCallSetsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchCallSetsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "variant_set_ids"),
    2: .same(proto: "name"),
    3: .standard(proto: "page_token"),
    4: .standard(proto: "page_size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.variantSetIds) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.variantSetIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.variantSetIds, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_SearchCallSetsRequest, rhs: Google_Genomics_V1_SearchCallSetsRequest) -> Bool {
    if lhs.variantSetIds != rhs.variantSetIds {return false}
    if lhs.name != rhs.name {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_SearchCallSetsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchCallSetsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_sets"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.callSets) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.callSets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.callSets, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_SearchCallSetsResponse, rhs: Google_Genomics_V1_SearchCallSetsResponse) -> Bool {
    if lhs.callSets != rhs.callSets {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_CreateCallSetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateCallSetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_set"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._callSet) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._callSet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_CreateCallSetRequest, rhs: Google_Genomics_V1_CreateCallSetRequest) -> Bool {
    if lhs._callSet != rhs._callSet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_UpdateCallSetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateCallSetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_set_id"),
    2: .standard(proto: "call_set"),
    3: .standard(proto: "update_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.callSetID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._callSet) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.callSetID.isEmpty {
      try visitor.visitSingularStringField(value: self.callSetID, fieldNumber: 1)
    }
    if let v = self._callSet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_UpdateCallSetRequest, rhs: Google_Genomics_V1_UpdateCallSetRequest) -> Bool {
    if lhs.callSetID != rhs.callSetID {return false}
    if lhs._callSet != rhs._callSet {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_DeleteCallSetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteCallSetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_set_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.callSetID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.callSetID.isEmpty {
      try visitor.visitSingularStringField(value: self.callSetID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_DeleteCallSetRequest, rhs: Google_Genomics_V1_DeleteCallSetRequest) -> Bool {
    if lhs.callSetID != rhs.callSetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_GetCallSetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCallSetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_set_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.callSetID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.callSetID.isEmpty {
      try visitor.visitSingularStringField(value: self.callSetID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_GetCallSetRequest, rhs: Google_Genomics_V1_GetCallSetRequest) -> Bool {
    if lhs.callSetID != rhs.callSetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_StreamVariantsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StreamVariantsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .standard(proto: "variant_set_id"),
    3: .standard(proto: "call_set_ids"),
    4: .standard(proto: "reference_name"),
    5: .same(proto: "start"),
    6: .same(proto: "end"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.variantSetID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.callSetIds) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.referenceName) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.start) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.end) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.variantSetID.isEmpty {
      try visitor.visitSingularStringField(value: self.variantSetID, fieldNumber: 2)
    }
    if !self.callSetIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.callSetIds, fieldNumber: 3)
    }
    if !self.referenceName.isEmpty {
      try visitor.visitSingularStringField(value: self.referenceName, fieldNumber: 4)
    }
    if self.start != 0 {
      try visitor.visitSingularInt64Field(value: self.start, fieldNumber: 5)
    }
    if self.end != 0 {
      try visitor.visitSingularInt64Field(value: self.end, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_StreamVariantsRequest, rhs: Google_Genomics_V1_StreamVariantsRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.variantSetID != rhs.variantSetID {return false}
    if lhs.callSetIds != rhs.callSetIds {return false}
    if lhs.referenceName != rhs.referenceName {return false}
    if lhs.start != rhs.start {return false}
    if lhs.end != rhs.end {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_StreamVariantsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StreamVariantsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "variants"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.variants) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.variants.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.variants, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_StreamVariantsResponse, rhs: Google_Genomics_V1_StreamVariantsResponse) -> Bool {
    if lhs.variants != rhs.variants {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

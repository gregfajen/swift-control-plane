// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/genomics/v1/references.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2016 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A reference is a canonical assembled DNA sequence, intended to act as a
/// reference coordinate space for other genomic annotations. A single reference
/// might represent the human chromosome 1 or mitochandrial DNA, for instance. A
/// reference belongs to one or more reference sets.
///
/// For more genomics resource definitions, see [Fundamentals of Google
/// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
public struct Google_Genomics_V1_Reference {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The server-generated reference ID, unique across all references.
  public var id: String = String()

  /// The length of this reference's sequence.
  public var length: Int64 = 0

  /// MD5 of the upper-case sequence excluding all whitespace characters (this
  /// is equivalent to SQ:M5 in SAM). This value is represented in lower case
  /// hexadecimal format.
  public var md5Checksum: String = String()

  /// The name of this reference, for example `22`.
  public var name: String = String()

  /// The URI from which the sequence was obtained. Typically specifies a FASTA
  /// format file.
  public var sourceUri: String = String()

  /// All known corresponding accession IDs in INSDC (GenBank/ENA/DDBJ) ideally
  /// with a version number, for example `GCF_000001405.26`.
  public var sourceAccessions: [String] = []

  /// ID from http://www.ncbi.nlm.nih.gov/taxonomy. For example, 9606 for human.
  public var ncbiTaxonID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A reference set is a set of references which typically comprise a reference
/// assembly for a species, such as `GRCh38` which is representative
/// of the human genome. A reference set defines a common coordinate space for
/// comparing reference-aligned experimental data. A reference set contains 1 or
/// more references.
///
/// For more genomics resource definitions, see [Fundamentals of Google
/// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
public struct Google_Genomics_V1_ReferenceSet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The server-generated reference set ID, unique across all reference sets.
  public var id: String = String()

  /// The IDs of the reference objects that are part of this set.
  /// `Reference.md5checksum` must be unique within this set.
  public var referenceIds: [String] = []

  /// Order-independent MD5 checksum which identifies this reference set. The
  /// checksum is computed by sorting all lower case hexidecimal string
  /// `reference.md5checksum` (for all reference in this set) in
  /// ascending lexicographic order, concatenating, and taking the MD5 of that
  /// value. The resulting value is represented in lower case hexadecimal format.
  public var md5Checksum: String = String()

  /// ID from http://www.ncbi.nlm.nih.gov/taxonomy (for example, 9606 for human)
  /// indicating the species which this reference set is intended to model. Note
  /// that contained references may specify a different `ncbiTaxonId`, as
  /// assemblies may contain reference sequences which do not belong to the
  /// modeled species, for example EBV in a human reference genome.
  public var ncbiTaxonID: Int32 = 0

  /// Free text description of this reference set.
  public var description_p: String = String()

  /// Public id of this reference set, such as `GRCh37`.
  public var assemblyID: String = String()

  /// The URI from which the references were obtained.
  public var sourceUri: String = String()

  /// All known corresponding accession IDs in INSDC (GenBank/ENA/DDBJ) ideally
  /// with a version number, for example `NC_000001.11`.
  public var sourceAccessions: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Google_Genomics_V1_SearchReferenceSetsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If present, return reference sets for which the
  /// [md5checksum][google.genomics.v1.ReferenceSet.md5checksum] matches exactly.
  public var md5Checksums: [String] = []

  /// If present, return reference sets for which a prefix of any of
  /// [sourceAccessions][google.genomics.v1.ReferenceSet.source_accessions]
  /// match any of these strings. Accession numbers typically have a main number
  /// and a version, for example `NC_000001.11`.
  public var accessions: [String] = []

  /// If present, return reference sets for which a substring of their
  /// `assemblyId` matches this string (case insensitive).
  public var assemblyID: String = String()

  /// The continuation token, which is used to page through large result sets.
  /// To get the next page of results, set this parameter to the value of
  /// `nextPageToken` from the previous response.
  public var pageToken: String = String()

  /// The maximum number of results to return in a single page. If unspecified,
  /// defaults to 1024. The maximum value is 4096.
  public var pageSize: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Google_Genomics_V1_SearchReferenceSetsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The matching references sets.
  public var referenceSets: [Google_Genomics_V1_ReferenceSet] = []

  /// The continuation token, which is used to page through large result sets.
  /// Provide this value in a subsequent request to return the next page of
  /// results. This field will be empty if there aren't any additional results.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Google_Genomics_V1_GetReferenceSetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the reference set.
  public var referenceSetID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Google_Genomics_V1_SearchReferencesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If present, return references for which the
  /// [md5checksum][google.genomics.v1.Reference.md5checksum] matches exactly.
  public var md5Checksums: [String] = []

  /// If present, return references for which a prefix of any of
  /// [sourceAccessions][google.genomics.v1.Reference.source_accessions] match
  /// any of these strings. Accession numbers typically have a main number and a
  /// version, for example `GCF_000001405.26`.
  public var accessions: [String] = []

  /// If present, return only references which belong to this reference set.
  public var referenceSetID: String = String()

  /// The continuation token, which is used to page through large result sets.
  /// To get the next page of results, set this parameter to the value of
  /// `nextPageToken` from the previous response.
  public var pageToken: String = String()

  /// The maximum number of results to return in a single page. If unspecified,
  /// defaults to 1024. The maximum value is 4096.
  public var pageSize: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Google_Genomics_V1_SearchReferencesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The matching references.
  public var references: [Google_Genomics_V1_Reference] = []

  /// The continuation token, which is used to page through large result sets.
  /// Provide this value in a subsequent request to return the next page of
  /// results. This field will be empty if there aren't any additional results.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Google_Genomics_V1_GetReferenceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the reference.
  public var referenceID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Google_Genomics_V1_ListBasesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the reference.
  public var referenceID: String = String()

  /// The start position (0-based) of this query. Defaults to 0.
  public var start: Int64 = 0

  /// The end position (0-based, exclusive) of this query. Defaults to the length
  /// of this reference.
  public var end: Int64 = 0

  /// The continuation token, which is used to page through large result sets.
  /// To get the next page of results, set this parameter to the value of
  /// `nextPageToken` from the previous response.
  public var pageToken: String = String()

  /// The maximum number of bases to return in a single page. If unspecified,
  /// defaults to 200Kbp (kilo base pairs). The maximum value is 10Mbp (mega base
  /// pairs).
  public var pageSize: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Google_Genomics_V1_ListBasesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The offset position (0-based) of the given `sequence` from the
  /// start of this `Reference`. This value will differ for each page
  /// in a paginated request.
  public var offset: Int64 = 0

  /// A substring of the bases that make up this reference.
  public var sequence: String = String()

  /// The continuation token, which is used to page through large result sets.
  /// Provide this value in a subsequent request to return the next page of
  /// results. This field will be empty if there aren't any additional results.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.genomics.v1"

extension Google_Genomics_V1_Reference: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Reference"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "length"),
    3: .same(proto: "md5checksum"),
    4: .same(proto: "name"),
    5: .standard(proto: "source_uri"),
    6: .standard(proto: "source_accessions"),
    7: .standard(proto: "ncbi_taxon_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.length) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.md5Checksum) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.sourceUri) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.sourceAccessions) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.ncbiTaxonID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.length != 0 {
      try visitor.visitSingularInt64Field(value: self.length, fieldNumber: 2)
    }
    if !self.md5Checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.md5Checksum, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    if !self.sourceUri.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceUri, fieldNumber: 5)
    }
    if !self.sourceAccessions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.sourceAccessions, fieldNumber: 6)
    }
    if self.ncbiTaxonID != 0 {
      try visitor.visitSingularInt32Field(value: self.ncbiTaxonID, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_Reference, rhs: Google_Genomics_V1_Reference) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.length != rhs.length {return false}
    if lhs.md5Checksum != rhs.md5Checksum {return false}
    if lhs.name != rhs.name {return false}
    if lhs.sourceUri != rhs.sourceUri {return false}
    if lhs.sourceAccessions != rhs.sourceAccessions {return false}
    if lhs.ncbiTaxonID != rhs.ncbiTaxonID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_ReferenceSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReferenceSet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "reference_ids"),
    3: .same(proto: "md5checksum"),
    4: .standard(proto: "ncbi_taxon_id"),
    5: .same(proto: "description"),
    6: .standard(proto: "assembly_id"),
    7: .standard(proto: "source_uri"),
    8: .standard(proto: "source_accessions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.referenceIds) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.md5Checksum) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.ncbiTaxonID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.assemblyID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.sourceUri) }()
      case 8: try { try decoder.decodeRepeatedStringField(value: &self.sourceAccessions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.referenceIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.referenceIds, fieldNumber: 2)
    }
    if !self.md5Checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.md5Checksum, fieldNumber: 3)
    }
    if self.ncbiTaxonID != 0 {
      try visitor.visitSingularInt32Field(value: self.ncbiTaxonID, fieldNumber: 4)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 5)
    }
    if !self.assemblyID.isEmpty {
      try visitor.visitSingularStringField(value: self.assemblyID, fieldNumber: 6)
    }
    if !self.sourceUri.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceUri, fieldNumber: 7)
    }
    if !self.sourceAccessions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.sourceAccessions, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_ReferenceSet, rhs: Google_Genomics_V1_ReferenceSet) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.referenceIds != rhs.referenceIds {return false}
    if lhs.md5Checksum != rhs.md5Checksum {return false}
    if lhs.ncbiTaxonID != rhs.ncbiTaxonID {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.assemblyID != rhs.assemblyID {return false}
    if lhs.sourceUri != rhs.sourceUri {return false}
    if lhs.sourceAccessions != rhs.sourceAccessions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_SearchReferenceSetsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchReferenceSetsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "md5checksums"),
    2: .same(proto: "accessions"),
    3: .standard(proto: "assembly_id"),
    4: .standard(proto: "page_token"),
    5: .standard(proto: "page_size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.md5Checksums) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.accessions) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.assemblyID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.md5Checksums.isEmpty {
      try visitor.visitRepeatedStringField(value: self.md5Checksums, fieldNumber: 1)
    }
    if !self.accessions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.accessions, fieldNumber: 2)
    }
    if !self.assemblyID.isEmpty {
      try visitor.visitSingularStringField(value: self.assemblyID, fieldNumber: 3)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 4)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_SearchReferenceSetsRequest, rhs: Google_Genomics_V1_SearchReferenceSetsRequest) -> Bool {
    if lhs.md5Checksums != rhs.md5Checksums {return false}
    if lhs.accessions != rhs.accessions {return false}
    if lhs.assemblyID != rhs.assemblyID {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_SearchReferenceSetsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchReferenceSetsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "reference_sets"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.referenceSets) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.referenceSets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.referenceSets, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_SearchReferenceSetsResponse, rhs: Google_Genomics_V1_SearchReferenceSetsResponse) -> Bool {
    if lhs.referenceSets != rhs.referenceSets {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_GetReferenceSetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetReferenceSetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "reference_set_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.referenceSetID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.referenceSetID.isEmpty {
      try visitor.visitSingularStringField(value: self.referenceSetID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_GetReferenceSetRequest, rhs: Google_Genomics_V1_GetReferenceSetRequest) -> Bool {
    if lhs.referenceSetID != rhs.referenceSetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_SearchReferencesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchReferencesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "md5checksums"),
    2: .same(proto: "accessions"),
    3: .standard(proto: "reference_set_id"),
    4: .standard(proto: "page_token"),
    5: .standard(proto: "page_size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.md5Checksums) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.accessions) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.referenceSetID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.md5Checksums.isEmpty {
      try visitor.visitRepeatedStringField(value: self.md5Checksums, fieldNumber: 1)
    }
    if !self.accessions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.accessions, fieldNumber: 2)
    }
    if !self.referenceSetID.isEmpty {
      try visitor.visitSingularStringField(value: self.referenceSetID, fieldNumber: 3)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 4)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_SearchReferencesRequest, rhs: Google_Genomics_V1_SearchReferencesRequest) -> Bool {
    if lhs.md5Checksums != rhs.md5Checksums {return false}
    if lhs.accessions != rhs.accessions {return false}
    if lhs.referenceSetID != rhs.referenceSetID {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_SearchReferencesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchReferencesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "references"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.references) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.references.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.references, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_SearchReferencesResponse, rhs: Google_Genomics_V1_SearchReferencesResponse) -> Bool {
    if lhs.references != rhs.references {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_GetReferenceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetReferenceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "reference_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.referenceID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.referenceID.isEmpty {
      try visitor.visitSingularStringField(value: self.referenceID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_GetReferenceRequest, rhs: Google_Genomics_V1_GetReferenceRequest) -> Bool {
    if lhs.referenceID != rhs.referenceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_ListBasesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListBasesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "reference_id"),
    2: .same(proto: "start"),
    3: .same(proto: "end"),
    4: .standard(proto: "page_token"),
    5: .standard(proto: "page_size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.referenceID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.start) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.end) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.referenceID.isEmpty {
      try visitor.visitSingularStringField(value: self.referenceID, fieldNumber: 1)
    }
    if self.start != 0 {
      try visitor.visitSingularInt64Field(value: self.start, fieldNumber: 2)
    }
    if self.end != 0 {
      try visitor.visitSingularInt64Field(value: self.end, fieldNumber: 3)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 4)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_ListBasesRequest, rhs: Google_Genomics_V1_ListBasesRequest) -> Bool {
    if lhs.referenceID != rhs.referenceID {return false}
    if lhs.start != rhs.start {return false}
    if lhs.end != rhs.end {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_ListBasesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListBasesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "offset"),
    2: .same(proto: "sequence"),
    3: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sequence) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 1)
    }
    if !self.sequence.isEmpty {
      try visitor.visitSingularStringField(value: self.sequence, fieldNumber: 2)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_ListBasesResponse, rhs: Google_Genomics_V1_ListBasesResponse) -> Bool {
    if lhs.offset != rhs.offset {return false}
    if lhs.sequence != rhs.sequence {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

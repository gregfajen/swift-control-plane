// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/genomics/v1/annotations.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2016 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// When an [Annotation][google.genomics.v1.Annotation] or
/// [AnnotationSet][google.genomics.v1.AnnotationSet] is created, if `type` is
/// not specified it will be set to `GENERIC`.
public enum Google_Genomics_V1_AnnotationType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unspecified // = 0

  /// A `GENERIC` annotation type should be used when no other annotation
  /// type will suffice. This represents an untyped annotation of the reference
  /// genome.
  case generic // = 1

  /// A `VARIANT` annotation type.
  case variant // = 2

  /// A `GENE` annotation type represents the existence of a gene at the
  /// associated reference coordinates. The start coordinate is typically the
  /// gene's transcription start site and the end is typically the end of the
  /// gene's last exon.
  case gene // = 3

  /// A `TRANSCRIPT` annotation type represents the assertion that a
  /// particular region of the reference genome may be transcribed as RNA.
  case transcript // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .generic
    case 2: self = .variant
    case 3: self = .gene
    case 4: self = .transcript
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .generic: return 1
    case .variant: return 2
    case .gene: return 3
    case .transcript: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Genomics_V1_AnnotationType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Genomics_V1_AnnotationType] = [
    .unspecified,
    .generic,
    .variant,
    .gene,
    .transcript,
  ]
}

#endif  // swift(>=4.2)

/// An annotation set is a logical grouping of annotations that share consistent
/// type information and provenance. Examples of annotation sets include 'all
/// genes from refseq', and 'all variant annotations from ClinVar'.
public struct Google_Genomics_V1_AnnotationSet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The server-generated annotation set ID, unique across all annotation sets.
  public var id: String = String()

  /// The dataset to which this annotation set belongs.
  public var datasetID: String = String()

  /// The ID of the reference set that defines the coordinate space for this
  /// set's annotations.
  public var referenceSetID: String = String()

  /// The display name for this annotation set.
  public var name: String = String()

  /// The source URI describing the file from which this annotation set was
  /// generated, if any.
  public var sourceUri: String = String()

  /// The type of annotations contained within this set.
  public var type: Google_Genomics_V1_AnnotationType = .unspecified

  /// A map of additional read alignment information. This must be of the form
  /// map<string, string[]> (string key mapping to a list of string values).
  public var info: Dictionary<String,SwiftProtobuf.Google_Protobuf_ListValue> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// An annotation describes a region of reference genome. The value of an
/// annotation may be one of several canonical types, supplemented by arbitrary
/// info tags. An annotation is not inherently associated with a specific
/// sample or individual (though a client could choose to use annotations in
/// this way). Example canonical annotation types are `GENE` and
/// `VARIANT`.
public struct Google_Genomics_V1_Annotation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The server-generated annotation ID, unique across all annotations.
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// The annotation set to which this annotation belongs.
  public var annotationSetID: String {
    get {return _storage._annotationSetID}
    set {_uniqueStorage()._annotationSetID = newValue}
  }

  /// The display name of this annotation.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// The ID of the Google Genomics reference associated with this range.
  public var referenceID: String {
    get {return _storage._referenceID}
    set {_uniqueStorage()._referenceID = newValue}
  }

  /// The display name corresponding to the reference specified by
  /// `referenceId`, for example `chr1`, `1`, or `chrX`.
  public var referenceName: String {
    get {return _storage._referenceName}
    set {_uniqueStorage()._referenceName = newValue}
  }

  /// The start position of the range on the reference, 0-based inclusive.
  public var start: Int64 {
    get {return _storage._start}
    set {_uniqueStorage()._start = newValue}
  }

  /// The end position of the range on the reference, 0-based exclusive.
  public var end: Int64 {
    get {return _storage._end}
    set {_uniqueStorage()._end = newValue}
  }

  /// Whether this range refers to the reverse strand, as opposed to the forward
  /// strand. Note that regardless of this field, the start/end position of the
  /// range always refer to the forward strand.
  public var reverseStrand: Bool {
    get {return _storage._reverseStrand}
    set {_uniqueStorage()._reverseStrand = newValue}
  }

  /// The data type for this annotation. Must match the containing annotation
  /// set's type.
  public var type: Google_Genomics_V1_AnnotationType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var value: OneOf_Value? {
    get {return _storage._value}
    set {_uniqueStorage()._value = newValue}
  }

  /// A variant annotation, which describes the effect of a variant on the
  /// genome, the coding sequence, and/or higher level consequences at the
  /// organism level e.g. pathogenicity. This field is only set for annotations
  /// of type `VARIANT`.
  public var variant: Google_Genomics_V1_VariantAnnotation {
    get {
      if case .variant(let v)? = _storage._value {return v}
      return Google_Genomics_V1_VariantAnnotation()
    }
    set {_uniqueStorage()._value = .variant(newValue)}
  }

  /// A transcript value represents the assertion that a particular region of
  /// the reference genome may be transcribed as RNA. An alternative splicing
  /// pattern would be represented as a separate transcript object. This field
  /// is only set for annotations of type `TRANSCRIPT`.
  public var transcript: Google_Genomics_V1_Transcript {
    get {
      if case .transcript(let v)? = _storage._value {return v}
      return Google_Genomics_V1_Transcript()
    }
    set {_uniqueStorage()._value = .transcript(newValue)}
  }

  /// A map of additional read alignment information. This must be of the form
  /// map<string, string[]> (string key mapping to a list of string values).
  public var info: Dictionary<String,SwiftProtobuf.Google_Protobuf_ListValue> {
    get {return _storage._info}
    set {_uniqueStorage()._info = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Value: Equatable {
    /// A variant annotation, which describes the effect of a variant on the
    /// genome, the coding sequence, and/or higher level consequences at the
    /// organism level e.g. pathogenicity. This field is only set for annotations
    /// of type `VARIANT`.
    case variant(Google_Genomics_V1_VariantAnnotation)
    /// A transcript value represents the assertion that a particular region of
    /// the reference genome may be transcribed as RNA. An alternative splicing
    /// pattern would be represented as a separate transcript object. This field
    /// is only set for annotations of type `TRANSCRIPT`.
    case transcript(Google_Genomics_V1_Transcript)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Genomics_V1_Annotation.OneOf_Value, rhs: Google_Genomics_V1_Annotation.OneOf_Value) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.variant, .variant): return {
        guard case .variant(let l) = lhs, case .variant(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.transcript, .transcript): return {
        guard case .transcript(let l) = lhs, case .transcript(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Google_Genomics_V1_VariantAnnotation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type has been adapted from ClinVar's list of variant types.
  public var type: Google_Genomics_V1_VariantAnnotation.TypeEnum = .unspecified

  /// Effect of the variant on the coding sequence.
  public var effect: Google_Genomics_V1_VariantAnnotation.Effect = .unspecified

  /// The alternate allele for this variant. If multiple alternate alleles
  /// exist at this location, create a separate variant for each one, as they
  /// may represent distinct conditions.
  public var alternateBases: String = String()

  /// Google annotation ID of the gene affected by this variant. This should
  /// be provided when the variant is created.
  public var geneID: String = String()

  /// Google annotation IDs of the transcripts affected by this variant. These
  /// should be provided when the variant is created.
  public var transcriptIds: [String] = []

  /// The set of conditions associated with this variant.
  /// A condition describes the way a variant influences human health.
  public var conditions: [Google_Genomics_V1_VariantAnnotation.ClinicalCondition] = []

  /// Describes the clinical significance of a variant.
  /// It is adapted from the ClinVar controlled vocabulary for clinical
  /// significance described at:
  /// http://www.ncbi.nlm.nih.gov/clinvar/docs/clinsig/
  public var clinicalSignificance: Google_Genomics_V1_VariantAnnotation.ClinicalSignificance = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unspecified // = 0

    /// `TYPE_OTHER` should be used when no other Type will suffice.
    /// Further explanation of the variant type may be included in the
    /// [info][google.genomics.v1.Annotation.info] field.
    case other // = 1

    /// `INSERTION` indicates an insertion.
    case insertion // = 2

    /// `DELETION` indicates a deletion.
    case deletion // = 3

    /// `SUBSTITUTION` indicates a block substitution of
    /// two or more nucleotides.
    case substitution // = 4

    /// `SNP` indicates a single nucleotide polymorphism.
    case snp // = 5

    /// `STRUCTURAL` indicates a large structural variant,
    /// including chromosomal fusions, inversions, etc.
    case structural // = 6

    /// `CNV` indicates a variation in copy number.
    case cnv // = 7
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .other
      case 2: self = .insertion
      case 3: self = .deletion
      case 4: self = .substitution
      case 5: self = .snp
      case 6: self = .structural
      case 7: self = .cnv
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .other: return 1
      case .insertion: return 2
      case .deletion: return 3
      case .substitution: return 4
      case .snp: return 5
      case .structural: return 6
      case .cnv: return 7
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Effect: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unspecified // = 0

    /// `EFFECT_OTHER` should be used when no other Effect
    /// will suffice.
    case other // = 1

    /// `FRAMESHIFT` indicates a mutation in which the insertion or
    /// deletion of nucleotides resulted in a frameshift change.
    case frameshift // = 2

    /// `FRAME_PRESERVING_INDEL` indicates a mutation in which a
    /// multiple of three nucleotides has been inserted or deleted, resulting
    /// in no change to the reading frame of the coding sequence.
    case framePreservingIndel // = 3

    /// `SYNONYMOUS_SNP` indicates a single nucleotide polymorphism
    /// mutation that results in no amino acid change.
    case synonymousSnp // = 4

    /// `NONSYNONYMOUS_SNP` indicates a single nucleotide
    /// polymorphism mutation that results in an amino acid change.
    case nonsynonymousSnp // = 5

    /// `STOP_GAIN` indicates a mutation that leads to the creation
    /// of a stop codon at the variant site. Frameshift mutations creating
    /// downstream stop codons do not count as `STOP_GAIN`.
    case stopGain // = 6

    /// `STOP_LOSS` indicates a mutation that eliminates a
    /// stop codon at the variant site.
    case stopLoss // = 7

    /// `SPLICE_SITE_DISRUPTION` indicates that this variant is
    /// found in a splice site for the associated transcript, and alters the
    /// normal splicing pattern.
    case spliceSiteDisruption // = 8
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .other
      case 2: self = .frameshift
      case 3: self = .framePreservingIndel
      case 4: self = .synonymousSnp
      case 5: self = .nonsynonymousSnp
      case 6: self = .stopGain
      case 7: self = .stopLoss
      case 8: self = .spliceSiteDisruption
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .other: return 1
      case .frameshift: return 2
      case .framePreservingIndel: return 3
      case .synonymousSnp: return 4
      case .nonsynonymousSnp: return 5
      case .stopGain: return 6
      case .stopLoss: return 7
      case .spliceSiteDisruption: return 8
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum ClinicalSignificance: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unspecified // = 0

    /// `OTHER` should be used when no other clinical significance
    /// value will suffice.
    case other // = 1
    case uncertain // = 2
    case benign // = 3
    case likelyBenign // = 4
    case likelyPathogenic // = 5
    case pathogenic // = 6
    case drugResponse // = 7
    case histocompatibility // = 8
    case confersSensitivity // = 9
    case riskFactor // = 10
    case association // = 11
    case protective // = 12

    /// `MULTIPLE_REPORTED` should be used when multiple clinical
    /// signficances are reported for a variant. The original clinical
    /// significance values may be provided in the `info` field.
    case multipleReported // = 13
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .other
      case 2: self = .uncertain
      case 3: self = .benign
      case 4: self = .likelyBenign
      case 5: self = .likelyPathogenic
      case 6: self = .pathogenic
      case 7: self = .drugResponse
      case 8: self = .histocompatibility
      case 9: self = .confersSensitivity
      case 10: self = .riskFactor
      case 11: self = .association
      case 12: self = .protective
      case 13: self = .multipleReported
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .other: return 1
      case .uncertain: return 2
      case .benign: return 3
      case .likelyBenign: return 4
      case .likelyPathogenic: return 5
      case .pathogenic: return 6
      case .drugResponse: return 7
      case .histocompatibility: return 8
      case .confersSensitivity: return 9
      case .riskFactor: return 10
      case .association: return 11
      case .protective: return 12
      case .multipleReported: return 13
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct ClinicalCondition {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A set of names for the condition.
    public var names: [String] = []

    /// The set of external IDs for this condition.
    public var externalIds: [Google_Genomics_V1_ExternalId] = []

    /// The MedGen concept id associated with this gene.
    /// Search for these IDs at http://www.ncbi.nlm.nih.gov/medgen/
    public var conceptID: String = String()

    /// The OMIM id for this condition.
    /// Search for these IDs at http://omim.org/
    public var omimID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Genomics_V1_VariantAnnotation.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Genomics_V1_VariantAnnotation.TypeEnum] = [
    .unspecified,
    .other,
    .insertion,
    .deletion,
    .substitution,
    .snp,
    .structural,
    .cnv,
  ]
}

extension Google_Genomics_V1_VariantAnnotation.Effect: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Genomics_V1_VariantAnnotation.Effect] = [
    .unspecified,
    .other,
    .frameshift,
    .framePreservingIndel,
    .synonymousSnp,
    .nonsynonymousSnp,
    .stopGain,
    .stopLoss,
    .spliceSiteDisruption,
  ]
}

extension Google_Genomics_V1_VariantAnnotation.ClinicalSignificance: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Genomics_V1_VariantAnnotation.ClinicalSignificance] = [
    .unspecified,
    .other,
    .uncertain,
    .benign,
    .likelyBenign,
    .likelyPathogenic,
    .pathogenic,
    .drugResponse,
    .histocompatibility,
    .confersSensitivity,
    .riskFactor,
    .association,
    .protective,
    .multipleReported,
  ]
}

#endif  // swift(>=4.2)

/// A transcript represents the assertion that a particular region of the
/// reference genome may be transcribed as RNA.
public struct Google_Genomics_V1_Transcript {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The annotation ID of the gene from which this transcript is transcribed.
  public var geneID: String = String()

  /// The <a href="http://en.wikipedia.org/wiki/Exon">exons</a> that compose
  /// this transcript. This field should be unset for genomes where transcript
  /// splicing does not occur, for example prokaryotes.
  ///
  /// Introns are regions of the transcript that are not included in the
  /// spliced RNA product. Though not explicitly modeled here, intron ranges can
  /// be deduced; all regions of this transcript that are not exons are introns.
  ///
  /// Exonic sequences do not necessarily code for a translational product
  /// (amino acids). Only the regions of exons bounded by the
  /// [codingSequence][google.genomics.v1.Transcript.coding_sequence] correspond
  /// to coding DNA sequence.
  ///
  /// Exons are ordered by start position and may not overlap.
  public var exons: [Google_Genomics_V1_Transcript.Exon] = []

  /// The range of the coding sequence for this transcript, if any. To determine
  /// the exact ranges of coding sequence, intersect this range with those of the
  /// [exons][google.genomics.v1.Transcript.exons], if any. If there are any
  /// [exons][google.genomics.v1.Transcript.exons], the
  /// [codingSequence][google.genomics.v1.Transcript.coding_sequence] must start
  /// and end within them.
  ///
  /// Note that in some cases, the reference genome will not exactly match the
  /// observed mRNA transcript e.g. due to variance in the source genome from
  /// reference. In these cases,
  /// [exon.frame][google.genomics.v1.Transcript.Exon.frame] will not necessarily
  /// match the expected reference reading frame and coding exon reference bases
  /// cannot necessarily be concatenated to produce the original transcript mRNA.
  public var codingSequence: Google_Genomics_V1_Transcript.CodingSequence {
    get {return _codingSequence ?? Google_Genomics_V1_Transcript.CodingSequence()}
    set {_codingSequence = newValue}
  }
  /// Returns true if `codingSequence` has been explicitly set.
  public var hasCodingSequence: Bool {return self._codingSequence != nil}
  /// Clears the value of `codingSequence`. Subsequent reads from it will return its default value.
  public mutating func clearCodingSequence() {self._codingSequence = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Exon {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The start position of the exon on this annotation's reference sequence,
    /// 0-based inclusive. Note that this is relative to the reference start, and
    /// **not** the containing annotation start.
    public var start: Int64 = 0

    /// The end position of the exon on this annotation's reference sequence,
    /// 0-based exclusive. Note that this is relative to the reference start, and
    /// *not* the containing annotation start.
    public var end: Int64 = 0

    /// The frame of this exon. Contains a value of 0, 1, or 2, which indicates
    /// the offset of the first coding base of the exon within the reading frame
    /// of the coding DNA sequence, if any. This field is dependent on the
    /// strandedness of this annotation (see
    /// [Annotation.reverse_strand][google.genomics.v1.Annotation.reverse_strand]).
    /// For forward stranded annotations, this offset is relative to the
    /// [exon.start][google.genomics.v1.Transcript.Exon.start]. For reverse
    /// strand annotations, this offset is relative to the
    /// [exon.end][google.genomics.v1.Transcript.Exon.end] `- 1`.
    ///
    /// Unset if this exon does not intersect the coding sequence. Upon creation
    /// of a transcript, the frame must be populated for all or none of the
    /// coding exons.
    public var frame: SwiftProtobuf.Google_Protobuf_Int32Value {
      get {return _frame ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
      set {_frame = newValue}
    }
    /// Returns true if `frame` has been explicitly set.
    public var hasFrame: Bool {return self._frame != nil}
    /// Clears the value of `frame`. Subsequent reads from it will return its default value.
    public mutating func clearFrame() {self._frame = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _frame: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  }

  public struct CodingSequence {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The start of the coding sequence on this annotation's reference sequence,
    /// 0-based inclusive. Note that this position is relative to the reference
    /// start, and *not* the containing annotation start.
    public var start: Int64 = 0

    /// The end of the coding sequence on this annotation's reference sequence,
    /// 0-based exclusive. Note that this position is relative to the reference
    /// start, and *not* the containing annotation start.
    public var end: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _codingSequence: Google_Genomics_V1_Transcript.CodingSequence? = nil
}

public struct Google_Genomics_V1_ExternalId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the source of this data.
  public var sourceName: String = String()

  /// The id used by the source of this data.
  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Google_Genomics_V1_CreateAnnotationSetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The annotation set to create.
  public var annotationSet: Google_Genomics_V1_AnnotationSet {
    get {return _annotationSet ?? Google_Genomics_V1_AnnotationSet()}
    set {_annotationSet = newValue}
  }
  /// Returns true if `annotationSet` has been explicitly set.
  public var hasAnnotationSet: Bool {return self._annotationSet != nil}
  /// Clears the value of `annotationSet`. Subsequent reads from it will return its default value.
  public mutating func clearAnnotationSet() {self._annotationSet = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _annotationSet: Google_Genomics_V1_AnnotationSet? = nil
}

public struct Google_Genomics_V1_GetAnnotationSetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the annotation set to be retrieved.
  public var annotationSetID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Google_Genomics_V1_UpdateAnnotationSetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the annotation set to be updated.
  public var annotationSetID: String = String()

  /// The new annotation set.
  public var annotationSet: Google_Genomics_V1_AnnotationSet {
    get {return _annotationSet ?? Google_Genomics_V1_AnnotationSet()}
    set {_annotationSet = newValue}
  }
  /// Returns true if `annotationSet` has been explicitly set.
  public var hasAnnotationSet: Bool {return self._annotationSet != nil}
  /// Clears the value of `annotationSet`. Subsequent reads from it will return its default value.
  public mutating func clearAnnotationSet() {self._annotationSet = nil}

  /// An optional mask specifying which fields to update. Mutable fields are
  /// [name][google.genomics.v1.AnnotationSet.name],
  /// [source_uri][google.genomics.v1.AnnotationSet.source_uri], and
  /// [info][google.genomics.v1.AnnotationSet.info]. If unspecified, all
  /// mutable fields will be updated.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _annotationSet: Google_Genomics_V1_AnnotationSet? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

public struct Google_Genomics_V1_DeleteAnnotationSetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the annotation set to be deleted.
  public var annotationSetID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Google_Genomics_V1_SearchAnnotationSetsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The dataset IDs to search within. Caller must have `READ` access
  /// to these datasets.
  public var datasetIds: [String] = []

  /// If specified, only annotation sets associated with the given reference set
  /// are returned.
  public var referenceSetID: String = String()

  /// Only return annotations sets for which a substring of the name matches this
  /// string (case insensitive).
  public var name: String = String()

  /// If specified, only annotation sets that have any of these types are
  /// returned.
  public var types: [Google_Genomics_V1_AnnotationType] = []

  /// The continuation token, which is used to page through large result sets.
  /// To get the next page of results, set this parameter to the value of
  /// `nextPageToken` from the previous response.
  public var pageToken: String = String()

  /// The maximum number of results to return in a single page. If unspecified,
  /// defaults to 128. The maximum value is 1024.
  public var pageSize: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Google_Genomics_V1_SearchAnnotationSetsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The matching annotation sets.
  public var annotationSets: [Google_Genomics_V1_AnnotationSet] = []

  /// The continuation token, which is used to page through large result sets.
  /// Provide this value in a subsequent request to return the next page of
  /// results. This field will be empty if there aren't any additional results.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Google_Genomics_V1_CreateAnnotationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The annotation to be created.
  public var annotation: Google_Genomics_V1_Annotation {
    get {return _annotation ?? Google_Genomics_V1_Annotation()}
    set {_annotation = newValue}
  }
  /// Returns true if `annotation` has been explicitly set.
  public var hasAnnotation: Bool {return self._annotation != nil}
  /// Clears the value of `annotation`. Subsequent reads from it will return its default value.
  public mutating func clearAnnotation() {self._annotation = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _annotation: Google_Genomics_V1_Annotation? = nil
}

public struct Google_Genomics_V1_BatchCreateAnnotationsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The annotations to be created. At most 4096 can be specified in a single
  /// request.
  public var annotations: [Google_Genomics_V1_Annotation] = []

  /// A unique request ID which enables the server to detect duplicated requests.
  /// If provided, duplicated requests will result in the same response; if not
  /// provided, duplicated requests may result in duplicated data. For a given
  /// annotation set, callers should not reuse `request_id`s when writing
  /// different batches of annotations - behavior in this case is undefined.
  /// A common approach is to use a UUID. For batch jobs where worker crashes are
  /// a possibility, consider using some unique variant of a worker or run ID.
  public var requestID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Google_Genomics_V1_BatchCreateAnnotationsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The resulting per-annotation entries, ordered consistently with the
  /// original request.
  public var entries: [Google_Genomics_V1_BatchCreateAnnotationsResponse.Entry] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Entry {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The creation status.
    public var status: Google_Rpc_Status {
      get {return _status ?? Google_Rpc_Status()}
      set {_status = newValue}
    }
    /// Returns true if `status` has been explicitly set.
    public var hasStatus: Bool {return self._status != nil}
    /// Clears the value of `status`. Subsequent reads from it will return its default value.
    public mutating func clearStatus() {self._status = nil}

    /// The created annotation, if creation was successful.
    public var annotation: Google_Genomics_V1_Annotation {
      get {return _annotation ?? Google_Genomics_V1_Annotation()}
      set {_annotation = newValue}
    }
    /// Returns true if `annotation` has been explicitly set.
    public var hasAnnotation: Bool {return self._annotation != nil}
    /// Clears the value of `annotation`. Subsequent reads from it will return its default value.
    public mutating func clearAnnotation() {self._annotation = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _status: Google_Rpc_Status? = nil
    fileprivate var _annotation: Google_Genomics_V1_Annotation? = nil
  }

  public init() {}
}

public struct Google_Genomics_V1_GetAnnotationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the annotation to be retrieved.
  public var annotationID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Google_Genomics_V1_UpdateAnnotationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the annotation to be updated.
  public var annotationID: String = String()

  /// The new annotation.
  public var annotation: Google_Genomics_V1_Annotation {
    get {return _annotation ?? Google_Genomics_V1_Annotation()}
    set {_annotation = newValue}
  }
  /// Returns true if `annotation` has been explicitly set.
  public var hasAnnotation: Bool {return self._annotation != nil}
  /// Clears the value of `annotation`. Subsequent reads from it will return its default value.
  public mutating func clearAnnotation() {self._annotation = nil}

  /// An optional mask specifying which fields to update. Mutable fields are
  /// [name][google.genomics.v1.Annotation.name],
  /// [variant][google.genomics.v1.Annotation.variant],
  /// [transcript][google.genomics.v1.Annotation.transcript], and
  /// [info][google.genomics.v1.Annotation.info]. If unspecified, all mutable
  /// fields will be updated.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _annotation: Google_Genomics_V1_Annotation? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

public struct Google_Genomics_V1_DeleteAnnotationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the annotation to be deleted.
  public var annotationID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Google_Genomics_V1_SearchAnnotationsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The annotation sets to search within. The caller must have
  /// `READ` access to these annotation sets.
  /// All queried annotation sets must have the same type.
  public var annotationSetIds: [String] = []

  /// Required. `reference_id` or `reference_name` must be set.
  public var reference: Google_Genomics_V1_SearchAnnotationsRequest.OneOf_Reference? = nil

  /// The ID of the reference to query.
  public var referenceID: String {
    get {
      if case .referenceID(let v)? = reference {return v}
      return String()
    }
    set {reference = .referenceID(newValue)}
  }

  /// The name of the reference to query, within the reference set associated
  /// with this query.
  public var referenceName: String {
    get {
      if case .referenceName(let v)? = reference {return v}
      return String()
    }
    set {reference = .referenceName(newValue)}
  }

  /// The start position of the range on the reference, 0-based inclusive. If
  /// specified,
  /// [referenceId][google.genomics.v1.SearchAnnotationsRequest.reference_id] or
  /// [referenceName][google.genomics.v1.SearchAnnotationsRequest.reference_name]
  /// must be specified. Defaults to 0.
  public var start: Int64 = 0

  /// The end position of the range on the reference, 0-based exclusive. If
  /// [referenceId][google.genomics.v1.SearchAnnotationsRequest.reference_id] or
  /// [referenceName][google.genomics.v1.SearchAnnotationsRequest.reference_name]
  /// must be specified, Defaults to the length of the reference.
  public var end: Int64 = 0

  /// The continuation token, which is used to page through large result sets.
  /// To get the next page of results, set this parameter to the value of
  /// `nextPageToken` from the previous response.
  public var pageToken: String = String()

  /// The maximum number of results to return in a single page. If unspecified,
  /// defaults to 256. The maximum value is 2048.
  public var pageSize: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required. `reference_id` or `reference_name` must be set.
  public enum OneOf_Reference: Equatable {
    /// The ID of the reference to query.
    case referenceID(String)
    /// The name of the reference to query, within the reference set associated
    /// with this query.
    case referenceName(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Genomics_V1_SearchAnnotationsRequest.OneOf_Reference, rhs: Google_Genomics_V1_SearchAnnotationsRequest.OneOf_Reference) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.referenceID, .referenceID): return {
        guard case .referenceID(let l) = lhs, case .referenceID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.referenceName, .referenceName): return {
        guard case .referenceName(let l) = lhs, case .referenceName(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Google_Genomics_V1_SearchAnnotationsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The matching annotations.
  public var annotations: [Google_Genomics_V1_Annotation] = []

  /// The continuation token, which is used to page through large result sets.
  /// Provide this value in a subsequent request to return the next page of
  /// results. This field will be empty if there aren't any additional results.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.genomics.v1"

extension Google_Genomics_V1_AnnotationType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ANNOTATION_TYPE_UNSPECIFIED"),
    1: .same(proto: "GENERIC"),
    2: .same(proto: "VARIANT"),
    3: .same(proto: "GENE"),
    4: .same(proto: "TRANSCRIPT"),
  ]
}

extension Google_Genomics_V1_AnnotationSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AnnotationSet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "dataset_id"),
    3: .standard(proto: "reference_set_id"),
    4: .same(proto: "name"),
    5: .standard(proto: "source_uri"),
    6: .same(proto: "type"),
    17: .same(proto: "info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.datasetID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.referenceSetID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.sourceUri) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 17: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_ListValue>.self, value: &self.info) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.datasetID.isEmpty {
      try visitor.visitSingularStringField(value: self.datasetID, fieldNumber: 2)
    }
    if !self.referenceSetID.isEmpty {
      try visitor.visitSingularStringField(value: self.referenceSetID, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    if !self.sourceUri.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceUri, fieldNumber: 5)
    }
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 6)
    }
    if !self.info.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_ListValue>.self, value: self.info, fieldNumber: 17)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_AnnotationSet, rhs: Google_Genomics_V1_AnnotationSet) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.datasetID != rhs.datasetID {return false}
    if lhs.referenceSetID != rhs.referenceSetID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.sourceUri != rhs.sourceUri {return false}
    if lhs.type != rhs.type {return false}
    if lhs.info != rhs.info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_Annotation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Annotation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "annotation_set_id"),
    3: .same(proto: "name"),
    4: .standard(proto: "reference_id"),
    5: .standard(proto: "reference_name"),
    6: .same(proto: "start"),
    7: .same(proto: "end"),
    8: .standard(proto: "reverse_strand"),
    9: .same(proto: "type"),
    10: .same(proto: "variant"),
    11: .same(proto: "transcript"),
    12: .same(proto: "info"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _annotationSetID: String = String()
    var _name: String = String()
    var _referenceID: String = String()
    var _referenceName: String = String()
    var _start: Int64 = 0
    var _end: Int64 = 0
    var _reverseStrand: Bool = false
    var _type: Google_Genomics_V1_AnnotationType = .unspecified
    var _value: Google_Genomics_V1_Annotation.OneOf_Value?
    var _info: Dictionary<String,SwiftProtobuf.Google_Protobuf_ListValue> = [:]

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _annotationSetID = source._annotationSetID
      _name = source._name
      _referenceID = source._referenceID
      _referenceName = source._referenceName
      _start = source._start
      _end = source._end
      _reverseStrand = source._reverseStrand
      _type = source._type
      _value = source._value
      _info = source._info
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._annotationSetID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._referenceID) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._referenceName) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._start) }()
        case 7: try { try decoder.decodeSingularInt64Field(value: &_storage._end) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._reverseStrand) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 10: try {
          var v: Google_Genomics_V1_VariantAnnotation?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .variant(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .variant(v)}
        }()
        case 11: try {
          var v: Google_Genomics_V1_Transcript?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .transcript(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .transcript(v)}
        }()
        case 12: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_ListValue>.self, value: &_storage._info) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._annotationSetID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._annotationSetID, fieldNumber: 2)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 3)
      }
      if !_storage._referenceID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._referenceID, fieldNumber: 4)
      }
      if !_storage._referenceName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._referenceName, fieldNumber: 5)
      }
      if _storage._start != 0 {
        try visitor.visitSingularInt64Field(value: _storage._start, fieldNumber: 6)
      }
      if _storage._end != 0 {
        try visitor.visitSingularInt64Field(value: _storage._end, fieldNumber: 7)
      }
      if _storage._reverseStrand != false {
        try visitor.visitSingularBoolField(value: _storage._reverseStrand, fieldNumber: 8)
      }
      if _storage._type != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 9)
      }
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._value {
      case .variant?: try {
        guard case .variant(let v)? = _storage._value else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case .transcript?: try {
        guard case .transcript(let v)? = _storage._value else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      case nil: break
      }
      if !_storage._info.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_ListValue>.self, value: _storage._info, fieldNumber: 12)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_Annotation, rhs: Google_Genomics_V1_Annotation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._annotationSetID != rhs_storage._annotationSetID {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._referenceID != rhs_storage._referenceID {return false}
        if _storage._referenceName != rhs_storage._referenceName {return false}
        if _storage._start != rhs_storage._start {return false}
        if _storage._end != rhs_storage._end {return false}
        if _storage._reverseStrand != rhs_storage._reverseStrand {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._value != rhs_storage._value {return false}
        if _storage._info != rhs_storage._info {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_VariantAnnotation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VariantAnnotation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "effect"),
    3: .standard(proto: "alternate_bases"),
    4: .standard(proto: "gene_id"),
    5: .standard(proto: "transcript_ids"),
    6: .same(proto: "conditions"),
    7: .standard(proto: "clinical_significance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.effect) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.alternateBases) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.geneID) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.transcriptIds) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.conditions) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.clinicalSignificance) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.effect != .unspecified {
      try visitor.visitSingularEnumField(value: self.effect, fieldNumber: 2)
    }
    if !self.alternateBases.isEmpty {
      try visitor.visitSingularStringField(value: self.alternateBases, fieldNumber: 3)
    }
    if !self.geneID.isEmpty {
      try visitor.visitSingularStringField(value: self.geneID, fieldNumber: 4)
    }
    if !self.transcriptIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.transcriptIds, fieldNumber: 5)
    }
    if !self.conditions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.conditions, fieldNumber: 6)
    }
    if self.clinicalSignificance != .unspecified {
      try visitor.visitSingularEnumField(value: self.clinicalSignificance, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_VariantAnnotation, rhs: Google_Genomics_V1_VariantAnnotation) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.effect != rhs.effect {return false}
    if lhs.alternateBases != rhs.alternateBases {return false}
    if lhs.geneID != rhs.geneID {return false}
    if lhs.transcriptIds != rhs.transcriptIds {return false}
    if lhs.conditions != rhs.conditions {return false}
    if lhs.clinicalSignificance != rhs.clinicalSignificance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_VariantAnnotation.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNSPECIFIED"),
    1: .same(proto: "TYPE_OTHER"),
    2: .same(proto: "INSERTION"),
    3: .same(proto: "DELETION"),
    4: .same(proto: "SUBSTITUTION"),
    5: .same(proto: "SNP"),
    6: .same(proto: "STRUCTURAL"),
    7: .same(proto: "CNV"),
  ]
}

extension Google_Genomics_V1_VariantAnnotation.Effect: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EFFECT_UNSPECIFIED"),
    1: .same(proto: "EFFECT_OTHER"),
    2: .same(proto: "FRAMESHIFT"),
    3: .same(proto: "FRAME_PRESERVING_INDEL"),
    4: .same(proto: "SYNONYMOUS_SNP"),
    5: .same(proto: "NONSYNONYMOUS_SNP"),
    6: .same(proto: "STOP_GAIN"),
    7: .same(proto: "STOP_LOSS"),
    8: .same(proto: "SPLICE_SITE_DISRUPTION"),
  ]
}

extension Google_Genomics_V1_VariantAnnotation.ClinicalSignificance: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CLINICAL_SIGNIFICANCE_UNSPECIFIED"),
    1: .same(proto: "CLINICAL_SIGNIFICANCE_OTHER"),
    2: .same(proto: "UNCERTAIN"),
    3: .same(proto: "BENIGN"),
    4: .same(proto: "LIKELY_BENIGN"),
    5: .same(proto: "LIKELY_PATHOGENIC"),
    6: .same(proto: "PATHOGENIC"),
    7: .same(proto: "DRUG_RESPONSE"),
    8: .same(proto: "HISTOCOMPATIBILITY"),
    9: .same(proto: "CONFERS_SENSITIVITY"),
    10: .same(proto: "RISK_FACTOR"),
    11: .same(proto: "ASSOCIATION"),
    12: .same(proto: "PROTECTIVE"),
    13: .same(proto: "MULTIPLE_REPORTED"),
  ]
}

extension Google_Genomics_V1_VariantAnnotation.ClinicalCondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Genomics_V1_VariantAnnotation.protoMessageName + ".ClinicalCondition"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "names"),
    2: .standard(proto: "external_ids"),
    3: .standard(proto: "concept_id"),
    4: .standard(proto: "omim_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.names) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.externalIds) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.conceptID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.omimID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.names.isEmpty {
      try visitor.visitRepeatedStringField(value: self.names, fieldNumber: 1)
    }
    if !self.externalIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.externalIds, fieldNumber: 2)
    }
    if !self.conceptID.isEmpty {
      try visitor.visitSingularStringField(value: self.conceptID, fieldNumber: 3)
    }
    if !self.omimID.isEmpty {
      try visitor.visitSingularStringField(value: self.omimID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_VariantAnnotation.ClinicalCondition, rhs: Google_Genomics_V1_VariantAnnotation.ClinicalCondition) -> Bool {
    if lhs.names != rhs.names {return false}
    if lhs.externalIds != rhs.externalIds {return false}
    if lhs.conceptID != rhs.conceptID {return false}
    if lhs.omimID != rhs.omimID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_Transcript: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Transcript"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "gene_id"),
    2: .same(proto: "exons"),
    3: .standard(proto: "coding_sequence"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.geneID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.exons) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._codingSequence) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.geneID.isEmpty {
      try visitor.visitSingularStringField(value: self.geneID, fieldNumber: 1)
    }
    if !self.exons.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.exons, fieldNumber: 2)
    }
    if let v = self._codingSequence {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_Transcript, rhs: Google_Genomics_V1_Transcript) -> Bool {
    if lhs.geneID != rhs.geneID {return false}
    if lhs.exons != rhs.exons {return false}
    if lhs._codingSequence != rhs._codingSequence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_Transcript.Exon: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Genomics_V1_Transcript.protoMessageName + ".Exon"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "end"),
    3: .same(proto: "frame"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.start) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.end) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._frame) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.start != 0 {
      try visitor.visitSingularInt64Field(value: self.start, fieldNumber: 1)
    }
    if self.end != 0 {
      try visitor.visitSingularInt64Field(value: self.end, fieldNumber: 2)
    }
    if let v = self._frame {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_Transcript.Exon, rhs: Google_Genomics_V1_Transcript.Exon) -> Bool {
    if lhs.start != rhs.start {return false}
    if lhs.end != rhs.end {return false}
    if lhs._frame != rhs._frame {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_Transcript.CodingSequence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Genomics_V1_Transcript.protoMessageName + ".CodingSequence"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "end"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.start) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.end) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.start != 0 {
      try visitor.visitSingularInt64Field(value: self.start, fieldNumber: 1)
    }
    if self.end != 0 {
      try visitor.visitSingularInt64Field(value: self.end, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_Transcript.CodingSequence, rhs: Google_Genomics_V1_Transcript.CodingSequence) -> Bool {
    if lhs.start != rhs.start {return false}
    if lhs.end != rhs.end {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_ExternalId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExternalId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "source_name"),
    2: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sourceName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sourceName.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceName, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_ExternalId, rhs: Google_Genomics_V1_ExternalId) -> Bool {
    if lhs.sourceName != rhs.sourceName {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_CreateAnnotationSetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateAnnotationSetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "annotation_set"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._annotationSet) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._annotationSet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_CreateAnnotationSetRequest, rhs: Google_Genomics_V1_CreateAnnotationSetRequest) -> Bool {
    if lhs._annotationSet != rhs._annotationSet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_GetAnnotationSetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAnnotationSetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "annotation_set_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.annotationSetID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.annotationSetID.isEmpty {
      try visitor.visitSingularStringField(value: self.annotationSetID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_GetAnnotationSetRequest, rhs: Google_Genomics_V1_GetAnnotationSetRequest) -> Bool {
    if lhs.annotationSetID != rhs.annotationSetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_UpdateAnnotationSetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateAnnotationSetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "annotation_set_id"),
    2: .standard(proto: "annotation_set"),
    3: .standard(proto: "update_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.annotationSetID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._annotationSet) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.annotationSetID.isEmpty {
      try visitor.visitSingularStringField(value: self.annotationSetID, fieldNumber: 1)
    }
    if let v = self._annotationSet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_UpdateAnnotationSetRequest, rhs: Google_Genomics_V1_UpdateAnnotationSetRequest) -> Bool {
    if lhs.annotationSetID != rhs.annotationSetID {return false}
    if lhs._annotationSet != rhs._annotationSet {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_DeleteAnnotationSetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteAnnotationSetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "annotation_set_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.annotationSetID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.annotationSetID.isEmpty {
      try visitor.visitSingularStringField(value: self.annotationSetID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_DeleteAnnotationSetRequest, rhs: Google_Genomics_V1_DeleteAnnotationSetRequest) -> Bool {
    if lhs.annotationSetID != rhs.annotationSetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_SearchAnnotationSetsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchAnnotationSetsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dataset_ids"),
    2: .standard(proto: "reference_set_id"),
    3: .same(proto: "name"),
    4: .same(proto: "types"),
    5: .standard(proto: "page_token"),
    6: .standard(proto: "page_size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.datasetIds) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.referenceSetID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeRepeatedEnumField(value: &self.types) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.datasetIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.datasetIds, fieldNumber: 1)
    }
    if !self.referenceSetID.isEmpty {
      try visitor.visitSingularStringField(value: self.referenceSetID, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.types.isEmpty {
      try visitor.visitPackedEnumField(value: self.types, fieldNumber: 4)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 5)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_SearchAnnotationSetsRequest, rhs: Google_Genomics_V1_SearchAnnotationSetsRequest) -> Bool {
    if lhs.datasetIds != rhs.datasetIds {return false}
    if lhs.referenceSetID != rhs.referenceSetID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.types != rhs.types {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_SearchAnnotationSetsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchAnnotationSetsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "annotation_sets"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.annotationSets) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.annotationSets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.annotationSets, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_SearchAnnotationSetsResponse, rhs: Google_Genomics_V1_SearchAnnotationSetsResponse) -> Bool {
    if lhs.annotationSets != rhs.annotationSets {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_CreateAnnotationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateAnnotationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "annotation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._annotation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._annotation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_CreateAnnotationRequest, rhs: Google_Genomics_V1_CreateAnnotationRequest) -> Bool {
    if lhs._annotation != rhs._annotation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_BatchCreateAnnotationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchCreateAnnotationsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "annotations"),
    2: .standard(proto: "request_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.annotations) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.annotations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.annotations, fieldNumber: 1)
    }
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_BatchCreateAnnotationsRequest, rhs: Google_Genomics_V1_BatchCreateAnnotationsRequest) -> Bool {
    if lhs.annotations != rhs.annotations {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_BatchCreateAnnotationsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchCreateAnnotationsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entries"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_BatchCreateAnnotationsResponse, rhs: Google_Genomics_V1_BatchCreateAnnotationsResponse) -> Bool {
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_BatchCreateAnnotationsResponse.Entry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Genomics_V1_BatchCreateAnnotationsResponse.protoMessageName + ".Entry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "annotation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._annotation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._annotation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_BatchCreateAnnotationsResponse.Entry, rhs: Google_Genomics_V1_BatchCreateAnnotationsResponse.Entry) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._annotation != rhs._annotation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_GetAnnotationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAnnotationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "annotation_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.annotationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.annotationID.isEmpty {
      try visitor.visitSingularStringField(value: self.annotationID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_GetAnnotationRequest, rhs: Google_Genomics_V1_GetAnnotationRequest) -> Bool {
    if lhs.annotationID != rhs.annotationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_UpdateAnnotationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateAnnotationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "annotation_id"),
    2: .same(proto: "annotation"),
    3: .standard(proto: "update_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.annotationID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._annotation) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.annotationID.isEmpty {
      try visitor.visitSingularStringField(value: self.annotationID, fieldNumber: 1)
    }
    if let v = self._annotation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_UpdateAnnotationRequest, rhs: Google_Genomics_V1_UpdateAnnotationRequest) -> Bool {
    if lhs.annotationID != rhs.annotationID {return false}
    if lhs._annotation != rhs._annotation {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_DeleteAnnotationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteAnnotationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "annotation_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.annotationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.annotationID.isEmpty {
      try visitor.visitSingularStringField(value: self.annotationID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_DeleteAnnotationRequest, rhs: Google_Genomics_V1_DeleteAnnotationRequest) -> Bool {
    if lhs.annotationID != rhs.annotationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_SearchAnnotationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchAnnotationsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "annotation_set_ids"),
    2: .standard(proto: "reference_id"),
    3: .standard(proto: "reference_name"),
    4: .same(proto: "start"),
    5: .same(proto: "end"),
    6: .standard(proto: "page_token"),
    7: .standard(proto: "page_size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.annotationSetIds) }()
      case 2: try {
        if self.reference != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.reference = .referenceID(v)}
      }()
      case 3: try {
        if self.reference != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.reference = .referenceName(v)}
      }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.start) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.end) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.annotationSetIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.annotationSetIds, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.reference {
    case .referenceID?: try {
      guard case .referenceID(let v)? = self.reference else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .referenceName?: try {
      guard case .referenceName(let v)? = self.reference else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if self.start != 0 {
      try visitor.visitSingularInt64Field(value: self.start, fieldNumber: 4)
    }
    if self.end != 0 {
      try visitor.visitSingularInt64Field(value: self.end, fieldNumber: 5)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 6)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_SearchAnnotationsRequest, rhs: Google_Genomics_V1_SearchAnnotationsRequest) -> Bool {
    if lhs.annotationSetIds != rhs.annotationSetIds {return false}
    if lhs.reference != rhs.reference {return false}
    if lhs.start != rhs.start {return false}
    if lhs.end != rhs.end {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1_SearchAnnotationsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchAnnotationsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "annotations"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.annotations) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.annotations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.annotations, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1_SearchAnnotationsResponse, rhs: Google_Genomics_V1_SearchAnnotationsResponse) -> Bool {
    if lhs.annotations != rhs.annotations {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

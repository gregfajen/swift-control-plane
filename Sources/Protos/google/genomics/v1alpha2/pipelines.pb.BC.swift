// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/genomics/v1alpha2/pipelines.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2016 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Describes a Compute Engine resource that is being managed by a running
/// [pipeline][google.genomics.v1alpha2.Pipeline].
public struct Google_Genomics_V1alpha2_ComputeEngine {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The instance on which the operation is running.
  public var instanceName: String = String()

  /// The availability zone in which the instance resides.
  public var zone: String = String()

  /// The machine type of the instance.
  public var machineType: String = String()

  /// The names of the disks that were created for this pipeline.
  public var diskNames: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Runtime metadata that will be populated in the
/// [runtimeMetadata][google.genomics.v1.OperationMetadata.runtime_metadata]
/// field of the Operation associated with a RunPipeline execution.
public struct Google_Genomics_V1alpha2_RuntimeMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Execution information specific to Google Compute Engine.
  public var computeEngine: Google_Genomics_V1alpha2_ComputeEngine {
    get {return _computeEngine ?? Google_Genomics_V1alpha2_ComputeEngine()}
    set {_computeEngine = newValue}
  }
  /// Returns true if `computeEngine` has been explicitly set.
  public var hasComputeEngine: Bool {return self._computeEngine != nil}
  /// Clears the value of `computeEngine`. Subsequent reads from it will return its default value.
  public mutating func clearComputeEngine() {self._computeEngine = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _computeEngine: Google_Genomics_V1alpha2_ComputeEngine? = nil
}

/// The pipeline object. Represents a transformation from a set of input
/// parameters to a set of output parameters. The transformation is defined
/// as a docker image and command to run within that image. Each pipeline
/// is run on a Google Compute Engine VM. A pipeline can be created with the
/// `create` method and then later run with the `run` method, or a pipeline can
/// be defined and run all at once with the `run` method.
public struct Google_Genomics_V1alpha2_Pipeline {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The project in which to create the pipeline. The caller must have
  /// WRITE access.
  public var projectID: String = String()

  /// Required. A user specified pipeline name that does not have to be unique.
  /// This name can be used for filtering Pipelines in ListPipelines.
  public var name: String = String()

  /// User-specified description.
  public var description_p: String = String()

  /// Input parameters of the pipeline.
  public var inputParameters: [Google_Genomics_V1alpha2_PipelineParameter] = []

  /// Output parameters of the pipeline.
  public var outputParameters: [Google_Genomics_V1alpha2_PipelineParameter] = []

  /// Required. The executor indicates in which environment the pipeline runs.
  public var executor: Google_Genomics_V1alpha2_Pipeline.OneOf_Executor? = nil

  /// Specifies the docker run information.
  public var docker: Google_Genomics_V1alpha2_DockerExecutor {
    get {
      if case .docker(let v)? = executor {return v}
      return Google_Genomics_V1alpha2_DockerExecutor()
    }
    set {executor = .docker(newValue)}
  }

  /// Required. Specifies resource requirements for the pipeline run.
  /// Required fields:
  ///
  /// *
  /// [minimumCpuCores][google.genomics.v1alpha2.PipelineResources.minimum_cpu_cores]
  ///
  /// *
  /// [minimumRamGb][google.genomics.v1alpha2.PipelineResources.minimum_ram_gb]
  public var resources: Google_Genomics_V1alpha2_PipelineResources {
    get {return _resources ?? Google_Genomics_V1alpha2_PipelineResources()}
    set {_resources = newValue}
  }
  /// Returns true if `resources` has been explicitly set.
  public var hasResources: Bool {return self._resources != nil}
  /// Clears the value of `resources`. Subsequent reads from it will return its default value.
  public mutating func clearResources() {self._resources = nil}

  /// Unique pipeline id that is generated by the service when CreatePipeline
  /// is called. Cannot be specified in the Pipeline used in the
  /// CreatePipelineRequest, and will be populated in the response to
  /// CreatePipeline and all subsequent Get and List calls. Indicates that the
  /// service has registered this pipeline.
  public var pipelineID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required. The executor indicates in which environment the pipeline runs.
  public enum OneOf_Executor: Equatable {
    /// Specifies the docker run information.
    case docker(Google_Genomics_V1alpha2_DockerExecutor)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Genomics_V1alpha2_Pipeline.OneOf_Executor, rhs: Google_Genomics_V1alpha2_Pipeline.OneOf_Executor) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.docker, .docker): return {
        guard case .docker(let l) = lhs, case .docker(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _resources: Google_Genomics_V1alpha2_PipelineResources? = nil
}

/// The request to create a pipeline. The pipeline field here should not have
/// `pipelineId` populated, as that will be populated by the server.
public struct Google_Genomics_V1alpha2_CreatePipelineRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The pipeline to create. Should not have `pipelineId` populated.
  public var pipeline: Google_Genomics_V1alpha2_Pipeline {
    get {return _pipeline ?? Google_Genomics_V1alpha2_Pipeline()}
    set {_pipeline = newValue}
  }
  /// Returns true if `pipeline` has been explicitly set.
  public var hasPipeline: Bool {return self._pipeline != nil}
  /// Clears the value of `pipeline`. Subsequent reads from it will return its default value.
  public mutating func clearPipeline() {self._pipeline = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pipeline: Google_Genomics_V1alpha2_Pipeline? = nil
}

/// The pipeline run arguments.
public struct Google_Genomics_V1alpha2_RunPipelineArgs {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The project in which to run the pipeline. The caller must have
  /// WRITER access to all Google Cloud services and resources (e.g. Google
  /// Compute Engine) will be used.
  public var projectID: String {
    get {return _storage._projectID}
    set {_uniqueStorage()._projectID = newValue}
  }

  /// Pipeline input arguments; keys are defined in the pipeline documentation.
  /// All input parameters that do not have default values  must be specified.
  /// If parameters with defaults are specified here, the defaults will be
  /// overridden.
  public var inputs: Dictionary<String,String> {
    get {return _storage._inputs}
    set {_uniqueStorage()._inputs = newValue}
  }

  /// Pipeline output arguments; keys are defined in the pipeline
  /// documentation.  All output parameters of without default values
  /// must be specified.  If parameters with defaults are specified
  /// here, the defaults will be overridden.
  public var outputs: Dictionary<String,String> {
    get {return _storage._outputs}
    set {_uniqueStorage()._outputs = newValue}
  }

  /// The Google Cloud Service Account that will be used to access data and
  /// services. By default, the compute service account associated with
  /// `projectId` is used.
  public var serviceAccount: Google_Genomics_V1alpha2_ServiceAccount {
    get {return _storage._serviceAccount ?? Google_Genomics_V1alpha2_ServiceAccount()}
    set {_uniqueStorage()._serviceAccount = newValue}
  }
  /// Returns true if `serviceAccount` has been explicitly set.
  public var hasServiceAccount: Bool {return _storage._serviceAccount != nil}
  /// Clears the value of `serviceAccount`. Subsequent reads from it will return its default value.
  public mutating func clearServiceAccount() {_uniqueStorage()._serviceAccount = nil}

  /// This field is deprecated. Use `labels` instead. Client-specified pipeline
  /// operation identifier.
  public var clientID: String {
    get {return _storage._clientID}
    set {_uniqueStorage()._clientID = newValue}
  }

  /// Specifies resource requirements/overrides for the pipeline run.
  public var resources: Google_Genomics_V1alpha2_PipelineResources {
    get {return _storage._resources ?? Google_Genomics_V1alpha2_PipelineResources()}
    set {_uniqueStorage()._resources = newValue}
  }
  /// Returns true if `resources` has been explicitly set.
  public var hasResources: Bool {return _storage._resources != nil}
  /// Clears the value of `resources`. Subsequent reads from it will return its default value.
  public mutating func clearResources() {_uniqueStorage()._resources = nil}

  /// Required. Logging options. Used by the service to communicate results
  /// to the user.
  public var logging: Google_Genomics_V1alpha2_LoggingOptions {
    get {return _storage._logging ?? Google_Genomics_V1alpha2_LoggingOptions()}
    set {_uniqueStorage()._logging = newValue}
  }
  /// Returns true if `logging` has been explicitly set.
  public var hasLogging: Bool {return _storage._logging != nil}
  /// Clears the value of `logging`. Subsequent reads from it will return its default value.
  public mutating func clearLogging() {_uniqueStorage()._logging = nil}

  /// How long to keep the VM up after a failure (for example docker command
  /// failed, copying input or output files failed, etc). While the VM is up, one
  /// can ssh into the VM to debug. Default is 0; maximum allowed value is 1 day.
  public var keepVmAliveOnFailureDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._keepVmAliveOnFailureDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._keepVmAliveOnFailureDuration = newValue}
  }
  /// Returns true if `keepVmAliveOnFailureDuration` has been explicitly set.
  public var hasKeepVmAliveOnFailureDuration: Bool {return _storage._keepVmAliveOnFailureDuration != nil}
  /// Clears the value of `keepVmAliveOnFailureDuration`. Subsequent reads from it will return its default value.
  public mutating func clearKeepVmAliveOnFailureDuration() {_uniqueStorage()._keepVmAliveOnFailureDuration = nil}

  /// Labels to apply to this pipeline run. Labels will also be applied to
  /// compute resources (VM, disks) created by this pipeline run. When listing
  /// operations, operations can [filtered by labels]
  /// [google.longrunning.ListOperationsRequest.filter].
  /// Label keys may not be empty; label values may be empty. Non-empty labels
  /// must be 1-63 characters long, and comply with [RFC1035]
  /// (https://www.ietf.org/rfc/rfc1035.txt).
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first
  /// character must be a lowercase letter, and all following characters must be
  /// a dash, lowercase letter, or digit, except the last character, which cannot
  /// be a dash.
  public var labels: Dictionary<String,String> {
    get {return _storage._labels}
    set {_uniqueStorage()._labels = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The request to run a pipeline. If `pipelineId` is specified, it
/// refers to a saved pipeline created with CreatePipeline and set as
/// the `pipelineId` of the returned Pipeline object. If
/// `ephemeralPipeline` is specified, that pipeline is run once
/// with the given args and not saved. It is an error to specify both
/// `pipelineId` and `ephemeralPipeline`. `pipelineArgs`
/// must be specified.
public struct Google_Genomics_V1alpha2_RunPipelineRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pipeline: Google_Genomics_V1alpha2_RunPipelineRequest.OneOf_Pipeline? = nil

  /// The already created pipeline to run.
  public var pipelineID: String {
    get {
      if case .pipelineID(let v)? = pipeline {return v}
      return String()
    }
    set {pipeline = .pipelineID(newValue)}
  }

  /// A new pipeline object to run once and then delete.
  public var ephemeralPipeline: Google_Genomics_V1alpha2_Pipeline {
    get {
      if case .ephemeralPipeline(let v)? = pipeline {return v}
      return Google_Genomics_V1alpha2_Pipeline()
    }
    set {pipeline = .ephemeralPipeline(newValue)}
  }

  /// The arguments to use when running this pipeline.
  public var pipelineArgs: Google_Genomics_V1alpha2_RunPipelineArgs {
    get {return _pipelineArgs ?? Google_Genomics_V1alpha2_RunPipelineArgs()}
    set {_pipelineArgs = newValue}
  }
  /// Returns true if `pipelineArgs` has been explicitly set.
  public var hasPipelineArgs: Bool {return self._pipelineArgs != nil}
  /// Clears the value of `pipelineArgs`. Subsequent reads from it will return its default value.
  public mutating func clearPipelineArgs() {self._pipelineArgs = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Pipeline: Equatable {
    /// The already created pipeline to run.
    case pipelineID(String)
    /// A new pipeline object to run once and then delete.
    case ephemeralPipeline(Google_Genomics_V1alpha2_Pipeline)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Genomics_V1alpha2_RunPipelineRequest.OneOf_Pipeline, rhs: Google_Genomics_V1alpha2_RunPipelineRequest.OneOf_Pipeline) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.pipelineID, .pipelineID): return {
        guard case .pipelineID(let l) = lhs, case .pipelineID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ephemeralPipeline, .ephemeralPipeline): return {
        guard case .ephemeralPipeline(let l) = lhs, case .ephemeralPipeline(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _pipelineArgs: Google_Genomics_V1alpha2_RunPipelineArgs? = nil
}

/// A request to get a saved pipeline by id.
public struct Google_Genomics_V1alpha2_GetPipelineRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Caller must have READ access to the project in which this pipeline
  /// is defined.
  public var pipelineID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A request to list pipelines in a given project. Pipelines can be
/// filtered by name using `namePrefix`: all pipelines with names that
/// begin with `namePrefix` will be returned. Uses standard pagination:
/// `pageSize` indicates how many pipelines to return, and
/// `pageToken` comes from a previous ListPipelinesResponse to
/// indicate offset.
public struct Google_Genomics_V1alpha2_ListPipelinesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the project to search for pipelines. Caller
  /// must have READ access to this project.
  public var projectID: String = String()

  /// Pipelines with names that match this prefix should be
  /// returned.  If unspecified, all pipelines in the project, up to
  /// `pageSize`, will be returned.
  public var namePrefix: String = String()

  /// Number of pipelines to return at once. Defaults to 256, and max
  /// is 2048.
  public var pageSize: Int32 = 0

  /// Token to use to indicate where to start getting results.
  /// If unspecified, returns the first page of results.
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The response of ListPipelines. Contains at most `pageSize`
/// pipelines. If it contains `pageSize` pipelines, and more pipelines
/// exist, then `nextPageToken` will be populated and should be
/// used as the `pageToken` argument to a subsequent ListPipelines
/// request.
public struct Google_Genomics_V1alpha2_ListPipelinesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The matched pipelines.
  public var pipelines: [Google_Genomics_V1alpha2_Pipeline] = []

  /// The token to use to get the next page of results.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request to delete a saved pipeline by ID.
public struct Google_Genomics_V1alpha2_DeletePipelineRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Caller must have WRITE access to the project in which this pipeline
  /// is defined.
  public var pipelineID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to get controller configuation.  Should only be used
/// by VMs created by the Pipelines Service and not by end users.
public struct Google_Genomics_V1alpha2_GetControllerConfigRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The operation to retrieve controller configuration for.
  public var operationID: String = String()

  public var validationToken: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Stores the information that the controller will fetch from the
/// server in order to run. Should only be used by VMs created by the
/// Pipelines Service and not by end users.
public struct Google_Genomics_V1alpha2_ControllerConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var image: String = String()

  public var cmd: String = String()

  public var gcsLogPath: String = String()

  public var machineType: String = String()

  public var vars: Dictionary<String,String> = [:]

  public var disks: Dictionary<String,String> = [:]

  public var gcsSources: Dictionary<String,Google_Genomics_V1alpha2_ControllerConfig.RepeatedString> = [:]

  public var gcsSinks: Dictionary<String,Google_Genomics_V1alpha2_ControllerConfig.RepeatedString> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct RepeatedString {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var values: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Stores the list of events and times they occured for major events in job
/// execution.
public struct Google_Genomics_V1alpha2_TimestampEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// String indicating the type of event
  public var description_p: String = String()

  /// The time this event occured.
  public var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  public var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamp() {self._timestamp = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Request to set operation status. Should only be used by VMs
/// created by the Pipelines Service and not by end users.
public struct Google_Genomics_V1alpha2_SetOperationStatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var operationID: String = String()

  public var timestampEvents: [Google_Genomics_V1alpha2_TimestampEvent] = []

  public var errorCode: Google_Rpc_Code = .ok

  public var errorMessage: String = String()

  public var validationToken: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A Google Cloud Service Account.
public struct Google_Genomics_V1alpha2_ServiceAccount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Email address of the service account. Defaults to `default`,
  /// which uses the compute service account associated with the project.
  public var email: String = String()

  /// List of scopes to be enabled for this service account on the VM.
  /// The following scopes are automatically included:
  ///
  /// * https://www.googleapis.com/auth/compute
  /// * https://www.googleapis.com/auth/devstorage.full_control
  /// * https://www.googleapis.com/auth/genomics
  /// * https://www.googleapis.com/auth/logging.write
  /// * https://www.googleapis.com/auth/monitoring.write
  public var scopes: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The logging options for the pipeline run.
public struct Google_Genomics_V1alpha2_LoggingOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The location in Google Cloud Storage to which the pipeline logs
  /// will be copied. Can be specified as a fully qualified directory
  /// path, in which case logs will be output with a unique identifier
  /// as the filename in that directory, or as a fully specified path,
  /// which must end in `.log`, in which case that path will be
  /// used, and the user must ensure that logs are not
  /// overwritten. Stdout and stderr logs from the run are also
  /// generated and output as `-stdout.log` and `-stderr.log`.
  public var gcsPath: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The system resources for the pipeline run.
public struct Google_Genomics_V1alpha2_PipelineResources {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The minimum number of cores to use. Defaults to 1.
  public var minimumCpuCores: Int32 = 0

  /// Whether to use preemptible VMs. Defaults to `false`. In order to use this,
  /// must be true for both create time and run time. Cannot be true at run time
  /// if false at create time.
  public var preemptible: Bool = false

  /// The minimum amount of RAM to use. Defaults to 3.75 (GB)
  public var minimumRamGb: Double = 0

  /// Disks to attach.
  public var disks: [Google_Genomics_V1alpha2_PipelineResources.Disk] = []

  /// List of Google Compute Engine availability zones to which resource
  /// creation will restricted. If empty, any zone may be chosen.
  public var zones: [String] = []

  /// The size of the boot disk. Defaults to 10 (GB).
  public var bootDiskSizeGb: Int32 = 0

  /// Whether to assign an external IP to the instance. This is an experimental
  /// feature that may go away. Defaults to false.
  /// Corresponds to `--no_address` flag for [gcloud compute instances create]
  /// (https://cloud.google.com/sdk/gcloud/reference/compute/instances/create).
  /// In order to use this, must be true for both create time and run time.
  /// Cannot be true at run time if false at create time. If you need to ssh into
  /// a private IP VM for debugging, you can ssh to a public VM and then ssh into
  /// the private VM's Internal IP.  If noAddress is set, this pipeline run may
  /// only load docker images from Google Container Registry and not Docker Hub.
  /// ** Note: To use this option, your project must be in Google Access for
  /// Private IPs Early Access Program.**
  public var noAddress: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A Google Compute Engine disk resource specification.
  public struct Disk {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. The name of the disk that can be used in the pipeline
    /// parameters. Must be 1 - 63 characters.
    /// The name "boot" is reserved for system use.
    public var name: String = String()

    /// Required. The type of the disk to create.
    public var type: Google_Genomics_V1alpha2_PipelineResources.Disk.TypeEnum = .unspecified

    /// The size of the disk. Defaults to 500 (GB).
    /// This field is not applicable for local SSD.
    public var sizeGb: Int32 = 0

    /// The full or partial URL of the persistent disk to attach. See
    /// https://cloud.google.com/compute/docs/reference/latest/instances#resource
    /// and
    /// https://cloud.google.com/compute/docs/disks/persistent-disks#snapshots
    /// for more details.
    public var source: String = String()

    /// Deprecated. Disks created by the Pipelines API will be deleted at the end
    /// of the pipeline run, regardless of what this field is set to.
    public var autoDelete: Bool = false

    /// Required at create time and cannot be overridden at run time.
    /// Specifies the path in the docker container where files on
    /// this disk should be located. For example, if `mountPoint`
    /// is `/mnt/disk`, and the parameter has `localPath`
    /// `inputs/file.txt`, the docker container can access the data at
    /// `/mnt/disk/inputs/file.txt`.
    public var mountPoint: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The types of disks that may be attached to VMs.
    public enum TypeEnum: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// Default disk type. Use one of the other options below.
      case unspecified // = 0

      /// Specifies a Google Compute Engine persistent hard disk. See
      /// https://cloud.google.com/compute/docs/disks/#pdspecs for details.
      case persistentHdd // = 1

      /// Specifies a Google Compute Engine persistent solid-state disk. See
      /// https://cloud.google.com/compute/docs/disks/#pdspecs for details.
      case persistentSsd // = 2

      /// Specifies a Google Compute Engine local SSD.
      /// See https://cloud.google.com/compute/docs/disks/local-ssd for details.
      case localSsd // = 3
      case UNRECOGNIZED(Int)

      public init() {
        self = .unspecified
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .persistentHdd
        case 2: self = .persistentSsd
        case 3: self = .localSsd
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .persistentHdd: return 1
        case .persistentSsd: return 2
        case .localSsd: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Genomics_V1alpha2_PipelineResources.Disk.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Genomics_V1alpha2_PipelineResources.Disk.TypeEnum] = [
    .unspecified,
    .persistentHdd,
    .persistentSsd,
    .localSsd,
  ]
}

#endif  // swift(>=4.2)

/// Parameters facilitate setting and delivering data into the
/// pipeline's execution environment. They are defined at create time,
/// with optional defaults, and can be overridden at run time.
///
/// If `localCopy` is unset, then the parameter specifies a string that
/// is passed as-is into the pipeline, as the value of the environment
/// variable with the given name.  A default value can be optionally
/// specified at create time. The default can be overridden at run time
/// using the inputs map. If no default is given, a value must be
/// supplied at runtime.
///
/// If `localCopy` is defined, then the parameter specifies a data
/// source or sink, both in Google Cloud Storage and on the Docker container
/// where the pipeline computation is run. The [service account associated with
/// the Pipeline][google.genomics.v1alpha2.RunPipelineArgs.service_account] (by
/// default the project's Compute Engine service account) must have access to the
/// Google Cloud Storage paths.
///
/// At run time, the Google Cloud Storage paths can be overridden if a default
/// was provided at create time, or must be set otherwise. The pipeline runner
/// should add a key/value pair to either the inputs or outputs map. The
/// indicated data copies will be carried out before/after pipeline execution,
/// just as if the corresponding arguments were provided to `gsutil cp`.
///
/// For example: Given the following `PipelineParameter`, specified
/// in the `inputParameters` list:
///
/// ```
/// {name: "input_file", localCopy: {path: "file.txt", disk: "pd1"}}
/// ```
///
/// where `disk` is defined in the `PipelineResources` object as:
///
/// ```
/// {name: "pd1", mountPoint: "/mnt/disk/"}
/// ```
///
/// We create a disk named `pd1`, mount it on the host VM, and map
/// `/mnt/pd1` to `/mnt/disk` in the docker container.  At
/// runtime, an entry for `input_file` would be required in the inputs
/// map, such as:
///
/// ```
///   inputs["input_file"] = "gs://my-bucket/bar.txt"
/// ```
///
/// This would generate the following gsutil call:
///
/// ```
///   gsutil cp gs://my-bucket/bar.txt /mnt/pd1/file.txt
/// ```
///
/// The file `/mnt/pd1/file.txt` maps to `/mnt/disk/file.txt` in the
/// Docker container. Acceptable paths are:
///
/// <table>
///   <thead>
///     <tr><th>Google Cloud storage path</th><th>Local path</th></tr>
///   </thead>
///   <tbody>
///     <tr><td>file</td><td>file</td></tr>
///     <tr><td>glob</td><td>directory</td></tr>
///   </tbody>
/// </table>
///
/// For outputs, the direction of the copy is reversed:
///
/// ```
///   gsutil cp /mnt/disk/file.txt gs://my-bucket/bar.txt
/// ```
///
/// Acceptable paths are:
///
/// <table>
///   <thead>
///     <tr><th>Local path</th><th>Google Cloud Storage path</th></tr>
///   </thead>
///   <tbody>
///     <tr><td>file</td><td>file</td></tr>
///     <tr>
///       <td>file</td>
///       <td>directory - directory must already exist</td>
///     </tr>
///     <tr>
///       <td>glob</td>
///       <td>directory - directory will be created if it doesn't exist</td></tr>
///   </tbody>
/// </table>
///
/// One restriction due to docker limitations, is that for outputs that are found
/// on the boot disk, the local path cannot be a glob and must be a file.
public struct Google_Genomics_V1alpha2_PipelineParameter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Name of the parameter - the pipeline runner uses this string
  /// as the key to the input and output maps in RunPipeline.
  public var name: String = String()

  /// Human-readable description.
  public var description_p: String = String()

  /// The default value for this parameter. Can be overridden at runtime.
  /// If `localCopy` is present, then this must be a Google Cloud Storage path
  /// beginning with `gs://`.
  public var defaultValue: String = String()

  /// If present, this parameter is marked for copying to and from the VM.
  /// `LocalCopy` indicates where on the VM the file should be. The value
  /// given to this parameter (either at runtime or using `defaultValue`)
  /// must be the remote path where the file should be.
  public var localCopy: Google_Genomics_V1alpha2_PipelineParameter.LocalCopy {
    get {return _localCopy ?? Google_Genomics_V1alpha2_PipelineParameter.LocalCopy()}
    set {_localCopy = newValue}
  }
  /// Returns true if `localCopy` has been explicitly set.
  public var hasLocalCopy: Bool {return self._localCopy != nil}
  /// Clears the value of `localCopy`. Subsequent reads from it will return its default value.
  public mutating func clearLocalCopy() {self._localCopy = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// LocalCopy defines how a remote file should be copied to and from the VM.
  public struct LocalCopy {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. The path within the user's docker container where
    /// this input should be localized to and from, relative to the specified
    /// disk's mount point. For example: file.txt,
    public var path: String = String()

    /// Required. The name of the disk where this parameter is
    /// located. Can be the name of one of the disks specified in the
    /// Resources field, or "boot", which represents the Docker
    /// instance's boot disk and has a mount point of `/`.
    public var disk: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _localCopy: Google_Genomics_V1alpha2_PipelineParameter.LocalCopy? = nil
}

/// The Docker execuctor specification.
public struct Google_Genomics_V1alpha2_DockerExecutor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Image name from either Docker Hub or Google Container Registry.
  /// Users that run pipelines must have READ access to the image.
  public var imageName: String = String()

  /// Required. The command or newline delimited script to run. The command
  /// string will be executed within a bash shell.
  ///
  /// If the command exits with a non-zero exit code, output parameter
  /// de-localization will be skipped and the pipeline operation's
  /// [`error`][google.longrunning.Operation.error] field will be populated.
  ///
  /// Maximum command string length is 16384.
  public var cmd: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.genomics.v1alpha2"

extension Google_Genomics_V1alpha2_ComputeEngine: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ComputeEngine"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instance_name"),
    2: .same(proto: "zone"),
    3: .standard(proto: "machine_type"),
    4: .standard(proto: "disk_names"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.instanceName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.machineType) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.diskNames) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instanceName.isEmpty {
      try visitor.visitSingularStringField(value: self.instanceName, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.machineType.isEmpty {
      try visitor.visitSingularStringField(value: self.machineType, fieldNumber: 3)
    }
    if !self.diskNames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.diskNames, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1alpha2_ComputeEngine, rhs: Google_Genomics_V1alpha2_ComputeEngine) -> Bool {
    if lhs.instanceName != rhs.instanceName {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.machineType != rhs.machineType {return false}
    if lhs.diskNames != rhs.diskNames {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1alpha2_RuntimeMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RuntimeMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "compute_engine"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._computeEngine) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._computeEngine {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1alpha2_RuntimeMetadata, rhs: Google_Genomics_V1alpha2_RuntimeMetadata) -> Bool {
    if lhs._computeEngine != rhs._computeEngine {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1alpha2_Pipeline: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Pipeline"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "name"),
    3: .same(proto: "description"),
    8: .standard(proto: "input_parameters"),
    9: .standard(proto: "output_parameters"),
    5: .same(proto: "docker"),
    6: .same(proto: "resources"),
    7: .standard(proto: "pipeline_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 5: try {
        var v: Google_Genomics_V1alpha2_DockerExecutor?
        if let current = self.executor {
          try decoder.handleConflictingOneOf()
          if case .docker(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.executor = .docker(v)}
      }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._resources) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.pipelineID) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.inputParameters) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.outputParameters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if case .docker(let v)? = self.executor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._resources {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if !self.pipelineID.isEmpty {
      try visitor.visitSingularStringField(value: self.pipelineID, fieldNumber: 7)
    }
    if !self.inputParameters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputParameters, fieldNumber: 8)
    }
    if !self.outputParameters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputParameters, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1alpha2_Pipeline, rhs: Google_Genomics_V1alpha2_Pipeline) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.inputParameters != rhs.inputParameters {return false}
    if lhs.outputParameters != rhs.outputParameters {return false}
    if lhs.executor != rhs.executor {return false}
    if lhs._resources != rhs._resources {return false}
    if lhs.pipelineID != rhs.pipelineID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1alpha2_CreatePipelineRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreatePipelineRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pipeline"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pipeline) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._pipeline {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1alpha2_CreatePipelineRequest, rhs: Google_Genomics_V1alpha2_CreatePipelineRequest) -> Bool {
    if lhs._pipeline != rhs._pipeline {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1alpha2_RunPipelineArgs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RunPipelineArgs"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "inputs"),
    3: .same(proto: "outputs"),
    4: .standard(proto: "service_account"),
    5: .standard(proto: "client_id"),
    6: .same(proto: "resources"),
    7: .same(proto: "logging"),
    8: .standard(proto: "keep_vm_alive_on_failure_duration"),
    9: .same(proto: "labels"),
  ]

  fileprivate class _StorageClass {
    var _projectID: String = String()
    var _inputs: Dictionary<String,String> = [:]
    var _outputs: Dictionary<String,String> = [:]
    var _serviceAccount: Google_Genomics_V1alpha2_ServiceAccount? = nil
    var _clientID: String = String()
    var _resources: Google_Genomics_V1alpha2_PipelineResources? = nil
    var _logging: Google_Genomics_V1alpha2_LoggingOptions? = nil
    var _keepVmAliveOnFailureDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _labels: Dictionary<String,String> = [:]

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _projectID = source._projectID
      _inputs = source._inputs
      _outputs = source._outputs
      _serviceAccount = source._serviceAccount
      _clientID = source._clientID
      _resources = source._resources
      _logging = source._logging
      _keepVmAliveOnFailureDuration = source._keepVmAliveOnFailureDuration
      _labels = source._labels
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._projectID) }()
        case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._inputs) }()
        case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._outputs) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._serviceAccount) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._clientID) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._resources) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._logging) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._keepVmAliveOnFailureDuration) }()
        case 9: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._labels) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._projectID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._projectID, fieldNumber: 1)
      }
      if !_storage._inputs.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._inputs, fieldNumber: 2)
      }
      if !_storage._outputs.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._outputs, fieldNumber: 3)
      }
      if let v = _storage._serviceAccount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._clientID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._clientID, fieldNumber: 5)
      }
      if let v = _storage._resources {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._logging {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._keepVmAliveOnFailureDuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if !_storage._labels.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._labels, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1alpha2_RunPipelineArgs, rhs: Google_Genomics_V1alpha2_RunPipelineArgs) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._projectID != rhs_storage._projectID {return false}
        if _storage._inputs != rhs_storage._inputs {return false}
        if _storage._outputs != rhs_storage._outputs {return false}
        if _storage._serviceAccount != rhs_storage._serviceAccount {return false}
        if _storage._clientID != rhs_storage._clientID {return false}
        if _storage._resources != rhs_storage._resources {return false}
        if _storage._logging != rhs_storage._logging {return false}
        if _storage._keepVmAliveOnFailureDuration != rhs_storage._keepVmAliveOnFailureDuration {return false}
        if _storage._labels != rhs_storage._labels {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1alpha2_RunPipelineRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RunPipelineRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pipeline_id"),
    2: .standard(proto: "ephemeral_pipeline"),
    3: .standard(proto: "pipeline_args"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.pipeline != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.pipeline = .pipelineID(v)}
      }()
      case 2: try {
        var v: Google_Genomics_V1alpha2_Pipeline?
        if let current = self.pipeline {
          try decoder.handleConflictingOneOf()
          if case .ephemeralPipeline(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.pipeline = .ephemeralPipeline(v)}
      }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._pipelineArgs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.pipeline {
    case .pipelineID?: try {
      guard case .pipelineID(let v)? = self.pipeline else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .ephemeralPipeline?: try {
      guard case .ephemeralPipeline(let v)? = self.pipeline else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if let v = self._pipelineArgs {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1alpha2_RunPipelineRequest, rhs: Google_Genomics_V1alpha2_RunPipelineRequest) -> Bool {
    if lhs.pipeline != rhs.pipeline {return false}
    if lhs._pipelineArgs != rhs._pipelineArgs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1alpha2_GetPipelineRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPipelineRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pipeline_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pipelineID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pipelineID.isEmpty {
      try visitor.visitSingularStringField(value: self.pipelineID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1alpha2_GetPipelineRequest, rhs: Google_Genomics_V1alpha2_GetPipelineRequest) -> Bool {
    if lhs.pipelineID != rhs.pipelineID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1alpha2_ListPipelinesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListPipelinesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .standard(proto: "name_prefix"),
    3: .standard(proto: "page_size"),
    4: .standard(proto: "page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.namePrefix) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.namePrefix.isEmpty {
      try visitor.visitSingularStringField(value: self.namePrefix, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1alpha2_ListPipelinesRequest, rhs: Google_Genomics_V1alpha2_ListPipelinesRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.namePrefix != rhs.namePrefix {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1alpha2_ListPipelinesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListPipelinesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pipelines"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.pipelines) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pipelines.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pipelines, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1alpha2_ListPipelinesResponse, rhs: Google_Genomics_V1alpha2_ListPipelinesResponse) -> Bool {
    if lhs.pipelines != rhs.pipelines {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1alpha2_DeletePipelineRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeletePipelineRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pipeline_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pipelineID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pipelineID.isEmpty {
      try visitor.visitSingularStringField(value: self.pipelineID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1alpha2_DeletePipelineRequest, rhs: Google_Genomics_V1alpha2_DeletePipelineRequest) -> Bool {
    if lhs.pipelineID != rhs.pipelineID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1alpha2_GetControllerConfigRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetControllerConfigRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "operation_id"),
    2: .standard(proto: "validation_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.operationID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.validationToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.operationID.isEmpty {
      try visitor.visitSingularStringField(value: self.operationID, fieldNumber: 1)
    }
    if self.validationToken != 0 {
      try visitor.visitSingularUInt64Field(value: self.validationToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1alpha2_GetControllerConfigRequest, rhs: Google_Genomics_V1alpha2_GetControllerConfigRequest) -> Bool {
    if lhs.operationID != rhs.operationID {return false}
    if lhs.validationToken != rhs.validationToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1alpha2_ControllerConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ControllerConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "image"),
    2: .same(proto: "cmd"),
    3: .standard(proto: "gcs_log_path"),
    4: .standard(proto: "machine_type"),
    5: .same(proto: "vars"),
    6: .same(proto: "disks"),
    7: .standard(proto: "gcs_sources"),
    8: .standard(proto: "gcs_sinks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.image) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cmd) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.gcsLogPath) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.machineType) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.vars) }()
      case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.disks) }()
      case 7: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Genomics_V1alpha2_ControllerConfig.RepeatedString>.self, value: &self.gcsSources) }()
      case 8: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Genomics_V1alpha2_ControllerConfig.RepeatedString>.self, value: &self.gcsSinks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.image.isEmpty {
      try visitor.visitSingularStringField(value: self.image, fieldNumber: 1)
    }
    if !self.cmd.isEmpty {
      try visitor.visitSingularStringField(value: self.cmd, fieldNumber: 2)
    }
    if !self.gcsLogPath.isEmpty {
      try visitor.visitSingularStringField(value: self.gcsLogPath, fieldNumber: 3)
    }
    if !self.machineType.isEmpty {
      try visitor.visitSingularStringField(value: self.machineType, fieldNumber: 4)
    }
    if !self.vars.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.vars, fieldNumber: 5)
    }
    if !self.disks.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.disks, fieldNumber: 6)
    }
    if !self.gcsSources.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Genomics_V1alpha2_ControllerConfig.RepeatedString>.self, value: self.gcsSources, fieldNumber: 7)
    }
    if !self.gcsSinks.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Genomics_V1alpha2_ControllerConfig.RepeatedString>.self, value: self.gcsSinks, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1alpha2_ControllerConfig, rhs: Google_Genomics_V1alpha2_ControllerConfig) -> Bool {
    if lhs.image != rhs.image {return false}
    if lhs.cmd != rhs.cmd {return false}
    if lhs.gcsLogPath != rhs.gcsLogPath {return false}
    if lhs.machineType != rhs.machineType {return false}
    if lhs.vars != rhs.vars {return false}
    if lhs.disks != rhs.disks {return false}
    if lhs.gcsSources != rhs.gcsSources {return false}
    if lhs.gcsSinks != rhs.gcsSinks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1alpha2_ControllerConfig.RepeatedString: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Genomics_V1alpha2_ControllerConfig.protoMessageName + ".RepeatedString"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.values) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitRepeatedStringField(value: self.values, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1alpha2_ControllerConfig.RepeatedString, rhs: Google_Genomics_V1alpha2_ControllerConfig.RepeatedString) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1alpha2_TimestampEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TimestampEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "description"),
    2: .same(proto: "timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 1)
    }
    if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1alpha2_TimestampEvent, rhs: Google_Genomics_V1alpha2_TimestampEvent) -> Bool {
    if lhs.description_p != rhs.description_p {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1alpha2_SetOperationStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetOperationStatusRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "operation_id"),
    2: .standard(proto: "timestamp_events"),
    3: .standard(proto: "error_code"),
    4: .standard(proto: "error_message"),
    5: .standard(proto: "validation_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.operationID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.timestampEvents) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.errorCode) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.validationToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.operationID.isEmpty {
      try visitor.visitSingularStringField(value: self.operationID, fieldNumber: 1)
    }
    if !self.timestampEvents.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.timestampEvents, fieldNumber: 2)
    }
    if self.errorCode != .ok {
      try visitor.visitSingularEnumField(value: self.errorCode, fieldNumber: 3)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 4)
    }
    if self.validationToken != 0 {
      try visitor.visitSingularUInt64Field(value: self.validationToken, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1alpha2_SetOperationStatusRequest, rhs: Google_Genomics_V1alpha2_SetOperationStatusRequest) -> Bool {
    if lhs.operationID != rhs.operationID {return false}
    if lhs.timestampEvents != rhs.timestampEvents {return false}
    if lhs.errorCode != rhs.errorCode {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.validationToken != rhs.validationToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1alpha2_ServiceAccount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServiceAccount"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "email"),
    2: .same(proto: "scopes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.scopes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 1)
    }
    if !self.scopes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.scopes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1alpha2_ServiceAccount, rhs: Google_Genomics_V1alpha2_ServiceAccount) -> Bool {
    if lhs.email != rhs.email {return false}
    if lhs.scopes != rhs.scopes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1alpha2_LoggingOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoggingOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "gcs_path"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.gcsPath) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gcsPath.isEmpty {
      try visitor.visitSingularStringField(value: self.gcsPath, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1alpha2_LoggingOptions, rhs: Google_Genomics_V1alpha2_LoggingOptions) -> Bool {
    if lhs.gcsPath != rhs.gcsPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1alpha2_PipelineResources: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PipelineResources"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "minimum_cpu_cores"),
    2: .same(proto: "preemptible"),
    3: .standard(proto: "minimum_ram_gb"),
    4: .same(proto: "disks"),
    5: .same(proto: "zones"),
    6: .standard(proto: "boot_disk_size_gb"),
    7: .standard(proto: "no_address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.minimumCpuCores) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.preemptible) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.minimumRamGb) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.disks) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.zones) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.bootDiskSizeGb) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.noAddress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.minimumCpuCores != 0 {
      try visitor.visitSingularInt32Field(value: self.minimumCpuCores, fieldNumber: 1)
    }
    if self.preemptible != false {
      try visitor.visitSingularBoolField(value: self.preemptible, fieldNumber: 2)
    }
    if self.minimumRamGb != 0 {
      try visitor.visitSingularDoubleField(value: self.minimumRamGb, fieldNumber: 3)
    }
    if !self.disks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.disks, fieldNumber: 4)
    }
    if !self.zones.isEmpty {
      try visitor.visitRepeatedStringField(value: self.zones, fieldNumber: 5)
    }
    if self.bootDiskSizeGb != 0 {
      try visitor.visitSingularInt32Field(value: self.bootDiskSizeGb, fieldNumber: 6)
    }
    if self.noAddress != false {
      try visitor.visitSingularBoolField(value: self.noAddress, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1alpha2_PipelineResources, rhs: Google_Genomics_V1alpha2_PipelineResources) -> Bool {
    if lhs.minimumCpuCores != rhs.minimumCpuCores {return false}
    if lhs.preemptible != rhs.preemptible {return false}
    if lhs.minimumRamGb != rhs.minimumRamGb {return false}
    if lhs.disks != rhs.disks {return false}
    if lhs.zones != rhs.zones {return false}
    if lhs.bootDiskSizeGb != rhs.bootDiskSizeGb {return false}
    if lhs.noAddress != rhs.noAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1alpha2_PipelineResources.Disk: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Genomics_V1alpha2_PipelineResources.protoMessageName + ".Disk"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "type"),
    3: .standard(proto: "size_gb"),
    4: .same(proto: "source"),
    6: .standard(proto: "auto_delete"),
    8: .standard(proto: "mount_point"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.sizeGb) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.source) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.autoDelete) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.mountPoint) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if self.sizeGb != 0 {
      try visitor.visitSingularInt32Field(value: self.sizeGb, fieldNumber: 3)
    }
    if !self.source.isEmpty {
      try visitor.visitSingularStringField(value: self.source, fieldNumber: 4)
    }
    if self.autoDelete != false {
      try visitor.visitSingularBoolField(value: self.autoDelete, fieldNumber: 6)
    }
    if !self.mountPoint.isEmpty {
      try visitor.visitSingularStringField(value: self.mountPoint, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1alpha2_PipelineResources.Disk, rhs: Google_Genomics_V1alpha2_PipelineResources.Disk) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.sizeGb != rhs.sizeGb {return false}
    if lhs.source != rhs.source {return false}
    if lhs.autoDelete != rhs.autoDelete {return false}
    if lhs.mountPoint != rhs.mountPoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1alpha2_PipelineResources.Disk.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNSPECIFIED"),
    1: .same(proto: "PERSISTENT_HDD"),
    2: .same(proto: "PERSISTENT_SSD"),
    3: .same(proto: "LOCAL_SSD"),
  ]
}

extension Google_Genomics_V1alpha2_PipelineParameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PipelineParameter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "description"),
    5: .standard(proto: "default_value"),
    6: .standard(proto: "local_copy"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.defaultValue) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._localCopy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.defaultValue.isEmpty {
      try visitor.visitSingularStringField(value: self.defaultValue, fieldNumber: 5)
    }
    if let v = self._localCopy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1alpha2_PipelineParameter, rhs: Google_Genomics_V1alpha2_PipelineParameter) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.defaultValue != rhs.defaultValue {return false}
    if lhs._localCopy != rhs._localCopy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1alpha2_PipelineParameter.LocalCopy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Genomics_V1alpha2_PipelineParameter.protoMessageName + ".LocalCopy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .same(proto: "disk"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.disk) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    if !self.disk.isEmpty {
      try visitor.visitSingularStringField(value: self.disk, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1alpha2_PipelineParameter.LocalCopy, rhs: Google_Genomics_V1alpha2_PipelineParameter.LocalCopy) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.disk != rhs.disk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Genomics_V1alpha2_DockerExecutor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DockerExecutor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "image_name"),
    2: .same(proto: "cmd"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.imageName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cmd) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.imageName.isEmpty {
      try visitor.visitSingularStringField(value: self.imageName, fieldNumber: 1)
    }
    if !self.cmd.isEmpty {
      try visitor.visitSingularStringField(value: self.cmd, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Genomics_V1alpha2_DockerExecutor, rhs: Google_Genomics_V1alpha2_DockerExecutor) -> Bool {
    if lhs.imageName != rhs.imageName {return false}
    if lhs.cmd != rhs.cmd {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

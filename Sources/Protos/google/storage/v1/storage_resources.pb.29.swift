// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/storage/v1/storage_resources.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A bucket.
public struct Google_Storage_V1_Bucket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Access controls on the bucket.
  public var acl: [Google_Storage_V1_BucketAccessControl] {
    get {return _storage._acl}
    set {_uniqueStorage()._acl = newValue}
  }

  /// Default access controls to apply to new objects when no ACL is provided.
  public var defaultObjectAcl: [Google_Storage_V1_ObjectAccessControl] {
    get {return _storage._defaultObjectAcl}
    set {_uniqueStorage()._defaultObjectAcl = newValue}
  }

  /// The bucket's lifecycle configuration. See
  /// [https://developers.google.com/storage/docs/lifecycle]Lifecycle Management]
  /// for more information.
  public var lifecycle: Google_Storage_V1_Bucket.Lifecycle {
    get {return _storage._lifecycle ?? Google_Storage_V1_Bucket.Lifecycle()}
    set {_uniqueStorage()._lifecycle = newValue}
  }
  /// Returns true if `lifecycle` has been explicitly set.
  public var hasLifecycle: Bool {return _storage._lifecycle != nil}
  /// Clears the value of `lifecycle`. Subsequent reads from it will return its default value.
  public mutating func clearLifecycle() {_uniqueStorage()._lifecycle = nil}

  /// The creation time of the bucket in
  /// [https://tools.ietf.org/html/rfc3339][RFC 3339] format.
  /// Attempting to set this field will result in an error.
  public var timeCreated: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._timeCreated ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._timeCreated = newValue}
  }
  /// Returns true if `timeCreated` has been explicitly set.
  public var hasTimeCreated: Bool {return _storage._timeCreated != nil}
  /// Clears the value of `timeCreated`. Subsequent reads from it will return its default value.
  public mutating func clearTimeCreated() {_uniqueStorage()._timeCreated = nil}

  /// The ID of the bucket. For buckets, the `id` and `name` properties are the
  /// same.
  /// Attempting to update this field after the bucket is created will result in
  /// an error.
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// The name of the bucket.
  /// Attempting to update this field after the bucket is created will result in
  /// an error.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// The project number of the project the bucket belongs to.
  /// Attempting to set this field will result in an error.
  public var projectNumber: Int64 {
    get {return _storage._projectNumber}
    set {_uniqueStorage()._projectNumber = newValue}
  }

  /// The metadata generation of this bucket.
  /// Attempting to set this field will result in an error.
  public var metageneration: Int64 {
    get {return _storage._metageneration}
    set {_uniqueStorage()._metageneration = newValue}
  }

  /// The bucket's [https://www.w3.org/TR/cors/][Cross-Origin Resource Sharing]
  /// (CORS) configuration.
  public var cors: [Google_Storage_V1_Bucket.Cors] {
    get {return _storage._cors}
    set {_uniqueStorage()._cors = newValue}
  }

  /// The location of the bucket. Object data for objects in the bucket resides
  /// in physical storage within this region.  Defaults to `US`. See the
  /// [https://developers.google.com/storage/docs/concepts-techniques#specifyinglocations"][developer's
  /// guide] for the authoritative list. Attempting to update this field after
  /// the bucket is created will result in an error.
  public var location: String {
    get {return _storage._location}
    set {_uniqueStorage()._location = newValue}
  }

  /// The bucket's default storage class, used whenever no storageClass is
  /// specified for a newly-created object. This defines how objects in the
  /// bucket are stored and determines the SLA and the cost of storage.
  /// If this value is not specified when the bucket is created, it will default
  /// to `STANDARD`. For more information, see
  /// https://developers.google.com/storage/docs/storage-classes.
  public var storageClass: String {
    get {return _storage._storageClass}
    set {_uniqueStorage()._storageClass = newValue}
  }

  /// HTTP 1.1 [https://tools.ietf.org/html/rfc7232#section-2.3"]Entity tag]
  /// for the bucket.
  /// Attempting to set this field will result in an error.
  public var etag: String {
    get {return _storage._etag}
    set {_uniqueStorage()._etag = newValue}
  }

  /// The modification time of the bucket.
  /// Attempting to set this field will result in an error.
  public var updated: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updated ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updated = newValue}
  }
  /// Returns true if `updated` has been explicitly set.
  public var hasUpdated: Bool {return _storage._updated != nil}
  /// Clears the value of `updated`. Subsequent reads from it will return its default value.
  public mutating func clearUpdated() {_uniqueStorage()._updated = nil}

  /// The default value for event-based hold on newly created objects in this
  /// bucket.  Event-based hold is a way to retain objects indefinitely until an
  /// event occurs, signified by the
  /// hold's release. After being released, such objects will be subject to
  /// bucket-level retention (if any).  One sample use case of this flag is for
  /// banks to hold loan documents for at least 3 years after loan is paid in
  /// full. Here, bucket-level retention is 3 years and the event is loan being
  /// paid in full. In this example, these objects will be held intact for any
  /// number of years until the event has occurred (event-based hold on the
  /// object is released) and then 3 more years after that. That means retention
  /// duration of the objects begins from the moment event-based hold
  /// transitioned from true to false.  Objects under event-based hold cannot be
  /// deleted, overwritten or archived until the hold is removed.
  public var defaultEventBasedHold: Bool {
    get {return _storage._defaultEventBasedHold}
    set {_uniqueStorage()._defaultEventBasedHold = newValue}
  }

  /// User-provided labels, in key/value pairs.
  public var labels: Dictionary<String,String> {
    get {return _storage._labels}
    set {_uniqueStorage()._labels = newValue}
  }

  /// The bucket's website configuration, controlling how the service behaves
  /// when accessing bucket contents as a web site. See the
  /// [https://cloud.google.com/storage/docs/static-website][Static Website
  /// Examples] for more information.
  public var website: Google_Storage_V1_Bucket.Website {
    get {return _storage._website ?? Google_Storage_V1_Bucket.Website()}
    set {_uniqueStorage()._website = newValue}
  }
  /// Returns true if `website` has been explicitly set.
  public var hasWebsite: Bool {return _storage._website != nil}
  /// Clears the value of `website`. Subsequent reads from it will return its default value.
  public mutating func clearWebsite() {_uniqueStorage()._website = nil}

  /// The bucket's versioning configuration.
  public var versioning: Google_Storage_V1_Bucket.Versioning {
    get {return _storage._versioning ?? Google_Storage_V1_Bucket.Versioning()}
    set {_uniqueStorage()._versioning = newValue}
  }
  /// Returns true if `versioning` has been explicitly set.
  public var hasVersioning: Bool {return _storage._versioning != nil}
  /// Clears the value of `versioning`. Subsequent reads from it will return its default value.
  public mutating func clearVersioning() {_uniqueStorage()._versioning = nil}

  /// The bucket's logging configuration, which defines the destination bucket
  /// and optional name prefix for the current bucket's logs.
  public var logging: Google_Storage_V1_Bucket.Logging {
    get {return _storage._logging ?? Google_Storage_V1_Bucket.Logging()}
    set {_uniqueStorage()._logging = newValue}
  }
  /// Returns true if `logging` has been explicitly set.
  public var hasLogging: Bool {return _storage._logging != nil}
  /// Clears the value of `logging`. Subsequent reads from it will return its default value.
  public mutating func clearLogging() {_uniqueStorage()._logging = nil}

  /// The owner of the bucket. This is always the project team's owner group.
  public var owner: Google_Storage_V1_Owner {
    get {return _storage._owner ?? Google_Storage_V1_Owner()}
    set {_uniqueStorage()._owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return _storage._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {_uniqueStorage()._owner = nil}

  /// Encryption configuration for a bucket.
  public var encryption: Google_Storage_V1_Bucket.Encryption {
    get {return _storage._encryption ?? Google_Storage_V1_Bucket.Encryption()}
    set {_uniqueStorage()._encryption = newValue}
  }
  /// Returns true if `encryption` has been explicitly set.
  public var hasEncryption: Bool {return _storage._encryption != nil}
  /// Clears the value of `encryption`. Subsequent reads from it will return its default value.
  public mutating func clearEncryption() {_uniqueStorage()._encryption = nil}

  /// The bucket's billing configuration.
  public var billing: Google_Storage_V1_Bucket.Billing {
    get {return _storage._billing ?? Google_Storage_V1_Bucket.Billing()}
    set {_uniqueStorage()._billing = newValue}
  }
  /// Returns true if `billing` has been explicitly set.
  public var hasBilling: Bool {return _storage._billing != nil}
  /// Clears the value of `billing`. Subsequent reads from it will return its default value.
  public mutating func clearBilling() {_uniqueStorage()._billing = nil}

  /// The bucket's retention policy. The retention policy enforces a minimum
  /// retention time for all objects contained in the bucket, based on their
  /// creation time. Any attempt to overwrite or delete objects younger than the
  /// retention period will result in a PERMISSION_DENIED error.  An unlocked
  /// retention policy can be modified or removed from the bucket via a
  /// storage.buckets.update operation. A locked retention policy cannot be
  /// removed or shortened in duration for the lifetime of the bucket.
  /// Attempting to remove or decrease period of a locked retention policy will
  /// result in a PERMISSION_DENIED error.
  public var retentionPolicy: Google_Storage_V1_Bucket.RetentionPolicy {
    get {return _storage._retentionPolicy ?? Google_Storage_V1_Bucket.RetentionPolicy()}
    set {_uniqueStorage()._retentionPolicy = newValue}
  }
  /// Returns true if `retentionPolicy` has been explicitly set.
  public var hasRetentionPolicy: Bool {return _storage._retentionPolicy != nil}
  /// Clears the value of `retentionPolicy`. Subsequent reads from it will return its default value.
  public mutating func clearRetentionPolicy() {_uniqueStorage()._retentionPolicy = nil}

  /// The location type of the bucket (region, dual-region, multi-region, etc).
  public var locationType: String {
    get {return _storage._locationType}
    set {_uniqueStorage()._locationType = newValue}
  }

  /// The bucket's IAM configuration.
  public var iamConfiguration: Google_Storage_V1_Bucket.IamConfiguration {
    get {return _storage._iamConfiguration ?? Google_Storage_V1_Bucket.IamConfiguration()}
    set {_uniqueStorage()._iamConfiguration = newValue}
  }
  /// Returns true if `iamConfiguration` has been explicitly set.
  public var hasIamConfiguration: Bool {return _storage._iamConfiguration != nil}
  /// Clears the value of `iamConfiguration`. Subsequent reads from it will return its default value.
  public mutating func clearIamConfiguration() {_uniqueStorage()._iamConfiguration = nil}

  /// The zone or zones from which the bucket is intended to use zonal quota.
  /// Requests for data from outside the specified affinities are still allowed
  /// but won’t be able to use zonal quota. The values are case-insensitive.
  /// Attempting to update this field after bucket is created will result in an
  /// error.
  public var zoneAffinity: [String] {
    get {return _storage._zoneAffinity}
    set {_uniqueStorage()._zoneAffinity = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Billing properties of a bucket.
  public struct Billing {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// When set to true, Requester Pays is enabled for this bucket.
    public var requesterPays: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Cross-Origin Response sharing (CORS) properties for a bucket.
  /// For more on GCS and CORS, see
  /// https://cloud.google.com/storage/docs/cross-origin.
  /// For more on CORS in general, see https://tools.ietf.org/html/rfc6454.
  public struct Cors {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The list of Origins eligible to receive CORS response headers. See
    /// [https://tools.ietf.org/html/rfc6454][RFC 6454] for more on origins.
    /// Note: "*" is permitted in the list of origins, and means "any Origin".
    public var origin: [String] = []

    /// The list of HTTP methods on which to include CORS response headers,
    /// (`GET`, `OPTIONS`, `POST`, etc) Note: "*" is permitted in the list of
    /// methods, and means "any method".
    public var method: [String] = []

    /// The list of HTTP headers other than the
    /// [https://www.w3.org/TR/cors/#simple-response-header][simple response
    /// headers] to give permission for the user-agent to share across domains.
    public var responseHeader: [String] = []

    /// The value, in seconds, to return in the
    /// [https://www.w3.org/TR/cors/#access-control-max-age-response-header][Access-Control-Max-Age
    /// header] used in preflight responses.
    public var maxAgeSeconds: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Encryption properties of a bucket.
  public struct Encryption {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A Cloud KMS key that will be used to encrypt objects inserted into this
    /// bucket, if no encryption method is specified.
    public var defaultKmsKeyName: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Bucket restriction options currently enforced on the bucket.
  public struct IamConfiguration {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var uniformBucketLevelAccess: Google_Storage_V1_Bucket.IamConfiguration.UniformBucketLevelAccess {
      get {return _uniformBucketLevelAccess ?? Google_Storage_V1_Bucket.IamConfiguration.UniformBucketLevelAccess()}
      set {_uniformBucketLevelAccess = newValue}
    }
    /// Returns true if `uniformBucketLevelAccess` has been explicitly set.
    public var hasUniformBucketLevelAccess: Bool {return self._uniformBucketLevelAccess != nil}
    /// Clears the value of `uniformBucketLevelAccess`. Subsequent reads from it will return its default value.
    public mutating func clearUniformBucketLevelAccess() {self._uniformBucketLevelAccess = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct UniformBucketLevelAccess {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// If set, access checks only use bucket-level IAM policies or above.
      public var enabled: Bool = false

      /// The deadline time for changing
      /// <code>iamConfiguration.uniformBucketLevelAccess.enabled</code> from
      /// true to false in [https://tools.ietf.org/html/rfc3339][RFC 3339]. After
      /// the deadline is passed the field is immutable.
      public var lockedTime: SwiftProtobuf.Google_Protobuf_Timestamp {
        get {return _lockedTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
        set {_lockedTime = newValue}
      }
      /// Returns true if `lockedTime` has been explicitly set.
      public var hasLockedTime: Bool {return self._lockedTime != nil}
      /// Clears the value of `lockedTime`. Subsequent reads from it will return its default value.
      public mutating func clearLockedTime() {self._lockedTime = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _lockedTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    }

    public init() {}

    fileprivate var _uniformBucketLevelAccess: Google_Storage_V1_Bucket.IamConfiguration.UniformBucketLevelAccess? = nil
  }

  /// Lifecycle properties of a bucket.
  /// For more information, see https://cloud.google.com/storage/docs/lifecycle.
  public struct Lifecycle {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A lifecycle management rule, which is made of an action to take and the
    /// condition(s) under which the action will be taken.
    public var rule: [Google_Storage_V1_Bucket.Lifecycle.Rule] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// A lifecycle Rule, combining an action to take on an object and a
    /// condition which will trigger that action.
    public struct Rule {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The action to take.
      public var action: Google_Storage_V1_Bucket.Lifecycle.Rule.Action {
        get {return _action ?? Google_Storage_V1_Bucket.Lifecycle.Rule.Action()}
        set {_action = newValue}
      }
      /// Returns true if `action` has been explicitly set.
      public var hasAction: Bool {return self._action != nil}
      /// Clears the value of `action`. Subsequent reads from it will return its default value.
      public mutating func clearAction() {self._action = nil}

      /// The condition(s) under which the action will be taken.
      public var condition: Google_Storage_V1_Bucket.Lifecycle.Rule.Condition {
        get {return _condition ?? Google_Storage_V1_Bucket.Lifecycle.Rule.Condition()}
        set {_condition = newValue}
      }
      /// Returns true if `condition` has been explicitly set.
      public var hasCondition: Bool {return self._condition != nil}
      /// Clears the value of `condition`. Subsequent reads from it will return its default value.
      public mutating func clearCondition() {self._condition = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      /// An action to take on an object.
      public struct Action {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// Type of the action. Currently, only `Delete` and
        /// `SetStorageClass` are supported.
        public var type: String = String()

        /// Target storage class. Required iff the type of the action is
        /// SetStorageClass.
        public var storageClass: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      /// A condition of an object which triggers some action.
      public struct Condition {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// Age of an object (in days). This condition is satisfied when an
        /// object reaches the specified age.
        public var age: Int32 = 0

        /// A date in [RFC 3339][1] format with only the date part (for
        /// instance, "2013-01-15"). This condition is satisfied when an
        /// object is created before midnight of the specified date in UTC.
        /// [1]: https://tools.ietf.org/html/rfc3339
        public var createdBefore: SwiftProtobuf.Google_Protobuf_Timestamp {
          get {return _createdBefore ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
          set {_createdBefore = newValue}
        }
        /// Returns true if `createdBefore` has been explicitly set.
        public var hasCreatedBefore: Bool {return self._createdBefore != nil}
        /// Clears the value of `createdBefore`. Subsequent reads from it will return its default value.
        public mutating func clearCreatedBefore() {self._createdBefore = nil}

        /// Relevant only for versioned objects. If the value is
        /// `true`, this condition matches live objects; if the value
        /// is `false`, it matches archived objects.
        public var isLive: SwiftProtobuf.Google_Protobuf_BoolValue {
          get {return _isLive ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
          set {_isLive = newValue}
        }
        /// Returns true if `isLive` has been explicitly set.
        public var hasIsLive: Bool {return self._isLive != nil}
        /// Clears the value of `isLive`. Subsequent reads from it will return its default value.
        public mutating func clearIsLive() {self._isLive = nil}

        /// Relevant only for versioned objects. If the value is N, this
        /// condition is satisfied when there are at least N versions (including
        /// the live version) newer than this version of the object.
        public var numNewerVersions: Int32 = 0

        /// Objects having any of the storage classes specified by this condition
        /// will be matched. Values include `MULTI_REGIONAL`, `REGIONAL`,
        /// `NEARLINE`, `COLDLINE`, `STANDARD`, and
        /// `DURABLE_REDUCED_AVAILABILITY`.
        public var matchesStorageClass: [String] = []

        /// A regular expression that satisfies the RE2 syntax. This condition is
        /// satisfied when the name of the object matches the RE2 pattern.  Note:
        /// This feature is currently in the "Early Access" launch stage and is
        /// only available to a whitelisted set of users; that means that this
        /// feature may be changed in backward-incompatible ways and that it is
        /// not guaranteed to be released.
        public var matchesPattern: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _createdBefore: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
        fileprivate var _isLive: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
      }

      public init() {}

      fileprivate var _action: Google_Storage_V1_Bucket.Lifecycle.Rule.Action? = nil
      fileprivate var _condition: Google_Storage_V1_Bucket.Lifecycle.Rule.Condition? = nil
    }

    public init() {}
  }

  /// Logging-related properties of a bucket.
  public struct Logging {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The destination bucket where the current bucket's logs should be placed.
    public var logBucket: String = String()

    /// A prefix for log object names.
    public var logObjectPrefix: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Retention policy properties of a bucket.
  public struct RetentionPolicy {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Server-determined value that indicates the time from which policy was
    /// enforced and effective. This value is in
    /// [https://tools.ietf.org/html/rfc3339][RFC 3339] format.
    public var effectiveTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _effectiveTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_effectiveTime = newValue}
    }
    /// Returns true if `effectiveTime` has been explicitly set.
    public var hasEffectiveTime: Bool {return self._effectiveTime != nil}
    /// Clears the value of `effectiveTime`. Subsequent reads from it will return its default value.
    public mutating func clearEffectiveTime() {self._effectiveTime = nil}

    /// Once locked, an object retention policy cannot be modified.
    public var isLocked: Bool = false

    /// The duration in seconds that objects need to be retained. Retention
    /// duration must be greater than zero and less than 100 years. Note that
    /// enforcement of retention periods less than a day is not guaranteed. Such
    /// periods should only be used for testing purposes.
    public var retentionPeriod: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _effectiveTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }

  /// Properties of a bucket related to versioning.
  /// For more on GCS versioning, see
  /// https://cloud.google.com/storage/docs/object-versioning.
  public struct Versioning {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// While set to true, versioning is fully enabled for this bucket.
    public var enabled: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Properties of a bucket related to accessing the contents as a static
  /// website. For more on hosting a static website via GCS, see
  /// https://cloud.google.com/storage/docs/hosting-static-website.
  public struct Website {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// If the requested object path is missing, the service will ensure the path
    /// has a trailing '/', append this suffix, and attempt to retrieve the
    /// resulting object. This allows the creation of `index.html`
    /// objects to represent directory pages.
    public var mainPageSuffix: String = String()

    /// If the requested object path is missing, and any
    /// `mainPageSuffix` object is missing, if applicable, the service
    /// will return the named object from this bucket as the content for a
    /// [https://tools.ietf.org/html/rfc7231#section-6.5.4][404 Not Found]
    /// result.
    public var notFoundPage: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// An access-control entry.
public struct Google_Storage_V1_BucketAccessControl {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The access permission for the entity.
  public var role: String = String()

  /// HTTP 1.1 ["https://tools.ietf.org/html/rfc7232#section-2.3][Entity tag]
  /// for the access-control entry.
  public var etag: String = String()

  /// The ID of the access-control entry.
  public var id: String = String()

  /// The name of the bucket.
  public var bucket: String = String()

  /// The entity holding the permission, in one of the following forms:
  /// * `user-{userid}`
  /// * `user-{email}`
  /// * `group-{groupid}`
  /// * `group-{email}`
  /// * `domain-{domain}`
  /// * `project-{team-projectid}`
  /// * `allUsers`
  /// * `allAuthenticatedUsers`
  /// Examples:
  /// * The user `liz@example.com` would be `user-liz@example.com`.
  /// * The group `example@googlegroups.com` would be
  /// `group-example@googlegroups.com`
  /// * All members of the Google Apps for Business domain `example.com` would be
  /// `domain-example.com`
  public var entity: String = String()

  /// The ID for the entity, if any.
  public var entityID: String = String()

  /// The email address associated with the entity, if any.
  public var email: String = String()

  /// The domain associated with the entity, if any.
  public var domain: String = String()

  /// The project team associated with the entity, if any.
  public var projectTeam: Google_Storage_V1_ProjectTeam {
    get {return _projectTeam ?? Google_Storage_V1_ProjectTeam()}
    set {_projectTeam = newValue}
  }
  /// Returns true if `projectTeam` has been explicitly set.
  public var hasProjectTeam: Bool {return self._projectTeam != nil}
  /// Clears the value of `projectTeam`. Subsequent reads from it will return its default value.
  public mutating func clearProjectTeam() {self._projectTeam = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _projectTeam: Google_Storage_V1_ProjectTeam? = nil
}

/// The response to a call to BucketAccessControls.ListBucketAccessControls.
public struct Google_Storage_V1_ListBucketAccessControlsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of items.
  public var items: [Google_Storage_V1_BucketAccessControl] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The result of a call to Buckets.ListBuckets
public struct Google_Storage_V1_ListBucketsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of items.
  public var items: [Google_Storage_V1_Bucket] = []

  /// The continuation token, used to page through large result sets. Provide
  /// this value in a subsequent request to return the next page of results.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// An notification channel used to watch for resource changes.
public struct Google_Storage_V1_Channel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A UUID or similar unique string that identifies this channel.
  public var id: String = String()

  /// An opaque ID that identifies the resource being watched on this channel.
  /// Stable across different API versions.
  public var resourceID: String = String()

  /// A version-specific identifier for the watched resource.
  public var resourceUri: String = String()

  /// An arbitrary string delivered to the target address with each notification
  /// delivered over this channel. Optional.
  public var token: String = String()

  /// Date and time of notification channel expiration. Optional.
  public var expiration: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expiration ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expiration = newValue}
  }
  /// Returns true if `expiration` has been explicitly set.
  public var hasExpiration: Bool {return self._expiration != nil}
  /// Clears the value of `expiration`. Subsequent reads from it will return its default value.
  public mutating func clearExpiration() {self._expiration = nil}

  /// The type of delivery mechanism used for this channel.
  public var type: String = String()

  /// The address where notifications are delivered for this channel.
  public var address: String = String()

  /// Additional parameters controlling delivery channel behavior. Optional.
  public var params: Dictionary<String,String> = [:]

  /// A Boolean value to indicate whether payload is wanted. Optional.
  public var payload: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _expiration: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// The result of a call to Channels.ListChannels
public struct Google_Storage_V1_ListChannelsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of notification channels for a bucket.
  public var items: [Google_Storage_V1_ListChannelsResponse.Items] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Items {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// User-specified name for a channel. Needed to unsubscribe.
    public var channelID: String = String()

    /// Opaque value generated by GCS representing a bucket. Needed to
    /// unsubscribe.
    public var resourceID: String = String()

    /// Url used to identify where notifications are sent to.
    public var pushURL: String = String()

    /// Email address of the subscriber.
    public var subscriberEmail: String = String()

    /// Time when the channel was created.
    public var creationTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _creationTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_creationTime = newValue}
    }
    /// Returns true if `creationTime` has been explicitly set.
    public var hasCreationTime: Bool {return self._creationTime != nil}
    /// Clears the value of `creationTime`. Subsequent reads from it will return its default value.
    public mutating func clearCreationTime() {self._creationTime = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _creationTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }

  public init() {}
}

/// Message used to convey content being read or written, along with its
/// checksum.
public struct Google_Storage_V1_ChecksummedData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The data.
  public var content: Data = Data()

  /// CRC32C digest of the contents.
  public var crc32C: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _crc32C ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_crc32C = newValue}
  }
  /// Returns true if `crc32C` has been explicitly set.
  public var hasCrc32C: Bool {return self._crc32C != nil}
  /// Clears the value of `crc32C`. Subsequent reads from it will return its default value.
  public mutating func clearCrc32C() {self._crc32C = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _crc32C: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
}

/// Message used for storing full (not subrange) object checksums.
public struct Google_Storage_V1_ObjectChecksums {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// CRC32C digest of the object data. Computed by the GCS service for
  /// all written objects, and validated by the GCS service against
  /// client-supplied values if present in an InsertObjectRequest.
  public var crc32C: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _crc32C ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_crc32C = newValue}
  }
  /// Returns true if `crc32C` has been explicitly set.
  public var hasCrc32C: Bool {return self._crc32C != nil}
  /// Clears the value of `crc32C`. Subsequent reads from it will return its default value.
  public mutating func clearCrc32C() {self._crc32C = nil}

  /// Hex-encoded MD5 hash of the object data (hexdigest). Whether/how this
  /// checksum is provided and validated is service-dependent.
  public var md5Hash: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _crc32C: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
}

/// A collection of enums used in multiple places throughout the API.
public struct Google_Storage_V1_CommonEnums {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A set of properties to return in a response.
  public enum Projection: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// No specified projection.
    case unspecified // = 0

    /// Omit `owner`, `acl`, and `defaultObjectAcl` properties.
    case noAcl // = 1

    /// Include all properties.
    case full // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .noAcl
      case 2: self = .full
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .noAcl: return 1
      case .full: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Predefined or "canned" aliases for sets of specific bucket ACL entries.
  public enum PredefinedBucketAcl: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// No predefined ACL.
    case unspecified // = 0

    /// Project team owners get `OWNER` access, and
    /// `allAuthenticatedUsers` get `READER` access.
    case bucketAclAuthenticatedRead // = 1

    /// Project team owners get `OWNER` access.
    case bucketAclPrivate // = 2

    /// Project team members get access according to their roles.
    case bucketAclProjectPrivate // = 3

    /// Project team owners get `OWNER` access, and
    /// `allUsers` get `READER` access.
    case bucketAclPublicRead // = 4

    /// Project team owners get `OWNER` access, and
    /// `allUsers` get `WRITER` access.
    case bucketAclPublicReadWrite // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .bucketAclAuthenticatedRead
      case 2: self = .bucketAclPrivate
      case 3: self = .bucketAclProjectPrivate
      case 4: self = .bucketAclPublicRead
      case 5: self = .bucketAclPublicReadWrite
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .bucketAclAuthenticatedRead: return 1
      case .bucketAclPrivate: return 2
      case .bucketAclProjectPrivate: return 3
      case .bucketAclPublicRead: return 4
      case .bucketAclPublicReadWrite: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Predefined or "canned" aliases for sets of specific object ACL entries.
  public enum PredefinedObjectAcl: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// No predefined ACL.
    case unspecified // = 0

    /// Object owner gets `OWNER` access, and
    /// `allAuthenticatedUsers` get `READER` access.
    case objectAclAuthenticatedRead // = 1

    /// Object owner gets `OWNER` access, and project team owners get
    /// `OWNER` access.
    case objectAclBucketOwnerFullControl // = 2

    /// Object owner gets `OWNER` access, and project team owners get
    /// `READER` access.
    case objectAclBucketOwnerRead // = 3

    /// Object owner gets `OWNER` access.
    case objectAclPrivate // = 4

    /// Object owner gets `OWNER` access, and project team members get
    /// access according to their roles.
    case objectAclProjectPrivate // = 5

    /// Object owner gets `OWNER` access, and `allUsers`
    /// get `READER` access.
    case objectAclPublicRead // = 6
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .objectAclAuthenticatedRead
      case 2: self = .objectAclBucketOwnerFullControl
      case 3: self = .objectAclBucketOwnerRead
      case 4: self = .objectAclPrivate
      case 5: self = .objectAclProjectPrivate
      case 6: self = .objectAclPublicRead
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .objectAclAuthenticatedRead: return 1
      case .objectAclBucketOwnerFullControl: return 2
      case .objectAclBucketOwnerRead: return 3
      case .objectAclPrivate: return 4
      case .objectAclProjectPrivate: return 5
      case .objectAclPublicRead: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Storage_V1_CommonEnums.Projection: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Storage_V1_CommonEnums.Projection] = [
    .unspecified,
    .noAcl,
    .full,
  ]
}

extension Google_Storage_V1_CommonEnums.PredefinedBucketAcl: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Storage_V1_CommonEnums.PredefinedBucketAcl] = [
    .unspecified,
    .bucketAclAuthenticatedRead,
    .bucketAclPrivate,
    .bucketAclProjectPrivate,
    .bucketAclPublicRead,
    .bucketAclPublicReadWrite,
  ]
}

extension Google_Storage_V1_CommonEnums.PredefinedObjectAcl: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Storage_V1_CommonEnums.PredefinedObjectAcl] = [
    .unspecified,
    .objectAclAuthenticatedRead,
    .objectAclBucketOwnerFullControl,
    .objectAclBucketOwnerRead,
    .objectAclPrivate,
    .objectAclProjectPrivate,
    .objectAclPublicRead,
  ]
}

#endif  // swift(>=4.2)

/// Specifies a requested range of bytes to download.
public struct Google_Storage_V1_ContentRange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The starting offset of the object data.
  public var start: Int64 = 0

  /// The ending offset of the object data.
  public var end: Int64 = 0

  /// The complete length of the object data.
  public var completeLength: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Hmac Key Metadata, which includes all information other than the secret.
public struct Google_Storage_V1_HmacKeyMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Resource name ID of the key in the format <projectId>/<accessId>.
  public var id: String = String()

  /// Globally unique id for keys.
  public var accessID: String = String()

  /// The project ID that the hmac key is contained in.
  public var projectID: String = String()

  /// Email of the service account the key authenticates as.
  public var serviceAccountEmail: String = String()

  /// State of the key. One of ACTIVE, INACTIVE, or DELETED.
  public var state: String = String()

  /// The creation time of the HMAC key in RFC 3339 format.
  public var timeCreated: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timeCreated ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timeCreated = newValue}
  }
  /// Returns true if `timeCreated` has been explicitly set.
  public var hasTimeCreated: Bool {return self._timeCreated != nil}
  /// Clears the value of `timeCreated`. Subsequent reads from it will return its default value.
  public mutating func clearTimeCreated() {self._timeCreated = nil}

  /// The last modification time of the HMAC key metadata in RFC 3339 format.
  public var updated: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updated ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updated = newValue}
  }
  /// Returns true if `updated` has been explicitly set.
  public var hasUpdated: Bool {return self._updated != nil}
  /// Clears the value of `updated`. Subsequent reads from it will return its default value.
  public mutating func clearUpdated() {self._updated = nil}

  /// Tag updated with each key update.
  public var etag: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _timeCreated: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updated: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// A subscription to receive Google PubSub notifications.
public struct Google_Storage_V1_Notification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Cloud PubSub topic to which this subscription publishes. Formatted as:
  /// '//pubsub.googleapis.com/projects/{project-identifier}/topics/{my-topic}'
  public var topic: String = String()

  /// If present, only send notifications about listed event types. If empty,
  /// sent notifications for all event types.
  public var eventTypes: [String] = []

  /// An optional list of additional attributes to attach to each Cloud PubSub
  /// message published for this notification subscription.
  public var customAttributes: Dictionary<String,String> = [:]

  /// HTTP 1.1 [https://tools.ietf.org/html/rfc7232#section-2.3][Entity tag]
  /// for this subscription notification.
  public var etag: String = String()

  /// If present, only apply this notification configuration to object names that
  /// begin with this prefix.
  public var objectNamePrefix: String = String()

  /// The desired content of the Payload.
  public var payloadFormat: String = String()

  /// The ID of the notification.
  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The result of a call to Notifications.ListNotifications
public struct Google_Storage_V1_ListNotificationsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of items.
  public var items: [Google_Storage_V1_Notification] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// An object.
public struct Google_Storage_V1_Object {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Content-Encoding of the object data, matching
  /// [https://tools.ietf.org/html/rfc7231#section-3.1.2.2][RFC 7231 §3.1.2.2]
  public var contentEncoding: String {
    get {return _storage._contentEncoding}
    set {_uniqueStorage()._contentEncoding = newValue}
  }

  /// Content-Disposition of the object data, matching
  /// [https://tools.ietf.org/html/rfc6266][RFC 6266].
  public var contentDisposition: String {
    get {return _storage._contentDisposition}
    set {_uniqueStorage()._contentDisposition = newValue}
  }

  /// Cache-Control directive for the object data, matching
  /// [https://tools.ietf.org/html/rfc7234#section-5.2"][RFC 7234 §5.2].
  /// If omitted, and the object is accessible to all anonymous users, the
  /// default will be `public, max-age=3600`.
  public var cacheControl: String {
    get {return _storage._cacheControl}
    set {_uniqueStorage()._cacheControl = newValue}
  }

  /// Access controls on the object.
  public var acl: [Google_Storage_V1_ObjectAccessControl] {
    get {return _storage._acl}
    set {_uniqueStorage()._acl = newValue}
  }

  /// Content-Language of the object data, matching
  /// [https://tools.ietf.org/html/rfc7231#section-3.1.3.2][RFC 7231 §3.1.3.2].
  public var contentLanguage: String {
    get {return _storage._contentLanguage}
    set {_uniqueStorage()._contentLanguage = newValue}
  }

  /// The version of the metadata for this object at this generation. Used for
  /// preconditions and for detecting changes in metadata. A metageneration
  /// number is only meaningful in the context of a particular generation of a
  /// particular object.
  /// Attempting to set this field will result in an error.
  public var metageneration: Int64 {
    get {return _storage._metageneration}
    set {_uniqueStorage()._metageneration = newValue}
  }

  /// The deletion time of the object. Will be returned if and only if this
  /// version of the object has been deleted.
  /// Attempting to set this field will result in an error.
  public var timeDeleted: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._timeDeleted ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._timeDeleted = newValue}
  }
  /// Returns true if `timeDeleted` has been explicitly set.
  public var hasTimeDeleted: Bool {return _storage._timeDeleted != nil}
  /// Clears the value of `timeDeleted`. Subsequent reads from it will return its default value.
  public mutating func clearTimeDeleted() {_uniqueStorage()._timeDeleted = nil}

  /// Content-Type of the object data, matching
  /// [https://tools.ietf.org/html/rfc7231#section-3.1.1.5][RFC 7231 §3.1.1.5].
  /// If an object is stored without a Content-Type, it is served as
  /// `application/octet-stream`.
  public var contentType: String {
    get {return _storage._contentType}
    set {_uniqueStorage()._contentType = newValue}
  }

  /// Content-Length of the object data in bytes, matching
  /// [https://tools.ietf.org/html/rfc7230#section-3.3.2][RFC 7230 §3.3.2].
  /// Attempting to set this field will result in an error.
  public var size: Int64 {
    get {return _storage._size}
    set {_uniqueStorage()._size = newValue}
  }

  /// The creation time of the object.
  /// Attempting to set this field will result in an error.
  public var timeCreated: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._timeCreated ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._timeCreated = newValue}
  }
  /// Returns true if `timeCreated` has been explicitly set.
  public var hasTimeCreated: Bool {return _storage._timeCreated != nil}
  /// Clears the value of `timeCreated`. Subsequent reads from it will return its default value.
  public mutating func clearTimeCreated() {_uniqueStorage()._timeCreated = nil}

  /// CRC32c checksum. For more information about using the CRC32c
  /// checksum, see
  /// [https://cloud.google.com/storage/docs/hashes-etags#_JSONAPI][Hashes and
  /// ETags: Best Practices]. This is a server determined value and should not be
  /// supplied by the user when sending an Object. The server will ignore any
  /// value provided. Users should instead use the object_checksums field on the
  /// InsertObjectRequest when uploading an object.
  public var crc32C: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _storage._crc32C ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_uniqueStorage()._crc32C = newValue}
  }
  /// Returns true if `crc32C` has been explicitly set.
  public var hasCrc32C: Bool {return _storage._crc32C != nil}
  /// Clears the value of `crc32C`. Subsequent reads from it will return its default value.
  public mutating func clearCrc32C() {_uniqueStorage()._crc32C = nil}

  /// Number of underlying components that make up this object. Components are
  /// accumulated by compose operations.
  /// Attempting to set this field will result in an error.
  public var componentCount: Int32 {
    get {return _storage._componentCount}
    set {_uniqueStorage()._componentCount = newValue}
  }

  /// MD5 hash of the data; encoded using base64 as per
  /// [https://tools.ietf.org/html/rfc4648#section-4][RFC 4648 §4]. For more
  /// information about using the MD5 hash, see
  /// [https://cloud.google.com/storage/docs/hashes-etags#_JSONAPI][Hashes and
  /// ETags: Best Practices]. This is a server determined value and should not be
  /// supplied by the user when sending an Object. The server will ignore any
  /// value provided. Users should instead use the object_checksums field on the
  /// InsertObjectRequest when uploading an object.
  public var md5Hash: String {
    get {return _storage._md5Hash}
    set {_uniqueStorage()._md5Hash = newValue}
  }

  /// HTTP 1.1 Entity tag for the object. See
  /// [https://tools.ietf.org/html/rfc7232#section-2.3][RFC 7232 §2.3].
  /// Attempting to set this field will result in an error.
  public var etag: String {
    get {return _storage._etag}
    set {_uniqueStorage()._etag = newValue}
  }

  /// The modification time of the object metadata.
  /// Attempting to set this field will result in an error.
  public var updated: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updated ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updated = newValue}
  }
  /// Returns true if `updated` has been explicitly set.
  public var hasUpdated: Bool {return _storage._updated != nil}
  /// Clears the value of `updated`. Subsequent reads from it will return its default value.
  public mutating func clearUpdated() {_uniqueStorage()._updated = nil}

  /// Storage class of the object.
  public var storageClass: String {
    get {return _storage._storageClass}
    set {_uniqueStorage()._storageClass = newValue}
  }

  /// Cloud KMS Key used to encrypt this object, if the object is encrypted by
  /// such a key.
  public var kmsKeyName: String {
    get {return _storage._kmsKeyName}
    set {_uniqueStorage()._kmsKeyName = newValue}
  }

  /// The time at which the object's storage class was last changed. When the
  /// object is initially created, it will be set to time_created.
  /// Attempting to set this field will result in an error.
  public var timeStorageClassUpdated: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._timeStorageClassUpdated ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._timeStorageClassUpdated = newValue}
  }
  /// Returns true if `timeStorageClassUpdated` has been explicitly set.
  public var hasTimeStorageClassUpdated: Bool {return _storage._timeStorageClassUpdated != nil}
  /// Clears the value of `timeStorageClassUpdated`. Subsequent reads from it will return its default value.
  public mutating func clearTimeStorageClassUpdated() {_uniqueStorage()._timeStorageClassUpdated = nil}

  /// Whether an object is under temporary hold. While this flag is set to true,
  /// the object is protected against deletion and overwrites.  A common use case
  /// of this flag is regulatory investigations where objects need to be retained
  /// while the investigation is ongoing. Note that unlike event-based hold,
  /// temporary hold does not impact retention expiration time of an object.
  public var temporaryHold: Bool {
    get {return _storage._temporaryHold}
    set {_uniqueStorage()._temporaryHold = newValue}
  }

  /// A server-determined value that specifies the earliest time that the
  /// object's retention period expires. This value is in
  /// [https://tools.ietf.org/html/rfc3339][RFC 3339] format.
  /// Note 1: This field is not provided for objects with an active event-based
  /// hold, since retention expiration is unknown until the hold is removed.
  /// Note 2: This value can be provided even when temporary hold is set (so that
  /// the user can reason about policy without having to first unset the
  /// temporary hold).
  public var retentionExpirationTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._retentionExpirationTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._retentionExpirationTime = newValue}
  }
  /// Returns true if `retentionExpirationTime` has been explicitly set.
  public var hasRetentionExpirationTime: Bool {return _storage._retentionExpirationTime != nil}
  /// Clears the value of `retentionExpirationTime`. Subsequent reads from it will return its default value.
  public mutating func clearRetentionExpirationTime() {_uniqueStorage()._retentionExpirationTime = nil}

  /// User-provided metadata, in key/value pairs.
  public var metadata: Dictionary<String,String> {
    get {return _storage._metadata}
    set {_uniqueStorage()._metadata = newValue}
  }

  /// Whether an object is under event-based hold. Event-based hold is a way to
  /// retain objects until an event occurs, which is signified by the
  /// hold's release (i.e. this value is set to false). After being released (set
  /// to false), such objects will be subject to bucket-level retention (if any).
  /// One sample use case of this flag is for banks to hold loan documents for at
  /// least 3 years after loan is paid in full. Here, bucket-level retention is 3
  /// years and the event is the loan being paid in full. In this example, these
  /// objects will be held intact for any number of years until the event has
  /// occurred (event-based hold on the object is released) and then 3 more years
  /// after that. That means retention duration of the objects begins from the
  /// moment event-based hold transitioned from true to false.
  public var eventBasedHold: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._eventBasedHold ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._eventBasedHold = newValue}
  }
  /// Returns true if `eventBasedHold` has been explicitly set.
  public var hasEventBasedHold: Bool {return _storage._eventBasedHold != nil}
  /// Clears the value of `eventBasedHold`. Subsequent reads from it will return its default value.
  public mutating func clearEventBasedHold() {_uniqueStorage()._eventBasedHold = nil}

  /// The name of the object.
  /// Attempting to update this field after the object is created will result in
  /// an error.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// The ID of the object, including the bucket name, object name, and
  /// generation number.
  /// Attempting to update this field after the object is created will result in
  /// an error.
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// The name of the bucket containing this object.
  /// Attempting to update this field after the object is created will result in
  /// an error.
  public var bucket: String {
    get {return _storage._bucket}
    set {_uniqueStorage()._bucket = newValue}
  }

  /// The content generation of this object. Used for object versioning.
  /// Attempting to set this field will result in an error.
  public var generation: Int64 {
    get {return _storage._generation}
    set {_uniqueStorage()._generation = newValue}
  }

  /// The owner of the object. This will always be the uploader of the object.
  /// Attempting to set this field will result in an error.
  public var owner: Google_Storage_V1_Owner {
    get {return _storage._owner ?? Google_Storage_V1_Owner()}
    set {_uniqueStorage()._owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return _storage._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {_uniqueStorage()._owner = nil}

  /// Metadata of customer-supplied encryption key, if the object is encrypted by
  /// such a key.
  public var customerEncryption: Google_Storage_V1_Object.CustomerEncryption {
    get {return _storage._customerEncryption ?? Google_Storage_V1_Object.CustomerEncryption()}
    set {_uniqueStorage()._customerEncryption = newValue}
  }
  /// Returns true if `customerEncryption` has been explicitly set.
  public var hasCustomerEncryption: Bool {return _storage._customerEncryption != nil}
  /// Clears the value of `customerEncryption`. Subsequent reads from it will return its default value.
  public mutating func clearCustomerEncryption() {_uniqueStorage()._customerEncryption = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Describes the customer-specified mechanism used to store the data at rest.
  public struct CustomerEncryption {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The encryption algorithm.
    public var encryptionAlgorithm: String = String()

    /// SHA256 hash value of the encryption key.
    public var keySha256: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// An access-control entry.
public struct Google_Storage_V1_ObjectAccessControl {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The access permission for the entity.
  public var role: String = String()

  /// HTTP 1.1 Entity tag for the access-control entry.
  /// See [https://tools.ietf.org/html/rfc7232#section-2.3][RFC 7232 §2.3].
  public var etag: String = String()

  /// The ID of the access-control entry.
  public var id: String = String()

  /// The name of the bucket.
  public var bucket: String = String()

  /// The name of the object, if applied to an object.
  public var object: String = String()

  /// The content generation of the object, if applied to an object.
  public var generation: Int64 = 0

  /// The entity holding the permission, in one of the following forms:
  /// * `user-{userid}`
  /// * `user-{email}`
  /// * `group-{groupid}`
  /// * `group-{email}`
  /// * `domain-{domain}`
  /// * `project-{team-projectid}`
  /// * `allUsers`
  /// * `allAuthenticatedUsers`
  /// Examples:
  /// * The user `liz@example.com` would be `user-liz@example.com`.
  /// * The group `example@googlegroups.com` would be
  /// `group-example@googlegroups.com`.
  /// * All members of the Google Apps for Business domain `example.com` would be
  /// `domain-example.com`.
  public var entity: String = String()

  /// The ID for the entity, if any.
  public var entityID: String = String()

  /// The email address associated with the entity, if any.
  public var email: String = String()

  /// The domain associated with the entity, if any.
  public var domain: String = String()

  /// The project team associated with the entity, if any.
  public var projectTeam: Google_Storage_V1_ProjectTeam {
    get {return _projectTeam ?? Google_Storage_V1_ProjectTeam()}
    set {_projectTeam = newValue}
  }
  /// Returns true if `projectTeam` has been explicitly set.
  public var hasProjectTeam: Bool {return self._projectTeam != nil}
  /// Clears the value of `projectTeam`. Subsequent reads from it will return its default value.
  public mutating func clearProjectTeam() {self._projectTeam = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _projectTeam: Google_Storage_V1_ProjectTeam? = nil
}

/// The result of a call to ObjectAccessControls.ListObjectAccessControls.
public struct Google_Storage_V1_ListObjectAccessControlsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of items.
  public var items: [Google_Storage_V1_ObjectAccessControl] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The result of a call to Objects.ListObjects
public struct Google_Storage_V1_ListObjectsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of prefixes of objects matching-but-not-listed up to and including
  /// the requested delimiter.
  public var prefixes: [String] = []

  /// The list of items.
  public var items: [Google_Storage_V1_Object] = []

  /// The continuation token, used to page through large result sets. Provide
  /// this value in a subsequent request to return the next page of results.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Represents the Viewers, Editors, or Owners of a given project.
public struct Google_Storage_V1_ProjectTeam {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The project number.
  public var projectNumber: String = String()

  /// The team.
  public var team: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A subscription to receive Google PubSub notifications.
public struct Google_Storage_V1_ServiceAccount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the notification.
  public var emailAddress: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The owner of a specific resource.
public struct Google_Storage_V1_Owner {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The entity, in the form `user-`*userId*.
  public var entity: String = String()

  /// The ID for the entity.
  public var entityID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.storage.v1"

extension Google_Storage_V1_Bucket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Bucket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "acl"),
    2: .standard(proto: "default_object_acl"),
    3: .same(proto: "lifecycle"),
    4: .standard(proto: "time_created"),
    5: .same(proto: "id"),
    6: .same(proto: "name"),
    7: .standard(proto: "project_number"),
    8: .same(proto: "metageneration"),
    9: .same(proto: "cors"),
    10: .same(proto: "location"),
    11: .standard(proto: "storage_class"),
    12: .same(proto: "etag"),
    13: .same(proto: "updated"),
    14: .standard(proto: "default_event_based_hold"),
    15: .same(proto: "labels"),
    16: .same(proto: "website"),
    17: .same(proto: "versioning"),
    18: .same(proto: "logging"),
    19: .same(proto: "owner"),
    20: .same(proto: "encryption"),
    21: .same(proto: "billing"),
    22: .standard(proto: "retention_policy"),
    23: .standard(proto: "location_type"),
    24: .standard(proto: "iam_configuration"),
    25: .standard(proto: "zone_affinity"),
  ]

  fileprivate class _StorageClass {
    var _acl: [Google_Storage_V1_BucketAccessControl] = []
    var _defaultObjectAcl: [Google_Storage_V1_ObjectAccessControl] = []
    var _lifecycle: Google_Storage_V1_Bucket.Lifecycle? = nil
    var _timeCreated: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _id: String = String()
    var _name: String = String()
    var _projectNumber: Int64 = 0
    var _metageneration: Int64 = 0
    var _cors: [Google_Storage_V1_Bucket.Cors] = []
    var _location: String = String()
    var _storageClass: String = String()
    var _etag: String = String()
    var _updated: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _defaultEventBasedHold: Bool = false
    var _labels: Dictionary<String,String> = [:]
    var _website: Google_Storage_V1_Bucket.Website? = nil
    var _versioning: Google_Storage_V1_Bucket.Versioning? = nil
    var _logging: Google_Storage_V1_Bucket.Logging? = nil
    var _owner: Google_Storage_V1_Owner? = nil
    var _encryption: Google_Storage_V1_Bucket.Encryption? = nil
    var _billing: Google_Storage_V1_Bucket.Billing? = nil
    var _retentionPolicy: Google_Storage_V1_Bucket.RetentionPolicy? = nil
    var _locationType: String = String()
    var _iamConfiguration: Google_Storage_V1_Bucket.IamConfiguration? = nil
    var _zoneAffinity: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _acl = source._acl
      _defaultObjectAcl = source._defaultObjectAcl
      _lifecycle = source._lifecycle
      _timeCreated = source._timeCreated
      _id = source._id
      _name = source._name
      _projectNumber = source._projectNumber
      _metageneration = source._metageneration
      _cors = source._cors
      _location = source._location
      _storageClass = source._storageClass
      _etag = source._etag
      _updated = source._updated
      _defaultEventBasedHold = source._defaultEventBasedHold
      _labels = source._labels
      _website = source._website
      _versioning = source._versioning
      _logging = source._logging
      _owner = source._owner
      _encryption = source._encryption
      _billing = source._billing
      _retentionPolicy = source._retentionPolicy
      _locationType = source._locationType
      _iamConfiguration = source._iamConfiguration
      _zoneAffinity = source._zoneAffinity
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeRepeatedMessageField(value: &_storage._acl) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._defaultObjectAcl) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._lifecycle) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._timeCreated) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 7: try { try decoder.decodeSingularInt64Field(value: &_storage._projectNumber) }()
        case 8: try { try decoder.decodeSingularInt64Field(value: &_storage._metageneration) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._cors) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._location) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._storageClass) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._etag) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._updated) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._defaultEventBasedHold) }()
        case 15: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._labels) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._website) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._versioning) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._logging) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._owner) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._encryption) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._billing) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._retentionPolicy) }()
        case 23: try { try decoder.decodeSingularStringField(value: &_storage._locationType) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._iamConfiguration) }()
        case 25: try { try decoder.decodeRepeatedStringField(value: &_storage._zoneAffinity) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._acl.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._acl, fieldNumber: 1)
      }
      if !_storage._defaultObjectAcl.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._defaultObjectAcl, fieldNumber: 2)
      }
      if let v = _storage._lifecycle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._timeCreated {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 5)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 6)
      }
      if _storage._projectNumber != 0 {
        try visitor.visitSingularInt64Field(value: _storage._projectNumber, fieldNumber: 7)
      }
      if _storage._metageneration != 0 {
        try visitor.visitSingularInt64Field(value: _storage._metageneration, fieldNumber: 8)
      }
      if !_storage._cors.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._cors, fieldNumber: 9)
      }
      if !_storage._location.isEmpty {
        try visitor.visitSingularStringField(value: _storage._location, fieldNumber: 10)
      }
      if !_storage._storageClass.isEmpty {
        try visitor.visitSingularStringField(value: _storage._storageClass, fieldNumber: 11)
      }
      if !_storage._etag.isEmpty {
        try visitor.visitSingularStringField(value: _storage._etag, fieldNumber: 12)
      }
      if let v = _storage._updated {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if _storage._defaultEventBasedHold != false {
        try visitor.visitSingularBoolField(value: _storage._defaultEventBasedHold, fieldNumber: 14)
      }
      if !_storage._labels.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._labels, fieldNumber: 15)
      }
      if let v = _storage._website {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }
      if let v = _storage._versioning {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
      if let v = _storage._logging {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }
      if let v = _storage._owner {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }
      if let v = _storage._encryption {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }
      if let v = _storage._billing {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      }
      if let v = _storage._retentionPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      }
      if !_storage._locationType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._locationType, fieldNumber: 23)
      }
      if let v = _storage._iamConfiguration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      }
      if !_storage._zoneAffinity.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._zoneAffinity, fieldNumber: 25)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storage_V1_Bucket, rhs: Google_Storage_V1_Bucket) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._acl != rhs_storage._acl {return false}
        if _storage._defaultObjectAcl != rhs_storage._defaultObjectAcl {return false}
        if _storage._lifecycle != rhs_storage._lifecycle {return false}
        if _storage._timeCreated != rhs_storage._timeCreated {return false}
        if _storage._id != rhs_storage._id {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._projectNumber != rhs_storage._projectNumber {return false}
        if _storage._metageneration != rhs_storage._metageneration {return false}
        if _storage._cors != rhs_storage._cors {return false}
        if _storage._location != rhs_storage._location {return false}
        if _storage._storageClass != rhs_storage._storageClass {return false}
        if _storage._etag != rhs_storage._etag {return false}
        if _storage._updated != rhs_storage._updated {return false}
        if _storage._defaultEventBasedHold != rhs_storage._defaultEventBasedHold {return false}
        if _storage._labels != rhs_storage._labels {return false}
        if _storage._website != rhs_storage._website {return false}
        if _storage._versioning != rhs_storage._versioning {return false}
        if _storage._logging != rhs_storage._logging {return false}
        if _storage._owner != rhs_storage._owner {return false}
        if _storage._encryption != rhs_storage._encryption {return false}
        if _storage._billing != rhs_storage._billing {return false}
        if _storage._retentionPolicy != rhs_storage._retentionPolicy {return false}
        if _storage._locationType != rhs_storage._locationType {return false}
        if _storage._iamConfiguration != rhs_storage._iamConfiguration {return false}
        if _storage._zoneAffinity != rhs_storage._zoneAffinity {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storage_V1_Bucket.Billing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Storage_V1_Bucket.protoMessageName + ".Billing"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "requester_pays"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.requesterPays) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.requesterPays != false {
      try visitor.visitSingularBoolField(value: self.requesterPays, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storage_V1_Bucket.Billing, rhs: Google_Storage_V1_Bucket.Billing) -> Bool {
    if lhs.requesterPays != rhs.requesterPays {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storage_V1_Bucket.Cors: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Storage_V1_Bucket.protoMessageName + ".Cors"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "origin"),
    2: .same(proto: "method"),
    3: .standard(proto: "response_header"),
    4: .standard(proto: "max_age_seconds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.origin) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.method) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.responseHeader) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.maxAgeSeconds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.origin.isEmpty {
      try visitor.visitRepeatedStringField(value: self.origin, fieldNumber: 1)
    }
    if !self.method.isEmpty {
      try visitor.visitRepeatedStringField(value: self.method, fieldNumber: 2)
    }
    if !self.responseHeader.isEmpty {
      try visitor.visitRepeatedStringField(value: self.responseHeader, fieldNumber: 3)
    }
    if self.maxAgeSeconds != 0 {
      try visitor.visitSingularInt32Field(value: self.maxAgeSeconds, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storage_V1_Bucket.Cors, rhs: Google_Storage_V1_Bucket.Cors) -> Bool {
    if lhs.origin != rhs.origin {return false}
    if lhs.method != rhs.method {return false}
    if lhs.responseHeader != rhs.responseHeader {return false}
    if lhs.maxAgeSeconds != rhs.maxAgeSeconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storage_V1_Bucket.Encryption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Storage_V1_Bucket.protoMessageName + ".Encryption"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "default_kms_key_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.defaultKmsKeyName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.defaultKmsKeyName.isEmpty {
      try visitor.visitSingularStringField(value: self.defaultKmsKeyName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storage_V1_Bucket.Encryption, rhs: Google_Storage_V1_Bucket.Encryption) -> Bool {
    if lhs.defaultKmsKeyName != rhs.defaultKmsKeyName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storage_V1_Bucket.IamConfiguration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Storage_V1_Bucket.protoMessageName + ".IamConfiguration"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "uniform_bucket_level_access"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._uniformBucketLevelAccess) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._uniformBucketLevelAccess {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storage_V1_Bucket.IamConfiguration, rhs: Google_Storage_V1_Bucket.IamConfiguration) -> Bool {
    if lhs._uniformBucketLevelAccess != rhs._uniformBucketLevelAccess {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storage_V1_Bucket.IamConfiguration.UniformBucketLevelAccess: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Storage_V1_Bucket.IamConfiguration.protoMessageName + ".UniformBucketLevelAccess"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .standard(proto: "locked_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._lockedTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if let v = self._lockedTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storage_V1_Bucket.IamConfiguration.UniformBucketLevelAccess, rhs: Google_Storage_V1_Bucket.IamConfiguration.UniformBucketLevelAccess) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs._lockedTime != rhs._lockedTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storage_V1_Bucket.Lifecycle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Storage_V1_Bucket.protoMessageName + ".Lifecycle"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rule"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.rule) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rule.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rule, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storage_V1_Bucket.Lifecycle, rhs: Google_Storage_V1_Bucket.Lifecycle) -> Bool {
    if lhs.rule != rhs.rule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storage_V1_Bucket.Lifecycle.Rule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Storage_V1_Bucket.Lifecycle.protoMessageName + ".Rule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "condition"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._action) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._condition) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._action {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._condition {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storage_V1_Bucket.Lifecycle.Rule, rhs: Google_Storage_V1_Bucket.Lifecycle.Rule) -> Bool {
    if lhs._action != rhs._action {return false}
    if lhs._condition != rhs._condition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storage_V1_Bucket.Lifecycle.Rule.Action: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Storage_V1_Bucket.Lifecycle.Rule.protoMessageName + ".Action"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "storage_class"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.storageClass) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.storageClass.isEmpty {
      try visitor.visitSingularStringField(value: self.storageClass, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storage_V1_Bucket.Lifecycle.Rule.Action, rhs: Google_Storage_V1_Bucket.Lifecycle.Rule.Action) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.storageClass != rhs.storageClass {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storage_V1_Bucket.Lifecycle.Rule.Condition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Storage_V1_Bucket.Lifecycle.Rule.protoMessageName + ".Condition"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "age"),
    2: .standard(proto: "created_before"),
    3: .standard(proto: "is_live"),
    4: .standard(proto: "num_newer_versions"),
    5: .standard(proto: "matches_storage_class"),
    6: .standard(proto: "matches_pattern"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.age) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createdBefore) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._isLive) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.numNewerVersions) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.matchesStorageClass) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.matchesPattern) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.age != 0 {
      try visitor.visitSingularInt32Field(value: self.age, fieldNumber: 1)
    }
    if let v = self._createdBefore {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._isLive {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.numNewerVersions != 0 {
      try visitor.visitSingularInt32Field(value: self.numNewerVersions, fieldNumber: 4)
    }
    if !self.matchesStorageClass.isEmpty {
      try visitor.visitRepeatedStringField(value: self.matchesStorageClass, fieldNumber: 5)
    }
    if !self.matchesPattern.isEmpty {
      try visitor.visitSingularStringField(value: self.matchesPattern, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storage_V1_Bucket.Lifecycle.Rule.Condition, rhs: Google_Storage_V1_Bucket.Lifecycle.Rule.Condition) -> Bool {
    if lhs.age != rhs.age {return false}
    if lhs._createdBefore != rhs._createdBefore {return false}
    if lhs._isLive != rhs._isLive {return false}
    if lhs.numNewerVersions != rhs.numNewerVersions {return false}
    if lhs.matchesStorageClass != rhs.matchesStorageClass {return false}
    if lhs.matchesPattern != rhs.matchesPattern {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storage_V1_Bucket.Logging: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Storage_V1_Bucket.protoMessageName + ".Logging"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "log_bucket"),
    2: .standard(proto: "log_object_prefix"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.logBucket) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.logObjectPrefix) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.logBucket.isEmpty {
      try visitor.visitSingularStringField(value: self.logBucket, fieldNumber: 1)
    }
    if !self.logObjectPrefix.isEmpty {
      try visitor.visitSingularStringField(value: self.logObjectPrefix, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storage_V1_Bucket.Logging, rhs: Google_Storage_V1_Bucket.Logging) -> Bool {
    if lhs.logBucket != rhs.logBucket {return false}
    if lhs.logObjectPrefix != rhs.logObjectPrefix {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storage_V1_Bucket.RetentionPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Storage_V1_Bucket.protoMessageName + ".RetentionPolicy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "effective_time"),
    2: .standard(proto: "is_locked"),
    3: .standard(proto: "retention_period"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._effectiveTime) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isLocked) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.retentionPeriod) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._effectiveTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.isLocked != false {
      try visitor.visitSingularBoolField(value: self.isLocked, fieldNumber: 2)
    }
    if self.retentionPeriod != 0 {
      try visitor.visitSingularInt64Field(value: self.retentionPeriod, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storage_V1_Bucket.RetentionPolicy, rhs: Google_Storage_V1_Bucket.RetentionPolicy) -> Bool {
    if lhs._effectiveTime != rhs._effectiveTime {return false}
    if lhs.isLocked != rhs.isLocked {return false}
    if lhs.retentionPeriod != rhs.retentionPeriod {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storage_V1_Bucket.Versioning: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Storage_V1_Bucket.protoMessageName + ".Versioning"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storage_V1_Bucket.Versioning, rhs: Google_Storage_V1_Bucket.Versioning) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storage_V1_Bucket.Website: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Storage_V1_Bucket.protoMessageName + ".Website"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "main_page_suffix"),
    2: .standard(proto: "not_found_page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.mainPageSuffix) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.notFoundPage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mainPageSuffix.isEmpty {
      try visitor.visitSingularStringField(value: self.mainPageSuffix, fieldNumber: 1)
    }
    if !self.notFoundPage.isEmpty {
      try visitor.visitSingularStringField(value: self.notFoundPage, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storage_V1_Bucket.Website, rhs: Google_Storage_V1_Bucket.Website) -> Bool {
    if lhs.mainPageSuffix != rhs.mainPageSuffix {return false}
    if lhs.notFoundPage != rhs.notFoundPage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storage_V1_BucketAccessControl: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BucketAccessControl"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "role"),
    2: .same(proto: "etag"),
    3: .same(proto: "id"),
    4: .same(proto: "bucket"),
    6: .same(proto: "entity"),
    7: .standard(proto: "entity_id"),
    8: .same(proto: "email"),
    9: .same(proto: "domain"),
    10: .standard(proto: "project_team"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.role) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.etag) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.bucket) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.entity) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.entityID) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.domain) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._projectTeam) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.role.isEmpty {
      try visitor.visitSingularStringField(value: self.role, fieldNumber: 1)
    }
    if !self.etag.isEmpty {
      try visitor.visitSingularStringField(value: self.etag, fieldNumber: 2)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 3)
    }
    if !self.bucket.isEmpty {
      try visitor.visitSingularStringField(value: self.bucket, fieldNumber: 4)
    }
    if !self.entity.isEmpty {
      try visitor.visitSingularStringField(value: self.entity, fieldNumber: 6)
    }
    if !self.entityID.isEmpty {
      try visitor.visitSingularStringField(value: self.entityID, fieldNumber: 7)
    }
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 8)
    }
    if !self.domain.isEmpty {
      try visitor.visitSingularStringField(value: self.domain, fieldNumber: 9)
    }
    if let v = self._projectTeam {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storage_V1_BucketAccessControl, rhs: Google_Storage_V1_BucketAccessControl) -> Bool {
    if lhs.role != rhs.role {return false}
    if lhs.etag != rhs.etag {return false}
    if lhs.id != rhs.id {return false}
    if lhs.bucket != rhs.bucket {return false}
    if lhs.entity != rhs.entity {return false}
    if lhs.entityID != rhs.entityID {return false}
    if lhs.email != rhs.email {return false}
    if lhs.domain != rhs.domain {return false}
    if lhs._projectTeam != rhs._projectTeam {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storage_V1_ListBucketAccessControlsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListBucketAccessControlsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storage_V1_ListBucketAccessControlsResponse, rhs: Google_Storage_V1_ListBucketAccessControlsResponse) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storage_V1_ListBucketsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListBucketsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "items"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storage_V1_ListBucketsResponse, rhs: Google_Storage_V1_ListBucketsResponse) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storage_V1_Channel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Channel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "resource_id"),
    3: .standard(proto: "resource_uri"),
    4: .same(proto: "token"),
    5: .same(proto: "expiration"),
    6: .same(proto: "type"),
    7: .same(proto: "address"),
    8: .same(proto: "params"),
    9: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.resourceID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.resourceUri) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._expiration) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 8: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.params) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.payload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.resourceID.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceID, fieldNumber: 2)
    }
    if !self.resourceUri.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceUri, fieldNumber: 3)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 4)
    }
    if let v = self._expiration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 6)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 7)
    }
    if !self.params.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.params, fieldNumber: 8)
    }
    if self.payload != false {
      try visitor.visitSingularBoolField(value: self.payload, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storage_V1_Channel, rhs: Google_Storage_V1_Channel) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.resourceID != rhs.resourceID {return false}
    if lhs.resourceUri != rhs.resourceUri {return false}
    if lhs.token != rhs.token {return false}
    if lhs._expiration != rhs._expiration {return false}
    if lhs.type != rhs.type {return false}
    if lhs.address != rhs.address {return false}
    if lhs.params != rhs.params {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storage_V1_ListChannelsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListChannelsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storage_V1_ListChannelsResponse, rhs: Google_Storage_V1_ListChannelsResponse) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storage_V1_ListChannelsResponse.Items: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Storage_V1_ListChannelsResponse.protoMessageName + ".Items"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_id"),
    2: .standard(proto: "resource_id"),
    3: .standard(proto: "push_url"),
    4: .standard(proto: "subscriber_email"),
    5: .standard(proto: "creation_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.resourceID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pushURL) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.subscriberEmail) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._creationTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if !self.resourceID.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceID, fieldNumber: 2)
    }
    if !self.pushURL.isEmpty {
      try visitor.visitSingularStringField(value: self.pushURL, fieldNumber: 3)
    }
    if !self.subscriberEmail.isEmpty {
      try visitor.visitSingularStringField(value: self.subscriberEmail, fieldNumber: 4)
    }
    if let v = self._creationTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storage_V1_ListChannelsResponse.Items, rhs: Google_Storage_V1_ListChannelsResponse.Items) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.resourceID != rhs.resourceID {return false}
    if lhs.pushURL != rhs.pushURL {return false}
    if lhs.subscriberEmail != rhs.subscriberEmail {return false}
    if lhs._creationTime != rhs._creationTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storage_V1_ChecksummedData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChecksummedData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content"),
    2: .same(proto: "crc32c"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.content) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._crc32C) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.content.isEmpty {
      try visitor.visitSingularBytesField(value: self.content, fieldNumber: 1)
    }
    if let v = self._crc32C {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storage_V1_ChecksummedData, rhs: Google_Storage_V1_ChecksummedData) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs._crc32C != rhs._crc32C {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storage_V1_ObjectChecksums: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ObjectChecksums"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "crc32c"),
    2: .standard(proto: "md5_hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._crc32C) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.md5Hash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._crc32C {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.md5Hash.isEmpty {
      try visitor.visitSingularStringField(value: self.md5Hash, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storage_V1_ObjectChecksums, rhs: Google_Storage_V1_ObjectChecksums) -> Bool {
    if lhs._crc32C != rhs._crc32C {return false}
    if lhs.md5Hash != rhs.md5Hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storage_V1_CommonEnums: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommonEnums"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storage_V1_CommonEnums, rhs: Google_Storage_V1_CommonEnums) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storage_V1_CommonEnums.Projection: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PROJECTION_UNSPECIFIED"),
    1: .same(proto: "NO_ACL"),
    2: .same(proto: "FULL"),
  ]
}

extension Google_Storage_V1_CommonEnums.PredefinedBucketAcl: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PREDEFINED_BUCKET_ACL_UNSPECIFIED"),
    1: .same(proto: "BUCKET_ACL_AUTHENTICATED_READ"),
    2: .same(proto: "BUCKET_ACL_PRIVATE"),
    3: .same(proto: "BUCKET_ACL_PROJECT_PRIVATE"),
    4: .same(proto: "BUCKET_ACL_PUBLIC_READ"),
    5: .same(proto: "BUCKET_ACL_PUBLIC_READ_WRITE"),
  ]
}

extension Google_Storage_V1_CommonEnums.PredefinedObjectAcl: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PREDEFINED_OBJECT_ACL_UNSPECIFIED"),
    1: .same(proto: "OBJECT_ACL_AUTHENTICATED_READ"),
    2: .same(proto: "OBJECT_ACL_BUCKET_OWNER_FULL_CONTROL"),
    3: .same(proto: "OBJECT_ACL_BUCKET_OWNER_READ"),
    4: .same(proto: "OBJECT_ACL_PRIVATE"),
    5: .same(proto: "OBJECT_ACL_PROJECT_PRIVATE"),
    6: .same(proto: "OBJECT_ACL_PUBLIC_READ"),
  ]
}

extension Google_Storage_V1_ContentRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ContentRange"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "end"),
    3: .standard(proto: "complete_length"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.start) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.end) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.completeLength) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.start != 0 {
      try visitor.visitSingularInt64Field(value: self.start, fieldNumber: 1)
    }
    if self.end != 0 {
      try visitor.visitSingularInt64Field(value: self.end, fieldNumber: 2)
    }
    if self.completeLength != 0 {
      try visitor.visitSingularInt64Field(value: self.completeLength, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storage_V1_ContentRange, rhs: Google_Storage_V1_ContentRange) -> Bool {
    if lhs.start != rhs.start {return false}
    if lhs.end != rhs.end {return false}
    if lhs.completeLength != rhs.completeLength {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storage_V1_HmacKeyMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HmacKeyMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "access_id"),
    3: .standard(proto: "project_id"),
    4: .standard(proto: "service_account_email"),
    5: .same(proto: "state"),
    6: .standard(proto: "time_created"),
    7: .same(proto: "updated"),
    8: .same(proto: "etag"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.accessID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.serviceAccountEmail) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.state) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._timeCreated) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._updated) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.etag) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.accessID.isEmpty {
      try visitor.visitSingularStringField(value: self.accessID, fieldNumber: 2)
    }
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 3)
    }
    if !self.serviceAccountEmail.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceAccountEmail, fieldNumber: 4)
    }
    if !self.state.isEmpty {
      try visitor.visitSingularStringField(value: self.state, fieldNumber: 5)
    }
    if let v = self._timeCreated {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._updated {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if !self.etag.isEmpty {
      try visitor.visitSingularStringField(value: self.etag, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storage_V1_HmacKeyMetadata, rhs: Google_Storage_V1_HmacKeyMetadata) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.accessID != rhs.accessID {return false}
    if lhs.projectID != rhs.projectID {return false}
    if lhs.serviceAccountEmail != rhs.serviceAccountEmail {return false}
    if lhs.state != rhs.state {return false}
    if lhs._timeCreated != rhs._timeCreated {return false}
    if lhs._updated != rhs._updated {return false}
    if lhs.etag != rhs.etag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storage_V1_Notification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Notification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
    2: .standard(proto: "event_types"),
    3: .standard(proto: "custom_attributes"),
    4: .same(proto: "etag"),
    5: .standard(proto: "object_name_prefix"),
    6: .standard(proto: "payload_format"),
    7: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.eventTypes) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.customAttributes) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.etag) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.objectNamePrefix) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.payloadFormat) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 1)
    }
    if !self.eventTypes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.eventTypes, fieldNumber: 2)
    }
    if !self.customAttributes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.customAttributes, fieldNumber: 3)
    }
    if !self.etag.isEmpty {
      try visitor.visitSingularStringField(value: self.etag, fieldNumber: 4)
    }
    if !self.objectNamePrefix.isEmpty {
      try visitor.visitSingularStringField(value: self.objectNamePrefix, fieldNumber: 5)
    }
    if !self.payloadFormat.isEmpty {
      try visitor.visitSingularStringField(value: self.payloadFormat, fieldNumber: 6)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storage_V1_Notification, rhs: Google_Storage_V1_Notification) -> Bool {
    if lhs.topic != rhs.topic {return false}
    if lhs.eventTypes != rhs.eventTypes {return false}
    if lhs.customAttributes != rhs.customAttributes {return false}
    if lhs.etag != rhs.etag {return false}
    if lhs.objectNamePrefix != rhs.objectNamePrefix {return false}
    if lhs.payloadFormat != rhs.payloadFormat {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storage_V1_ListNotificationsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListNotificationsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storage_V1_ListNotificationsResponse, rhs: Google_Storage_V1_ListNotificationsResponse) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storage_V1_Object: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Object"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "content_encoding"),
    2: .standard(proto: "content_disposition"),
    3: .standard(proto: "cache_control"),
    4: .same(proto: "acl"),
    5: .standard(proto: "content_language"),
    6: .same(proto: "metageneration"),
    7: .standard(proto: "time_deleted"),
    8: .standard(proto: "content_type"),
    9: .same(proto: "size"),
    10: .standard(proto: "time_created"),
    11: .same(proto: "crc32c"),
    12: .standard(proto: "component_count"),
    13: .standard(proto: "md5_hash"),
    14: .same(proto: "etag"),
    15: .same(proto: "updated"),
    16: .standard(proto: "storage_class"),
    17: .standard(proto: "kms_key_name"),
    18: .standard(proto: "time_storage_class_updated"),
    19: .standard(proto: "temporary_hold"),
    20: .standard(proto: "retention_expiration_time"),
    21: .same(proto: "metadata"),
    29: .standard(proto: "event_based_hold"),
    23: .same(proto: "name"),
    24: .same(proto: "id"),
    25: .same(proto: "bucket"),
    26: .same(proto: "generation"),
    27: .same(proto: "owner"),
    28: .standard(proto: "customer_encryption"),
  ]

  fileprivate class _StorageClass {
    var _contentEncoding: String = String()
    var _contentDisposition: String = String()
    var _cacheControl: String = String()
    var _acl: [Google_Storage_V1_ObjectAccessControl] = []
    var _contentLanguage: String = String()
    var _metageneration: Int64 = 0
    var _timeDeleted: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _contentType: String = String()
    var _size: Int64 = 0
    var _timeCreated: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _crc32C: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
    var _componentCount: Int32 = 0
    var _md5Hash: String = String()
    var _etag: String = String()
    var _updated: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _storageClass: String = String()
    var _kmsKeyName: String = String()
    var _timeStorageClassUpdated: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _temporaryHold: Bool = false
    var _retentionExpirationTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _metadata: Dictionary<String,String> = [:]
    var _eventBasedHold: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _name: String = String()
    var _id: String = String()
    var _bucket: String = String()
    var _generation: Int64 = 0
    var _owner: Google_Storage_V1_Owner? = nil
    var _customerEncryption: Google_Storage_V1_Object.CustomerEncryption? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _contentEncoding = source._contentEncoding
      _contentDisposition = source._contentDisposition
      _cacheControl = source._cacheControl
      _acl = source._acl
      _contentLanguage = source._contentLanguage
      _metageneration = source._metageneration
      _timeDeleted = source._timeDeleted
      _contentType = source._contentType
      _size = source._size
      _timeCreated = source._timeCreated
      _crc32C = source._crc32C
      _componentCount = source._componentCount
      _md5Hash = source._md5Hash
      _etag = source._etag
      _updated = source._updated
      _storageClass = source._storageClass
      _kmsKeyName = source._kmsKeyName
      _timeStorageClassUpdated = source._timeStorageClassUpdated
      _temporaryHold = source._temporaryHold
      _retentionExpirationTime = source._retentionExpirationTime
      _metadata = source._metadata
      _eventBasedHold = source._eventBasedHold
      _name = source._name
      _id = source._id
      _bucket = source._bucket
      _generation = source._generation
      _owner = source._owner
      _customerEncryption = source._customerEncryption
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._contentEncoding) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._contentDisposition) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._cacheControl) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._acl) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._contentLanguage) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._metageneration) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._timeDeleted) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._contentType) }()
        case 9: try { try decoder.decodeSingularInt64Field(value: &_storage._size) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._timeCreated) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._crc32C) }()
        case 12: try { try decoder.decodeSingularInt32Field(value: &_storage._componentCount) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._md5Hash) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._etag) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._updated) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._storageClass) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._kmsKeyName) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._timeStorageClassUpdated) }()
        case 19: try { try decoder.decodeSingularBoolField(value: &_storage._temporaryHold) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._retentionExpirationTime) }()
        case 21: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._metadata) }()
        case 23: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 24: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 25: try { try decoder.decodeSingularStringField(value: &_storage._bucket) }()
        case 26: try { try decoder.decodeSingularInt64Field(value: &_storage._generation) }()
        case 27: try { try decoder.decodeSingularMessageField(value: &_storage._owner) }()
        case 28: try { try decoder.decodeSingularMessageField(value: &_storage._customerEncryption) }()
        case 29: try { try decoder.decodeSingularMessageField(value: &_storage._eventBasedHold) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._contentEncoding.isEmpty {
        try visitor.visitSingularStringField(value: _storage._contentEncoding, fieldNumber: 1)
      }
      if !_storage._contentDisposition.isEmpty {
        try visitor.visitSingularStringField(value: _storage._contentDisposition, fieldNumber: 2)
      }
      if !_storage._cacheControl.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cacheControl, fieldNumber: 3)
      }
      if !_storage._acl.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._acl, fieldNumber: 4)
      }
      if !_storage._contentLanguage.isEmpty {
        try visitor.visitSingularStringField(value: _storage._contentLanguage, fieldNumber: 5)
      }
      if _storage._metageneration != 0 {
        try visitor.visitSingularInt64Field(value: _storage._metageneration, fieldNumber: 6)
      }
      if let v = _storage._timeDeleted {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if !_storage._contentType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._contentType, fieldNumber: 8)
      }
      if _storage._size != 0 {
        try visitor.visitSingularInt64Field(value: _storage._size, fieldNumber: 9)
      }
      if let v = _storage._timeCreated {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._crc32C {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if _storage._componentCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._componentCount, fieldNumber: 12)
      }
      if !_storage._md5Hash.isEmpty {
        try visitor.visitSingularStringField(value: _storage._md5Hash, fieldNumber: 13)
      }
      if !_storage._etag.isEmpty {
        try visitor.visitSingularStringField(value: _storage._etag, fieldNumber: 14)
      }
      if let v = _storage._updated {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
      if !_storage._storageClass.isEmpty {
        try visitor.visitSingularStringField(value: _storage._storageClass, fieldNumber: 16)
      }
      if !_storage._kmsKeyName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._kmsKeyName, fieldNumber: 17)
      }
      if let v = _storage._timeStorageClassUpdated {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }
      if _storage._temporaryHold != false {
        try visitor.visitSingularBoolField(value: _storage._temporaryHold, fieldNumber: 19)
      }
      if let v = _storage._retentionExpirationTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }
      if !_storage._metadata.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._metadata, fieldNumber: 21)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 23)
      }
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 24)
      }
      if !_storage._bucket.isEmpty {
        try visitor.visitSingularStringField(value: _storage._bucket, fieldNumber: 25)
      }
      if _storage._generation != 0 {
        try visitor.visitSingularInt64Field(value: _storage._generation, fieldNumber: 26)
      }
      if let v = _storage._owner {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      }
      if let v = _storage._customerEncryption {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      }
      if let v = _storage._eventBasedHold {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storage_V1_Object, rhs: Google_Storage_V1_Object) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._contentEncoding != rhs_storage._contentEncoding {return false}
        if _storage._contentDisposition != rhs_storage._contentDisposition {return false}
        if _storage._cacheControl != rhs_storage._cacheControl {return false}
        if _storage._acl != rhs_storage._acl {return false}
        if _storage._contentLanguage != rhs_storage._contentLanguage {return false}
        if _storage._metageneration != rhs_storage._metageneration {return false}
        if _storage._timeDeleted != rhs_storage._timeDeleted {return false}
        if _storage._contentType != rhs_storage._contentType {return false}
        if _storage._size != rhs_storage._size {return false}
        if _storage._timeCreated != rhs_storage._timeCreated {return false}
        if _storage._crc32C != rhs_storage._crc32C {return false}
        if _storage._componentCount != rhs_storage._componentCount {return false}
        if _storage._md5Hash != rhs_storage._md5Hash {return false}
        if _storage._etag != rhs_storage._etag {return false}
        if _storage._updated != rhs_storage._updated {return false}
        if _storage._storageClass != rhs_storage._storageClass {return false}
        if _storage._kmsKeyName != rhs_storage._kmsKeyName {return false}
        if _storage._timeStorageClassUpdated != rhs_storage._timeStorageClassUpdated {return false}
        if _storage._temporaryHold != rhs_storage._temporaryHold {return false}
        if _storage._retentionExpirationTime != rhs_storage._retentionExpirationTime {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._eventBasedHold != rhs_storage._eventBasedHold {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._id != rhs_storage._id {return false}
        if _storage._bucket != rhs_storage._bucket {return false}
        if _storage._generation != rhs_storage._generation {return false}
        if _storage._owner != rhs_storage._owner {return false}
        if _storage._customerEncryption != rhs_storage._customerEncryption {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storage_V1_Object.CustomerEncryption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Storage_V1_Object.protoMessageName + ".CustomerEncryption"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "encryption_algorithm"),
    2: .standard(proto: "key_sha256"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.encryptionAlgorithm) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.keySha256) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.encryptionAlgorithm.isEmpty {
      try visitor.visitSingularStringField(value: self.encryptionAlgorithm, fieldNumber: 1)
    }
    if !self.keySha256.isEmpty {
      try visitor.visitSingularStringField(value: self.keySha256, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storage_V1_Object.CustomerEncryption, rhs: Google_Storage_V1_Object.CustomerEncryption) -> Bool {
    if lhs.encryptionAlgorithm != rhs.encryptionAlgorithm {return false}
    if lhs.keySha256 != rhs.keySha256 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storage_V1_ObjectAccessControl: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ObjectAccessControl"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "role"),
    2: .same(proto: "etag"),
    3: .same(proto: "id"),
    4: .same(proto: "bucket"),
    5: .same(proto: "object"),
    6: .same(proto: "generation"),
    7: .same(proto: "entity"),
    8: .standard(proto: "entity_id"),
    9: .same(proto: "email"),
    10: .same(proto: "domain"),
    11: .standard(proto: "project_team"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.role) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.etag) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.bucket) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.object) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.generation) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.entity) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.entityID) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.domain) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._projectTeam) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.role.isEmpty {
      try visitor.visitSingularStringField(value: self.role, fieldNumber: 1)
    }
    if !self.etag.isEmpty {
      try visitor.visitSingularStringField(value: self.etag, fieldNumber: 2)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 3)
    }
    if !self.bucket.isEmpty {
      try visitor.visitSingularStringField(value: self.bucket, fieldNumber: 4)
    }
    if !self.object.isEmpty {
      try visitor.visitSingularStringField(value: self.object, fieldNumber: 5)
    }
    if self.generation != 0 {
      try visitor.visitSingularInt64Field(value: self.generation, fieldNumber: 6)
    }
    if !self.entity.isEmpty {
      try visitor.visitSingularStringField(value: self.entity, fieldNumber: 7)
    }
    if !self.entityID.isEmpty {
      try visitor.visitSingularStringField(value: self.entityID, fieldNumber: 8)
    }
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 9)
    }
    if !self.domain.isEmpty {
      try visitor.visitSingularStringField(value: self.domain, fieldNumber: 10)
    }
    if let v = self._projectTeam {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storage_V1_ObjectAccessControl, rhs: Google_Storage_V1_ObjectAccessControl) -> Bool {
    if lhs.role != rhs.role {return false}
    if lhs.etag != rhs.etag {return false}
    if lhs.id != rhs.id {return false}
    if lhs.bucket != rhs.bucket {return false}
    if lhs.object != rhs.object {return false}
    if lhs.generation != rhs.generation {return false}
    if lhs.entity != rhs.entity {return false}
    if lhs.entityID != rhs.entityID {return false}
    if lhs.email != rhs.email {return false}
    if lhs.domain != rhs.domain {return false}
    if lhs._projectTeam != rhs._projectTeam {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storage_V1_ListObjectAccessControlsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListObjectAccessControlsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storage_V1_ListObjectAccessControlsResponse, rhs: Google_Storage_V1_ListObjectAccessControlsResponse) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storage_V1_ListObjectsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListObjectsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prefixes"),
    2: .same(proto: "items"),
    3: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.prefixes) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.prefixes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.prefixes, fieldNumber: 1)
    }
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 2)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storage_V1_ListObjectsResponse, rhs: Google_Storage_V1_ListObjectsResponse) -> Bool {
    if lhs.prefixes != rhs.prefixes {return false}
    if lhs.items != rhs.items {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storage_V1_ProjectTeam: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProjectTeam"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_number"),
    2: .same(proto: "team"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectNumber) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.team) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectNumber.isEmpty {
      try visitor.visitSingularStringField(value: self.projectNumber, fieldNumber: 1)
    }
    if !self.team.isEmpty {
      try visitor.visitSingularStringField(value: self.team, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storage_V1_ProjectTeam, rhs: Google_Storage_V1_ProjectTeam) -> Bool {
    if lhs.projectNumber != rhs.projectNumber {return false}
    if lhs.team != rhs.team {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storage_V1_ServiceAccount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServiceAccount"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "email_address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.emailAddress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.emailAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.emailAddress, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storage_V1_ServiceAccount, rhs: Google_Storage_V1_ServiceAccount) -> Bool {
    if lhs.emailAddress != rhs.emailAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storage_V1_Owner: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Owner"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entity"),
    2: .standard(proto: "entity_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.entity) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.entityID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entity.isEmpty {
      try visitor.visitSingularStringField(value: self.entity, fieldNumber: 1)
    }
    if !self.entityID.isEmpty {
      try visitor.visitSingularStringField(value: self.entityID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storage_V1_Owner, rhs: Google_Storage_V1_Owner) -> Bool {
    if lhs.entity != rhs.entity {return false}
    if lhs.entityID != rhs.entityID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/firestore/admin/v1beta1/firestore_admin.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The various possible states for an ongoing Operation.
public enum Google_Firestore_Admin_V1beta1_OperationState: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Unspecified.
  case stateUnspecified // = 0

  /// Request is being prepared for processing.
  case initializing // = 1

  /// Request is actively being processed.
  case processing // = 2

  /// Request is in the process of being cancelled after user called
  /// google.longrunning.Operations.CancelOperation on the operation.
  case cancelling // = 3

  /// Request has been processed and is in its finalization stage.
  case finalizing // = 4

  /// Request has completed successfully.
  case successful // = 5

  /// Request has finished being processed, but encountered an error.
  case failed // = 6

  /// Request has finished being cancelled after user called
  /// google.longrunning.Operations.CancelOperation.
  case cancelled // = 7
  case UNRECOGNIZED(Int)

  public init() {
    self = .stateUnspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .stateUnspecified
    case 1: self = .initializing
    case 2: self = .processing
    case 3: self = .cancelling
    case 4: self = .finalizing
    case 5: self = .successful
    case 6: self = .failed
    case 7: self = .cancelled
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .stateUnspecified: return 0
    case .initializing: return 1
    case .processing: return 2
    case .cancelling: return 3
    case .finalizing: return 4
    case .successful: return 5
    case .failed: return 6
    case .cancelled: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Firestore_Admin_V1beta1_OperationState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Firestore_Admin_V1beta1_OperationState] = [
    .stateUnspecified,
    .initializing,
    .processing,
    .cancelling,
    .finalizing,
    .successful,
    .failed,
    .cancelled,
  ]
}

#endif  // swift(>=4.2)

/// Metadata for index operations. This metadata populates
/// the metadata field of [google.longrunning.Operation][google.longrunning.Operation].
public struct Google_Firestore_Admin_V1beta1_IndexOperationMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The time that work began on the operation.
  public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {self._startTime = nil}

  /// The time the operation ended, either successfully or otherwise. Unset if
  /// the operation is still active.
  public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {self._endTime = nil}

  /// The index resource that this operation is acting on. For example:
  /// `projects/{project_id}/databases/{database_id}/indexes/{index_id}`
  public var index: String = String()

  /// The type of index operation.
  public var operationType: Google_Firestore_Admin_V1beta1_IndexOperationMetadata.OperationType = .unspecified

  /// True if the [google.longrunning.Operation] was cancelled. If the
  /// cancellation is in progress, cancelled will be true but
  /// [google.longrunning.Operation.done][google.longrunning.Operation.done] will be false.
  public var cancelled: Bool = false

  /// Progress of the existing operation, measured in number of documents.
  public var documentProgress: Google_Firestore_Admin_V1beta1_Progress {
    get {return _documentProgress ?? Google_Firestore_Admin_V1beta1_Progress()}
    set {_documentProgress = newValue}
  }
  /// Returns true if `documentProgress` has been explicitly set.
  public var hasDocumentProgress: Bool {return self._documentProgress != nil}
  /// Clears the value of `documentProgress`. Subsequent reads from it will return its default value.
  public mutating func clearDocumentProgress() {self._documentProgress = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The type of index operation.
  public enum OperationType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unspecified. Never set by server.
    case unspecified // = 0

    /// The operation is creating the index. Initiated by a `CreateIndex` call.
    case creatingIndex // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .creatingIndex
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .creatingIndex: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _documentProgress: Google_Firestore_Admin_V1beta1_Progress? = nil
}

#if swift(>=4.2)

extension Google_Firestore_Admin_V1beta1_IndexOperationMetadata.OperationType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Firestore_Admin_V1beta1_IndexOperationMetadata.OperationType] = [
    .unspecified,
    .creatingIndex,
  ]
}

#endif  // swift(>=4.2)

/// Measures the progress of a particular metric.
public struct Google_Firestore_Admin_V1beta1_Progress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An estimate of how much work has been completed. Note that this may be
  /// greater than `work_estimated`.
  public var workCompleted: Int64 = 0

  /// An estimate of how much work needs to be performed. Zero if the
  /// work estimate is unavailable. May change as work progresses.
  public var workEstimated: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request for [FirestoreAdmin.CreateIndex][google.firestore.admin.v1beta1.FirestoreAdmin.CreateIndex].
public struct Google_Firestore_Admin_V1beta1_CreateIndexRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the database this index will apply to. For example:
  /// `projects/{project_id}/databases/{database_id}`
  public var parent: String = String()

  /// The index to create. The name and state fields are output only and will be
  /// ignored. Certain single field indexes cannot be created or deleted.
  public var index: Google_Firestore_Admin_V1beta1_Index {
    get {return _index ?? Google_Firestore_Admin_V1beta1_Index()}
    set {_index = newValue}
  }
  /// Returns true if `index` has been explicitly set.
  public var hasIndex: Bool {return self._index != nil}
  /// Clears the value of `index`. Subsequent reads from it will return its default value.
  public mutating func clearIndex() {self._index = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _index: Google_Firestore_Admin_V1beta1_Index? = nil
}

/// The request for [FirestoreAdmin.GetIndex][google.firestore.admin.v1beta1.FirestoreAdmin.GetIndex].
public struct Google_Firestore_Admin_V1beta1_GetIndexRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the index. For example:
  /// `projects/{project_id}/databases/{database_id}/indexes/{index_id}`
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request for [FirestoreAdmin.ListIndexes][google.firestore.admin.v1beta1.FirestoreAdmin.ListIndexes].
public struct Google_Firestore_Admin_V1beta1_ListIndexesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The database name. For example:
  /// `projects/{project_id}/databases/{database_id}`
  public var parent: String = String()

  public var filter: String = String()

  /// The standard List page size.
  public var pageSize: Int32 = 0

  /// The standard List page token.
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request for [FirestoreAdmin.DeleteIndex][google.firestore.admin.v1beta1.FirestoreAdmin.DeleteIndex].
public struct Google_Firestore_Admin_V1beta1_DeleteIndexRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The index name. For example:
  /// `projects/{project_id}/databases/{database_id}/indexes/{index_id}`
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The response for [FirestoreAdmin.ListIndexes][google.firestore.admin.v1beta1.FirestoreAdmin.ListIndexes].
public struct Google_Firestore_Admin_V1beta1_ListIndexesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The indexes.
  public var indexes: [Google_Firestore_Admin_V1beta1_Index] = []

  /// The standard List next-page token.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request for [FirestoreAdmin.ExportDocuments][google.firestore.admin.v1beta1.FirestoreAdmin.ExportDocuments].
public struct Google_Firestore_Admin_V1beta1_ExportDocumentsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Database to export. Should be of the form:
  /// `projects/{project_id}/databases/{database_id}`.
  public var name: String = String()

  /// Which collection ids to export. Unspecified means all collections.
  public var collectionIds: [String] = []

  /// The output URI. Currently only supports Google Cloud Storage URIs of the
  /// form: `gs://BUCKET_NAME[/NAMESPACE_PATH]`, where `BUCKET_NAME` is the name
  /// of the Google Cloud Storage bucket and `NAMESPACE_PATH` is an optional
  /// Google Cloud Storage namespace path. When
  /// choosing a name, be sure to consider Google Cloud Storage naming
  /// guidelines: https://cloud.google.com/storage/docs/naming.
  /// If the URI is a bucket (without a namespace path), a prefix will be
  /// generated based on the start time.
  public var outputUriPrefix: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request for [FirestoreAdmin.ImportDocuments][google.firestore.admin.v1beta1.FirestoreAdmin.ImportDocuments].
public struct Google_Firestore_Admin_V1beta1_ImportDocumentsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Database to import into. Should be of the form:
  /// `projects/{project_id}/databases/{database_id}`.
  public var name: String = String()

  /// Which collection ids to import. Unspecified means all collections included
  /// in the import.
  public var collectionIds: [String] = []

  /// Location of the exported files.
  /// This must match the output_uri_prefix of an ExportDocumentsResponse from
  /// an export that has completed successfully.
  /// See:
  /// [google.firestore.admin.v1beta1.ExportDocumentsResponse.output_uri_prefix][google.firestore.admin.v1beta1.ExportDocumentsResponse.output_uri_prefix].
  public var inputUriPrefix: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Returned in the [google.longrunning.Operation][google.longrunning.Operation] response field.
public struct Google_Firestore_Admin_V1beta1_ExportDocumentsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Location of the output files. This can be used to begin an import
  /// into Cloud Firestore (this project or another project) after the operation
  /// completes successfully.
  public var outputUriPrefix: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Metadata for ExportDocuments operations.
public struct Google_Firestore_Admin_V1beta1_ExportDocumentsMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The time that work began on the operation.
  public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {self._startTime = nil}

  /// The time the operation ended, either successfully or otherwise. Unset if
  /// the operation is still active.
  public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {self._endTime = nil}

  /// The state of the export operation.
  public var operationState: Google_Firestore_Admin_V1beta1_OperationState = .stateUnspecified

  /// An estimate of the number of documents processed.
  public var progressDocuments: Google_Firestore_Admin_V1beta1_Progress {
    get {return _progressDocuments ?? Google_Firestore_Admin_V1beta1_Progress()}
    set {_progressDocuments = newValue}
  }
  /// Returns true if `progressDocuments` has been explicitly set.
  public var hasProgressDocuments: Bool {return self._progressDocuments != nil}
  /// Clears the value of `progressDocuments`. Subsequent reads from it will return its default value.
  public mutating func clearProgressDocuments() {self._progressDocuments = nil}

  /// An estimate of the number of bytes processed.
  public var progressBytes: Google_Firestore_Admin_V1beta1_Progress {
    get {return _progressBytes ?? Google_Firestore_Admin_V1beta1_Progress()}
    set {_progressBytes = newValue}
  }
  /// Returns true if `progressBytes` has been explicitly set.
  public var hasProgressBytes: Bool {return self._progressBytes != nil}
  /// Clears the value of `progressBytes`. Subsequent reads from it will return its default value.
  public mutating func clearProgressBytes() {self._progressBytes = nil}

  /// Which collection ids are being exported.
  public var collectionIds: [String] = []

  /// Where the entities are being exported to.
  public var outputUriPrefix: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _progressDocuments: Google_Firestore_Admin_V1beta1_Progress? = nil
  fileprivate var _progressBytes: Google_Firestore_Admin_V1beta1_Progress? = nil
}

/// Metadata for ImportDocuments operations.
public struct Google_Firestore_Admin_V1beta1_ImportDocumentsMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The time that work began on the operation.
  public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {self._startTime = nil}

  /// The time the operation ended, either successfully or otherwise. Unset if
  /// the operation is still active.
  public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {self._endTime = nil}

  /// The state of the import operation.
  public var operationState: Google_Firestore_Admin_V1beta1_OperationState = .stateUnspecified

  /// An estimate of the number of documents processed.
  public var progressDocuments: Google_Firestore_Admin_V1beta1_Progress {
    get {return _progressDocuments ?? Google_Firestore_Admin_V1beta1_Progress()}
    set {_progressDocuments = newValue}
  }
  /// Returns true if `progressDocuments` has been explicitly set.
  public var hasProgressDocuments: Bool {return self._progressDocuments != nil}
  /// Clears the value of `progressDocuments`. Subsequent reads from it will return its default value.
  public mutating func clearProgressDocuments() {self._progressDocuments = nil}

  /// An estimate of the number of bytes processed.
  public var progressBytes: Google_Firestore_Admin_V1beta1_Progress {
    get {return _progressBytes ?? Google_Firestore_Admin_V1beta1_Progress()}
    set {_progressBytes = newValue}
  }
  /// Returns true if `progressBytes` has been explicitly set.
  public var hasProgressBytes: Bool {return self._progressBytes != nil}
  /// Clears the value of `progressBytes`. Subsequent reads from it will return its default value.
  public mutating func clearProgressBytes() {self._progressBytes = nil}

  /// Which collection ids are being imported.
  public var collectionIds: [String] = []

  /// The location of the documents being imported.
  public var inputUriPrefix: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _progressDocuments: Google_Firestore_Admin_V1beta1_Progress? = nil
  fileprivate var _progressBytes: Google_Firestore_Admin_V1beta1_Progress? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.firestore.admin.v1beta1"

extension Google_Firestore_Admin_V1beta1_OperationState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNSPECIFIED"),
    1: .same(proto: "INITIALIZING"),
    2: .same(proto: "PROCESSING"),
    3: .same(proto: "CANCELLING"),
    4: .same(proto: "FINALIZING"),
    5: .same(proto: "SUCCESSFUL"),
    6: .same(proto: "FAILED"),
    7: .same(proto: "CANCELLED"),
  ]
}

extension Google_Firestore_Admin_V1beta1_IndexOperationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IndexOperationMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_time"),
    2: .standard(proto: "end_time"),
    3: .same(proto: "index"),
    4: .standard(proto: "operation_type"),
    5: .same(proto: "cancelled"),
    6: .standard(proto: "document_progress"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._endTime) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.index) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.operationType) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.cancelled) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._documentProgress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.index.isEmpty {
      try visitor.visitSingularStringField(value: self.index, fieldNumber: 3)
    }
    if self.operationType != .unspecified {
      try visitor.visitSingularEnumField(value: self.operationType, fieldNumber: 4)
    }
    if self.cancelled != false {
      try visitor.visitSingularBoolField(value: self.cancelled, fieldNumber: 5)
    }
    if let v = self._documentProgress {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_Admin_V1beta1_IndexOperationMetadata, rhs: Google_Firestore_Admin_V1beta1_IndexOperationMetadata) -> Bool {
    if lhs._startTime != rhs._startTime {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs.index != rhs.index {return false}
    if lhs.operationType != rhs.operationType {return false}
    if lhs.cancelled != rhs.cancelled {return false}
    if lhs._documentProgress != rhs._documentProgress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_Admin_V1beta1_IndexOperationMetadata.OperationType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OPERATION_TYPE_UNSPECIFIED"),
    1: .same(proto: "CREATING_INDEX"),
  ]
}

extension Google_Firestore_Admin_V1beta1_Progress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Progress"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "work_completed"),
    2: .standard(proto: "work_estimated"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.workCompleted) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.workEstimated) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.workCompleted != 0 {
      try visitor.visitSingularInt64Field(value: self.workCompleted, fieldNumber: 1)
    }
    if self.workEstimated != 0 {
      try visitor.visitSingularInt64Field(value: self.workEstimated, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_Admin_V1beta1_Progress, rhs: Google_Firestore_Admin_V1beta1_Progress) -> Bool {
    if lhs.workCompleted != rhs.workCompleted {return false}
    if lhs.workEstimated != rhs.workEstimated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_Admin_V1beta1_CreateIndexRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateIndexRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "index"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._index) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if let v = self._index {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_Admin_V1beta1_CreateIndexRequest, rhs: Google_Firestore_Admin_V1beta1_CreateIndexRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs._index != rhs._index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_Admin_V1beta1_GetIndexRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetIndexRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_Admin_V1beta1_GetIndexRequest, rhs: Google_Firestore_Admin_V1beta1_GetIndexRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_Admin_V1beta1_ListIndexesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListIndexesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "filter"),
    3: .standard(proto: "page_size"),
    4: .standard(proto: "page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_Admin_V1beta1_ListIndexesRequest, rhs: Google_Firestore_Admin_V1beta1_ListIndexesRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_Admin_V1beta1_DeleteIndexRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteIndexRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_Admin_V1beta1_DeleteIndexRequest, rhs: Google_Firestore_Admin_V1beta1_DeleteIndexRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_Admin_V1beta1_ListIndexesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListIndexesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "indexes"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.indexes) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.indexes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.indexes, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_Admin_V1beta1_ListIndexesResponse, rhs: Google_Firestore_Admin_V1beta1_ListIndexesResponse) -> Bool {
    if lhs.indexes != rhs.indexes {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_Admin_V1beta1_ExportDocumentsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExportDocumentsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    3: .standard(proto: "collection_ids"),
    4: .standard(proto: "output_uri_prefix"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.collectionIds) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.outputUriPrefix) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.collectionIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.collectionIds, fieldNumber: 3)
    }
    if !self.outputUriPrefix.isEmpty {
      try visitor.visitSingularStringField(value: self.outputUriPrefix, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_Admin_V1beta1_ExportDocumentsRequest, rhs: Google_Firestore_Admin_V1beta1_ExportDocumentsRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.collectionIds != rhs.collectionIds {return false}
    if lhs.outputUriPrefix != rhs.outputUriPrefix {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_Admin_V1beta1_ImportDocumentsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ImportDocumentsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    3: .standard(proto: "collection_ids"),
    4: .standard(proto: "input_uri_prefix"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.collectionIds) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.inputUriPrefix) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.collectionIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.collectionIds, fieldNumber: 3)
    }
    if !self.inputUriPrefix.isEmpty {
      try visitor.visitSingularStringField(value: self.inputUriPrefix, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_Admin_V1beta1_ImportDocumentsRequest, rhs: Google_Firestore_Admin_V1beta1_ImportDocumentsRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.collectionIds != rhs.collectionIds {return false}
    if lhs.inputUriPrefix != rhs.inputUriPrefix {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_Admin_V1beta1_ExportDocumentsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExportDocumentsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "output_uri_prefix"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.outputUriPrefix) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.outputUriPrefix.isEmpty {
      try visitor.visitSingularStringField(value: self.outputUriPrefix, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_Admin_V1beta1_ExportDocumentsResponse, rhs: Google_Firestore_Admin_V1beta1_ExportDocumentsResponse) -> Bool {
    if lhs.outputUriPrefix != rhs.outputUriPrefix {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_Admin_V1beta1_ExportDocumentsMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExportDocumentsMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_time"),
    2: .standard(proto: "end_time"),
    3: .standard(proto: "operation_state"),
    4: .standard(proto: "progress_documents"),
    5: .standard(proto: "progress_bytes"),
    6: .standard(proto: "collection_ids"),
    7: .standard(proto: "output_uri_prefix"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._endTime) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.operationState) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._progressDocuments) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._progressBytes) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.collectionIds) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.outputUriPrefix) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.operationState != .stateUnspecified {
      try visitor.visitSingularEnumField(value: self.operationState, fieldNumber: 3)
    }
    if let v = self._progressDocuments {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._progressBytes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.collectionIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.collectionIds, fieldNumber: 6)
    }
    if !self.outputUriPrefix.isEmpty {
      try visitor.visitSingularStringField(value: self.outputUriPrefix, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_Admin_V1beta1_ExportDocumentsMetadata, rhs: Google_Firestore_Admin_V1beta1_ExportDocumentsMetadata) -> Bool {
    if lhs._startTime != rhs._startTime {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs.operationState != rhs.operationState {return false}
    if lhs._progressDocuments != rhs._progressDocuments {return false}
    if lhs._progressBytes != rhs._progressBytes {return false}
    if lhs.collectionIds != rhs.collectionIds {return false}
    if lhs.outputUriPrefix != rhs.outputUriPrefix {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_Admin_V1beta1_ImportDocumentsMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ImportDocumentsMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_time"),
    2: .standard(proto: "end_time"),
    3: .standard(proto: "operation_state"),
    4: .standard(proto: "progress_documents"),
    5: .standard(proto: "progress_bytes"),
    6: .standard(proto: "collection_ids"),
    7: .standard(proto: "input_uri_prefix"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._endTime) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.operationState) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._progressDocuments) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._progressBytes) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.collectionIds) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.inputUriPrefix) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.operationState != .stateUnspecified {
      try visitor.visitSingularEnumField(value: self.operationState, fieldNumber: 3)
    }
    if let v = self._progressDocuments {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._progressBytes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.collectionIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.collectionIds, fieldNumber: 6)
    }
    if !self.inputUriPrefix.isEmpty {
      try visitor.visitSingularStringField(value: self.inputUriPrefix, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_Admin_V1beta1_ImportDocumentsMetadata, rhs: Google_Firestore_Admin_V1beta1_ImportDocumentsMetadata) -> Bool {
    if lhs._startTime != rhs._startTime {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs.operationState != rhs.operationState {return false}
    if lhs._progressDocuments != rhs._progressDocuments {return false}
    if lhs._progressBytes != rhs._progressBytes {return false}
    if lhs.collectionIds != rhs.collectionIds {return false}
    if lhs.inputUriPrefix != rhs.inputUriPrefix {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/firestore/bundle/bundle.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This file defines the format of Firestore bundle file/stream. It is not a part of the
// Firestore API, only a specification used by Server and Client SDK to write and read
// bundles.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Encodes a query saved in the bundle.
public struct Google_Firestore_Bundle_BundledQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The parent resource name.
  public var parent: String = String()

  /// The query to run.
  public var queryType: Google_Firestore_Bundle_BundledQuery.OneOf_QueryType? = nil

  /// A structured query.
  public var structuredQuery: Google_Firestore_V1_StructuredQuery {
    get {
      if case .structuredQuery(let v)? = queryType {return v}
      return Google_Firestore_V1_StructuredQuery()
    }
    set {queryType = .structuredQuery(newValue)}
  }

  public var limitType: Google_Firestore_Bundle_BundledQuery.LimitType = .first

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The query to run.
  public enum OneOf_QueryType: Equatable {
    /// A structured query.
    case structuredQuery(Google_Firestore_V1_StructuredQuery)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Firestore_Bundle_BundledQuery.OneOf_QueryType, rhs: Google_Firestore_Bundle_BundledQuery.OneOf_QueryType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.structuredQuery, .structuredQuery): return {
        guard case .structuredQuery(let l) = lhs, case .structuredQuery(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  /// If the query is a limit query, should the limit be applied to the beginning or
  /// the end of results.
  public enum LimitType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case first // = 0
    case last // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .first
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .first
      case 1: self = .last
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .first: return 0
      case .last: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Firestore_Bundle_BundledQuery.LimitType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Firestore_Bundle_BundledQuery.LimitType] = [
    .first,
    .last,
  ]
}

#endif  // swift(>=4.2)

/// A Query associated with a name, created as part of the bundle file, and can be read
/// by client SDKs once the bundle containing them is loaded.
public struct Google_Firestore_Bundle_NamedQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the query, such that client can use the name to load this query
  /// from bundle, and resume from when the query results are materialized
  /// into this bundle.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// The query saved in the bundle.
  public var bundledQuery: Google_Firestore_Bundle_BundledQuery {
    get {return _storage._bundledQuery ?? Google_Firestore_Bundle_BundledQuery()}
    set {_uniqueStorage()._bundledQuery = newValue}
  }
  /// Returns true if `bundledQuery` has been explicitly set.
  public var hasBundledQuery: Bool {return _storage._bundledQuery != nil}
  /// Clears the value of `bundledQuery`. Subsequent reads from it will return its default value.
  public mutating func clearBundledQuery() {_uniqueStorage()._bundledQuery = nil}

  /// The read time of the query, when it is used to build the bundle. This is useful to
  /// resume the query from the bundle, once it is loaded by client SDKs.
  public var readTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._readTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._readTime = newValue}
  }
  /// Returns true if `readTime` has been explicitly set.
  public var hasReadTime: Bool {return _storage._readTime != nil}
  /// Clears the value of `readTime`. Subsequent reads from it will return its default value.
  public mutating func clearReadTime() {_uniqueStorage()._readTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Metadata describing a Firestore document saved in the bundle.
public struct Google_Firestore_Bundle_BundledDocumentMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The document key of a bundled document.
  public var name: String = String()

  /// The snapshot version of the document data bundled.
  public var readTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _readTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_readTime = newValue}
  }
  /// Returns true if `readTime` has been explicitly set.
  public var hasReadTime: Bool {return self._readTime != nil}
  /// Clears the value of `readTime`. Subsequent reads from it will return its default value.
  public mutating func clearReadTime() {self._readTime = nil}

  /// Whether the document exists.
  public var exists: Bool = false

  /// The names of the queries in this bundle that this document matches to.
  public var queries: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _readTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Metadata describing the bundle file/stream.
public struct Google_Firestore_Bundle_BundleMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the bundle.
  public var id: String = String()

  /// Time at which the documents snapshot is taken for this bundle.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {self._createTime = nil}

  /// The schema version of the bundle.
  public var version: UInt32 = 0

  /// The number of documents in the bundle.
  public var totalDocuments: UInt32 = 0

  /// The size of the bundle in bytes, excluding this `BundleMetadata`.
  public var totalBytes: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// A Firestore bundle is a length-prefixed stream of JSON representations of
/// `BundleElement`.
/// Only one `BundleMetadata` is expected, and it should be the first element.
/// The named queries follow after `metadata`. Every `document_metadata` is
/// immediately followed by a `document`.
public struct Google_Firestore_Bundle_BundleElement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var elementType: Google_Firestore_Bundle_BundleElement.OneOf_ElementType? = nil

  public var metadata: Google_Firestore_Bundle_BundleMetadata {
    get {
      if case .metadata(let v)? = elementType {return v}
      return Google_Firestore_Bundle_BundleMetadata()
    }
    set {elementType = .metadata(newValue)}
  }

  public var namedQuery: Google_Firestore_Bundle_NamedQuery {
    get {
      if case .namedQuery(let v)? = elementType {return v}
      return Google_Firestore_Bundle_NamedQuery()
    }
    set {elementType = .namedQuery(newValue)}
  }

  public var documentMetadata: Google_Firestore_Bundle_BundledDocumentMetadata {
    get {
      if case .documentMetadata(let v)? = elementType {return v}
      return Google_Firestore_Bundle_BundledDocumentMetadata()
    }
    set {elementType = .documentMetadata(newValue)}
  }

  public var document: Google_Firestore_V1_Document {
    get {
      if case .document(let v)? = elementType {return v}
      return Google_Firestore_V1_Document()
    }
    set {elementType = .document(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_ElementType: Equatable {
    case metadata(Google_Firestore_Bundle_BundleMetadata)
    case namedQuery(Google_Firestore_Bundle_NamedQuery)
    case documentMetadata(Google_Firestore_Bundle_BundledDocumentMetadata)
    case document(Google_Firestore_V1_Document)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Firestore_Bundle_BundleElement.OneOf_ElementType, rhs: Google_Firestore_Bundle_BundleElement.OneOf_ElementType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.metadata, .metadata): return {
        guard case .metadata(let l) = lhs, case .metadata(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.namedQuery, .namedQuery): return {
        guard case .namedQuery(let l) = lhs, case .namedQuery(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.documentMetadata, .documentMetadata): return {
        guard case .documentMetadata(let l) = lhs, case .documentMetadata(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.document, .document): return {
        guard case .document(let l) = lhs, case .document(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.firestore.bundle"

extension Google_Firestore_Bundle_BundledQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BundledQuery"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "structured_query"),
    3: .standard(proto: "limit_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try {
        var v: Google_Firestore_V1_StructuredQuery?
        if let current = self.queryType {
          try decoder.handleConflictingOneOf()
          if case .structuredQuery(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.queryType = .structuredQuery(v)}
      }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.limitType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if case .structuredQuery(let v)? = self.queryType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.limitType != .first {
      try visitor.visitSingularEnumField(value: self.limitType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_Bundle_BundledQuery, rhs: Google_Firestore_Bundle_BundledQuery) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.queryType != rhs.queryType {return false}
    if lhs.limitType != rhs.limitType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_Bundle_BundledQuery.LimitType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FIRST"),
    1: .same(proto: "LAST"),
  ]
}

extension Google_Firestore_Bundle_NamedQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NamedQuery"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "bundled_query"),
    3: .standard(proto: "read_time"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _bundledQuery: Google_Firestore_Bundle_BundledQuery? = nil
    var _readTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _bundledQuery = source._bundledQuery
      _readTime = source._readTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._bundledQuery) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._readTime) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if let v = _storage._bundledQuery {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._readTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_Bundle_NamedQuery, rhs: Google_Firestore_Bundle_NamedQuery) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._bundledQuery != rhs_storage._bundledQuery {return false}
        if _storage._readTime != rhs_storage._readTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_Bundle_BundledDocumentMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BundledDocumentMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "read_time"),
    3: .same(proto: "exists"),
    4: .same(proto: "queries"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._readTime) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.exists) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.queries) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._readTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.exists != false {
      try visitor.visitSingularBoolField(value: self.exists, fieldNumber: 3)
    }
    if !self.queries.isEmpty {
      try visitor.visitRepeatedStringField(value: self.queries, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_Bundle_BundledDocumentMetadata, rhs: Google_Firestore_Bundle_BundledDocumentMetadata) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._readTime != rhs._readTime {return false}
    if lhs.exists != rhs.exists {return false}
    if lhs.queries != rhs.queries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_Bundle_BundleMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BundleMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "create_time"),
    3: .same(proto: "version"),
    4: .standard(proto: "total_documents"),
    5: .standard(proto: "total_bytes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.version) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.totalDocuments) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.totalBytes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.version != 0 {
      try visitor.visitSingularUInt32Field(value: self.version, fieldNumber: 3)
    }
    if self.totalDocuments != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalDocuments, fieldNumber: 4)
    }
    if self.totalBytes != 0 {
      try visitor.visitSingularUInt64Field(value: self.totalBytes, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_Bundle_BundleMetadata, rhs: Google_Firestore_Bundle_BundleMetadata) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs.version != rhs.version {return false}
    if lhs.totalDocuments != rhs.totalDocuments {return false}
    if lhs.totalBytes != rhs.totalBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_Bundle_BundleElement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BundleElement"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .standard(proto: "named_query"),
    3: .standard(proto: "document_metadata"),
    4: .same(proto: "document"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Firestore_Bundle_BundleMetadata?
        if let current = self.elementType {
          try decoder.handleConflictingOneOf()
          if case .metadata(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.elementType = .metadata(v)}
      }()
      case 2: try {
        var v: Google_Firestore_Bundle_NamedQuery?
        if let current = self.elementType {
          try decoder.handleConflictingOneOf()
          if case .namedQuery(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.elementType = .namedQuery(v)}
      }()
      case 3: try {
        var v: Google_Firestore_Bundle_BundledDocumentMetadata?
        if let current = self.elementType {
          try decoder.handleConflictingOneOf()
          if case .documentMetadata(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.elementType = .documentMetadata(v)}
      }()
      case 4: try {
        var v: Google_Firestore_V1_Document?
        if let current = self.elementType {
          try decoder.handleConflictingOneOf()
          if case .document(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.elementType = .document(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.elementType {
    case .metadata?: try {
      guard case .metadata(let v)? = self.elementType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .namedQuery?: try {
      guard case .namedQuery(let v)? = self.elementType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .documentMetadata?: try {
      guard case .documentMetadata(let v)? = self.elementType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .document?: try {
      guard case .document(let v)? = self.elementType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_Bundle_BundleElement, rhs: Google_Firestore_Bundle_BundleElement) -> Bool {
    if lhs.elementType != rhs.elementType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

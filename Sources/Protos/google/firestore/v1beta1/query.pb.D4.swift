// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/firestore/v1beta1/query.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A Firestore query.
public struct Google_Firestore_V1beta1_StructuredQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The projection to return.
  public var select: Google_Firestore_V1beta1_StructuredQuery.Projection {
    get {return _select ?? Google_Firestore_V1beta1_StructuredQuery.Projection()}
    set {_select = newValue}
  }
  /// Returns true if `select` has been explicitly set.
  public var hasSelect: Bool {return self._select != nil}
  /// Clears the value of `select`. Subsequent reads from it will return its default value.
  public mutating func clearSelect() {self._select = nil}

  /// The collections to query.
  public var from: [Google_Firestore_V1beta1_StructuredQuery.CollectionSelector] = []

  /// The filter to apply.
  public var `where`: Google_Firestore_V1beta1_StructuredQuery.Filter {
    get {return _where ?? Google_Firestore_V1beta1_StructuredQuery.Filter()}
    set {_where = newValue}
  }
  /// Returns true if ``where`` has been explicitly set.
  public var hasWhere: Bool {return self._where != nil}
  /// Clears the value of ``where``. Subsequent reads from it will return its default value.
  public mutating func clearWhere() {self._where = nil}

  /// The order to apply to the query results.
  ///
  /// Firestore guarantees a stable ordering through the following rules:
  ///
  ///  * Any field required to appear in `order_by`, that is not already
  ///    specified in `order_by`, is appended to the order in field name order
  ///    by default.
  ///  * If an order on `__name__` is not specified, it is appended by default.
  ///
  /// Fields are appended with the same sort direction as the last order
  /// specified, or 'ASCENDING' if no order was specified. For example:
  ///
  ///  * `SELECT * FROM Foo ORDER BY A` becomes
  ///    `SELECT * FROM Foo ORDER BY A, __name__`
  ///  * `SELECT * FROM Foo ORDER BY A DESC` becomes
  ///    `SELECT * FROM Foo ORDER BY A DESC, __name__ DESC`
  ///  * `SELECT * FROM Foo WHERE A > 1` becomes
  ///    `SELECT * FROM Foo WHERE A > 1 ORDER BY A, __name__`
  public var orderBy: [Google_Firestore_V1beta1_StructuredQuery.Order] = []

  /// A starting point for the query results.
  public var startAt: Google_Firestore_V1beta1_Cursor {
    get {return _startAt ?? Google_Firestore_V1beta1_Cursor()}
    set {_startAt = newValue}
  }
  /// Returns true if `startAt` has been explicitly set.
  public var hasStartAt: Bool {return self._startAt != nil}
  /// Clears the value of `startAt`. Subsequent reads from it will return its default value.
  public mutating func clearStartAt() {self._startAt = nil}

  /// A end point for the query results.
  public var endAt: Google_Firestore_V1beta1_Cursor {
    get {return _endAt ?? Google_Firestore_V1beta1_Cursor()}
    set {_endAt = newValue}
  }
  /// Returns true if `endAt` has been explicitly set.
  public var hasEndAt: Bool {return self._endAt != nil}
  /// Clears the value of `endAt`. Subsequent reads from it will return its default value.
  public mutating func clearEndAt() {self._endAt = nil}

  /// The number of results to skip.
  ///
  /// Applies before limit, but after all other constraints. Must be >= 0 if
  /// specified.
  public var offset: Int32 = 0

  /// The maximum number of results to return.
  ///
  /// Applies after all other constraints.
  /// Must be >= 0 if specified.
  public var limit: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _limit ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_limit = newValue}
  }
  /// Returns true if `limit` has been explicitly set.
  public var hasLimit: Bool {return self._limit != nil}
  /// Clears the value of `limit`. Subsequent reads from it will return its default value.
  public mutating func clearLimit() {self._limit = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A sort direction.
  public enum Direction: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unspecified.
    case unspecified // = 0

    /// Ascending.
    case ascending // = 1

    /// Descending.
    case descending // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .ascending
      case 2: self = .descending
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .ascending: return 1
      case .descending: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// A selection of a collection, such as `messages as m1`.
  public struct CollectionSelector {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The collection ID.
    /// When set, selects only collections with this ID.
    public var collectionID: String = String()

    /// When false, selects only collections that are immediate children of
    /// the `parent` specified in the containing `RunQueryRequest`.
    /// When true, selects all descendant collections.
    public var allDescendants: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// A filter.
  public struct Filter {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The type of filter.
    public var filterType: Google_Firestore_V1beta1_StructuredQuery.Filter.OneOf_FilterType? = nil

    /// A composite filter.
    public var compositeFilter: Google_Firestore_V1beta1_StructuredQuery.CompositeFilter {
      get {
        if case .compositeFilter(let v)? = filterType {return v}
        return Google_Firestore_V1beta1_StructuredQuery.CompositeFilter()
      }
      set {filterType = .compositeFilter(newValue)}
    }

    /// A filter on a document field.
    public var fieldFilter: Google_Firestore_V1beta1_StructuredQuery.FieldFilter {
      get {
        if case .fieldFilter(let v)? = filterType {return v}
        return Google_Firestore_V1beta1_StructuredQuery.FieldFilter()
      }
      set {filterType = .fieldFilter(newValue)}
    }

    /// A filter that takes exactly one argument.
    public var unaryFilter: Google_Firestore_V1beta1_StructuredQuery.UnaryFilter {
      get {
        if case .unaryFilter(let v)? = filterType {return v}
        return Google_Firestore_V1beta1_StructuredQuery.UnaryFilter()
      }
      set {filterType = .unaryFilter(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The type of filter.
    public enum OneOf_FilterType: Equatable {
      /// A composite filter.
      case compositeFilter(Google_Firestore_V1beta1_StructuredQuery.CompositeFilter)
      /// A filter on a document field.
      case fieldFilter(Google_Firestore_V1beta1_StructuredQuery.FieldFilter)
      /// A filter that takes exactly one argument.
      case unaryFilter(Google_Firestore_V1beta1_StructuredQuery.UnaryFilter)

    #if !swift(>=4.1)
      public static func ==(lhs: Google_Firestore_V1beta1_StructuredQuery.Filter.OneOf_FilterType, rhs: Google_Firestore_V1beta1_StructuredQuery.Filter.OneOf_FilterType) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.compositeFilter, .compositeFilter): return {
          guard case .compositeFilter(let l) = lhs, case .compositeFilter(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.fieldFilter, .fieldFilter): return {
          guard case .fieldFilter(let l) = lhs, case .fieldFilter(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.unaryFilter, .unaryFilter): return {
          guard case .unaryFilter(let l) = lhs, case .unaryFilter(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  /// A filter that merges multiple other filters using the given operator.
  public struct CompositeFilter {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The operator for combining multiple filters.
    public var op: Google_Firestore_V1beta1_StructuredQuery.CompositeFilter.Operator = .unspecified

    /// The list of filters to combine.
    /// Must contain at least one filter.
    public var filters: [Google_Firestore_V1beta1_StructuredQuery.Filter] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// A composite filter operator.
    public enum Operator: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// Unspecified. This value must not be used.
      case unspecified // = 0

      /// The results are required to satisfy each of the combined filters.
      case and // = 1
      case UNRECOGNIZED(Int)

      public init() {
        self = .unspecified
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .and
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .and: return 1
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  /// A filter on a specific field.
  public struct FieldFilter {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The field to filter by.
    public var field: Google_Firestore_V1beta1_StructuredQuery.FieldReference {
      get {return _field ?? Google_Firestore_V1beta1_StructuredQuery.FieldReference()}
      set {_field = newValue}
    }
    /// Returns true if `field` has been explicitly set.
    public var hasField: Bool {return self._field != nil}
    /// Clears the value of `field`. Subsequent reads from it will return its default value.
    public mutating func clearField() {self._field = nil}

    /// The operator to filter by.
    public var op: Google_Firestore_V1beta1_StructuredQuery.FieldFilter.Operator = .unspecified

    /// The value to compare to.
    public var value: Google_Firestore_V1beta1_Value {
      get {return _value ?? Google_Firestore_V1beta1_Value()}
      set {_value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    public var hasValue: Bool {return self._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    public mutating func clearValue() {self._value = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// A field filter operator.
    public enum Operator: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// Unspecified. This value must not be used.
      case unspecified // = 0

      /// Less than. Requires that the field come first in `order_by`.
      case lessThan // = 1

      /// Less than or equal. Requires that the field come first in `order_by`.
      case lessThanOrEqual // = 2

      /// Greater than. Requires that the field come first in `order_by`.
      case greaterThan // = 3

      /// Greater than or equal. Requires that the field come first in
      /// `order_by`.
      case greaterThanOrEqual // = 4

      /// Equal.
      case equal // = 5

      /// Contains. Requires that the field is an array.
      case arrayContains // = 7

      /// In. Requires that `value` is a non-empty ArrayValue with at most 10
      /// values.
      case `in` // = 8

      /// Contains any. Requires that the field is an array and
      /// `value` is a non-empty ArrayValue with at most 10 values.
      case arrayContainsAny // = 9
      case UNRECOGNIZED(Int)

      public init() {
        self = .unspecified
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .lessThan
        case 2: self = .lessThanOrEqual
        case 3: self = .greaterThan
        case 4: self = .greaterThanOrEqual
        case 5: self = .equal
        case 7: self = .arrayContains
        case 8: self = .in
        case 9: self = .arrayContainsAny
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .lessThan: return 1
        case .lessThanOrEqual: return 2
        case .greaterThan: return 3
        case .greaterThanOrEqual: return 4
        case .equal: return 5
        case .arrayContains: return 7
        case .in: return 8
        case .arrayContainsAny: return 9
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}

    fileprivate var _field: Google_Firestore_V1beta1_StructuredQuery.FieldReference? = nil
    fileprivate var _value: Google_Firestore_V1beta1_Value? = nil
  }

  /// A filter with a single operand.
  public struct UnaryFilter {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The unary operator to apply.
    public var op: Google_Firestore_V1beta1_StructuredQuery.UnaryFilter.Operator = .unspecified

    /// The argument to the filter.
    public var operandType: Google_Firestore_V1beta1_StructuredQuery.UnaryFilter.OneOf_OperandType? = nil

    /// The field to which to apply the operator.
    public var field: Google_Firestore_V1beta1_StructuredQuery.FieldReference {
      get {
        if case .field(let v)? = operandType {return v}
        return Google_Firestore_V1beta1_StructuredQuery.FieldReference()
      }
      set {operandType = .field(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The argument to the filter.
    public enum OneOf_OperandType: Equatable {
      /// The field to which to apply the operator.
      case field(Google_Firestore_V1beta1_StructuredQuery.FieldReference)

    #if !swift(>=4.1)
      public static func ==(lhs: Google_Firestore_V1beta1_StructuredQuery.UnaryFilter.OneOf_OperandType, rhs: Google_Firestore_V1beta1_StructuredQuery.UnaryFilter.OneOf_OperandType) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.field, .field): return {
          guard case .field(let l) = lhs, case .field(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        }
      }
    #endif
    }

    /// A unary operator.
    public enum Operator: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// Unspecified. This value must not be used.
      case unspecified // = 0

      /// Test if a field is equal to NaN.
      case isNan // = 2

      /// Test if an expression evaluates to Null.
      case isNull // = 3
      case UNRECOGNIZED(Int)

      public init() {
        self = .unspecified
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 2: self = .isNan
        case 3: self = .isNull
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .isNan: return 2
        case .isNull: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  /// An order on a field.
  public struct Order {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The field to order by.
    public var field: Google_Firestore_V1beta1_StructuredQuery.FieldReference {
      get {return _field ?? Google_Firestore_V1beta1_StructuredQuery.FieldReference()}
      set {_field = newValue}
    }
    /// Returns true if `field` has been explicitly set.
    public var hasField: Bool {return self._field != nil}
    /// Clears the value of `field`. Subsequent reads from it will return its default value.
    public mutating func clearField() {self._field = nil}

    /// The direction to order by. Defaults to `ASCENDING`.
    public var direction: Google_Firestore_V1beta1_StructuredQuery.Direction = .unspecified

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _field: Google_Firestore_V1beta1_StructuredQuery.FieldReference? = nil
  }

  /// A reference to a field, such as `max(messages.time) as max_time`.
  public struct FieldReference {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var fieldPath: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// The projection of document's fields to return.
  public struct Projection {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The fields to return.
    ///
    /// If empty, all fields are returned. To only return the name
    /// of the document, use `['__name__']`.
    public var fields: [Google_Firestore_V1beta1_StructuredQuery.FieldReference] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _select: Google_Firestore_V1beta1_StructuredQuery.Projection? = nil
  fileprivate var _where: Google_Firestore_V1beta1_StructuredQuery.Filter? = nil
  fileprivate var _startAt: Google_Firestore_V1beta1_Cursor? = nil
  fileprivate var _endAt: Google_Firestore_V1beta1_Cursor? = nil
  fileprivate var _limit: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
}

#if swift(>=4.2)

extension Google_Firestore_V1beta1_StructuredQuery.Direction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Firestore_V1beta1_StructuredQuery.Direction] = [
    .unspecified,
    .ascending,
    .descending,
  ]
}

extension Google_Firestore_V1beta1_StructuredQuery.CompositeFilter.Operator: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Firestore_V1beta1_StructuredQuery.CompositeFilter.Operator] = [
    .unspecified,
    .and,
  ]
}

extension Google_Firestore_V1beta1_StructuredQuery.FieldFilter.Operator: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Firestore_V1beta1_StructuredQuery.FieldFilter.Operator] = [
    .unspecified,
    .lessThan,
    .lessThanOrEqual,
    .greaterThan,
    .greaterThanOrEqual,
    .equal,
    .arrayContains,
    .in,
    .arrayContainsAny,
  ]
}

extension Google_Firestore_V1beta1_StructuredQuery.UnaryFilter.Operator: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Firestore_V1beta1_StructuredQuery.UnaryFilter.Operator] = [
    .unspecified,
    .isNan,
    .isNull,
  ]
}

#endif  // swift(>=4.2)

/// A position in a query result set.
public struct Google_Firestore_V1beta1_Cursor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The values that represent a position, in the order they appear in
  /// the order by clause of a query.
  ///
  /// Can contain fewer values than specified in the order by clause.
  public var values: [Google_Firestore_V1beta1_Value] = []

  /// If the position is just before or just after the given values, relative
  /// to the sort order defined by the query.
  public var before: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.firestore.v1beta1"

extension Google_Firestore_V1beta1_StructuredQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StructuredQuery"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "select"),
    2: .same(proto: "from"),
    3: .same(proto: "where"),
    4: .standard(proto: "order_by"),
    7: .standard(proto: "start_at"),
    8: .standard(proto: "end_at"),
    6: .same(proto: "offset"),
    5: .same(proto: "limit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._select) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.from) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._where) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.orderBy) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._limit) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.offset) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._startAt) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._endAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._select {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.from.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.from, fieldNumber: 2)
    }
    if let v = self._where {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.orderBy.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.orderBy, fieldNumber: 4)
    }
    if let v = self._limit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt32Field(value: self.offset, fieldNumber: 6)
    }
    if let v = self._startAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if let v = self._endAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1beta1_StructuredQuery, rhs: Google_Firestore_V1beta1_StructuredQuery) -> Bool {
    if lhs._select != rhs._select {return false}
    if lhs.from != rhs.from {return false}
    if lhs._where != rhs._where {return false}
    if lhs.orderBy != rhs.orderBy {return false}
    if lhs._startAt != rhs._startAt {return false}
    if lhs._endAt != rhs._endAt {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs._limit != rhs._limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1beta1_StructuredQuery.Direction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DIRECTION_UNSPECIFIED"),
    1: .same(proto: "ASCENDING"),
    2: .same(proto: "DESCENDING"),
  ]
}

extension Google_Firestore_V1beta1_StructuredQuery.CollectionSelector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Firestore_V1beta1_StructuredQuery.protoMessageName + ".CollectionSelector"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "collection_id"),
    3: .standard(proto: "all_descendants"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.collectionID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.allDescendants) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.collectionID.isEmpty {
      try visitor.visitSingularStringField(value: self.collectionID, fieldNumber: 2)
    }
    if self.allDescendants != false {
      try visitor.visitSingularBoolField(value: self.allDescendants, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1beta1_StructuredQuery.CollectionSelector, rhs: Google_Firestore_V1beta1_StructuredQuery.CollectionSelector) -> Bool {
    if lhs.collectionID != rhs.collectionID {return false}
    if lhs.allDescendants != rhs.allDescendants {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1beta1_StructuredQuery.Filter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Firestore_V1beta1_StructuredQuery.protoMessageName + ".Filter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "composite_filter"),
    2: .standard(proto: "field_filter"),
    3: .standard(proto: "unary_filter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Firestore_V1beta1_StructuredQuery.CompositeFilter?
        if let current = self.filterType {
          try decoder.handleConflictingOneOf()
          if case .compositeFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.filterType = .compositeFilter(v)}
      }()
      case 2: try {
        var v: Google_Firestore_V1beta1_StructuredQuery.FieldFilter?
        if let current = self.filterType {
          try decoder.handleConflictingOneOf()
          if case .fieldFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.filterType = .fieldFilter(v)}
      }()
      case 3: try {
        var v: Google_Firestore_V1beta1_StructuredQuery.UnaryFilter?
        if let current = self.filterType {
          try decoder.handleConflictingOneOf()
          if case .unaryFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.filterType = .unaryFilter(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.filterType {
    case .compositeFilter?: try {
      guard case .compositeFilter(let v)? = self.filterType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .fieldFilter?: try {
      guard case .fieldFilter(let v)? = self.filterType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .unaryFilter?: try {
      guard case .unaryFilter(let v)? = self.filterType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1beta1_StructuredQuery.Filter, rhs: Google_Firestore_V1beta1_StructuredQuery.Filter) -> Bool {
    if lhs.filterType != rhs.filterType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1beta1_StructuredQuery.CompositeFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Firestore_V1beta1_StructuredQuery.protoMessageName + ".CompositeFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "op"),
    2: .same(proto: "filters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.op) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.filters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.op != .unspecified {
      try visitor.visitSingularEnumField(value: self.op, fieldNumber: 1)
    }
    if !self.filters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.filters, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1beta1_StructuredQuery.CompositeFilter, rhs: Google_Firestore_V1beta1_StructuredQuery.CompositeFilter) -> Bool {
    if lhs.op != rhs.op {return false}
    if lhs.filters != rhs.filters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1beta1_StructuredQuery.CompositeFilter.Operator: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OPERATOR_UNSPECIFIED"),
    1: .same(proto: "AND"),
  ]
}

extension Google_Firestore_V1beta1_StructuredQuery.FieldFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Firestore_V1beta1_StructuredQuery.protoMessageName + ".FieldFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "field"),
    2: .same(proto: "op"),
    3: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._field) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.op) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._field {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.op != .unspecified {
      try visitor.visitSingularEnumField(value: self.op, fieldNumber: 2)
    }
    if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1beta1_StructuredQuery.FieldFilter, rhs: Google_Firestore_V1beta1_StructuredQuery.FieldFilter) -> Bool {
    if lhs._field != rhs._field {return false}
    if lhs.op != rhs.op {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1beta1_StructuredQuery.FieldFilter.Operator: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OPERATOR_UNSPECIFIED"),
    1: .same(proto: "LESS_THAN"),
    2: .same(proto: "LESS_THAN_OR_EQUAL"),
    3: .same(proto: "GREATER_THAN"),
    4: .same(proto: "GREATER_THAN_OR_EQUAL"),
    5: .same(proto: "EQUAL"),
    7: .same(proto: "ARRAY_CONTAINS"),
    8: .same(proto: "IN"),
    9: .same(proto: "ARRAY_CONTAINS_ANY"),
  ]
}

extension Google_Firestore_V1beta1_StructuredQuery.UnaryFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Firestore_V1beta1_StructuredQuery.protoMessageName + ".UnaryFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "op"),
    2: .same(proto: "field"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.op) }()
      case 2: try {
        var v: Google_Firestore_V1beta1_StructuredQuery.FieldReference?
        if let current = self.operandType {
          try decoder.handleConflictingOneOf()
          if case .field(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operandType = .field(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.op != .unspecified {
      try visitor.visitSingularEnumField(value: self.op, fieldNumber: 1)
    }
    if case .field(let v)? = self.operandType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1beta1_StructuredQuery.UnaryFilter, rhs: Google_Firestore_V1beta1_StructuredQuery.UnaryFilter) -> Bool {
    if lhs.op != rhs.op {return false}
    if lhs.operandType != rhs.operandType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1beta1_StructuredQuery.UnaryFilter.Operator: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OPERATOR_UNSPECIFIED"),
    2: .same(proto: "IS_NAN"),
    3: .same(proto: "IS_NULL"),
  ]
}

extension Google_Firestore_V1beta1_StructuredQuery.Order: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Firestore_V1beta1_StructuredQuery.protoMessageName + ".Order"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "field"),
    2: .same(proto: "direction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._field) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.direction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._field {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.direction != .unspecified {
      try visitor.visitSingularEnumField(value: self.direction, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1beta1_StructuredQuery.Order, rhs: Google_Firestore_V1beta1_StructuredQuery.Order) -> Bool {
    if lhs._field != rhs._field {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1beta1_StructuredQuery.FieldReference: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Firestore_V1beta1_StructuredQuery.protoMessageName + ".FieldReference"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "field_path"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.fieldPath) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fieldPath.isEmpty {
      try visitor.visitSingularStringField(value: self.fieldPath, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1beta1_StructuredQuery.FieldReference, rhs: Google_Firestore_V1beta1_StructuredQuery.FieldReference) -> Bool {
    if lhs.fieldPath != rhs.fieldPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1beta1_StructuredQuery.Projection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Firestore_V1beta1_StructuredQuery.protoMessageName + ".Projection"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "fields"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.fields) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fields.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fields, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1beta1_StructuredQuery.Projection, rhs: Google_Firestore_V1beta1_StructuredQuery.Projection) -> Bool {
    if lhs.fields != rhs.fields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1beta1_Cursor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Cursor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
    2: .same(proto: "before"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.values) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.before) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.values, fieldNumber: 1)
    }
    if self.before != false {
      try visitor.visitSingularBoolField(value: self.before, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1beta1_Cursor, rhs: Google_Firestore_V1beta1_Cursor) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.before != rhs.before {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

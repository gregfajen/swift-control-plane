// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: grafeas/v1/vulnerability.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019 The Grafeas Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Note provider assigned severity/impact ranking.
public enum Grafeas_V1_Severity: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Unknown.
  case unspecified // = 0

  /// Minimal severity.
  case minimal // = 1

  /// Low severity.
  case low // = 2

  /// Medium severity.
  case medium // = 3

  /// High severity.
  case high // = 4

  /// Critical severity.
  case critical // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .minimal
    case 2: self = .low
    case 3: self = .medium
    case 4: self = .high
    case 5: self = .critical
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .minimal: return 1
    case .low: return 2
    case .medium: return 3
    case .high: return 4
    case .critical: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Grafeas_V1_Severity: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Grafeas_V1_Severity] = [
    .unspecified,
    .minimal,
    .low,
    .medium,
    .high,
    .critical,
  ]
}

#endif  // swift(>=4.2)

/// A security vulnerability that can be found in resources.
public struct Grafeas_V1_VulnerabilityNote {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The CVSS score of this vulnerability. CVSS score is on a scale of 0 - 10
  /// where 0 indicates low severity and 10 indicates high severity.
  public var cvssScore: Float {
    get {return _storage._cvssScore}
    set {_uniqueStorage()._cvssScore = newValue}
  }

  /// The note provider assigned severity of this vulnerability.
  public var severity: Grafeas_V1_Severity {
    get {return _storage._severity}
    set {_uniqueStorage()._severity = newValue}
  }

  /// Details of all known distros and packages affected by this vulnerability.
  public var details: [Grafeas_V1_VulnerabilityNote.Detail] {
    get {return _storage._details}
    set {_uniqueStorage()._details = newValue}
  }

  /// The full description of the CVSSv3 for this vulnerability.
  public var cvssV3: Grafeas_V1_CVSSv3 {
    get {return _storage._cvssV3 ?? Grafeas_V1_CVSSv3()}
    set {_uniqueStorage()._cvssV3 = newValue}
  }
  /// Returns true if `cvssV3` has been explicitly set.
  public var hasCvssV3: Bool {return _storage._cvssV3 != nil}
  /// Clears the value of `cvssV3`. Subsequent reads from it will return its default value.
  public mutating func clearCvssV3() {_uniqueStorage()._cvssV3 = nil}

  /// Windows details get their own format because the information format and
  /// model don't match a normal detail. Specifically Windows updates are done as
  /// patches, thus Windows vulnerabilities really are a missing package, rather
  /// than a package being at an incorrect version.
  public var windowsDetails: [Grafeas_V1_VulnerabilityNote.WindowsDetail] {
    get {return _storage._windowsDetails}
    set {_uniqueStorage()._windowsDetails = newValue}
  }

  /// The time this information was last changed at the source. This is an
  /// upstream timestamp from the underlying information source - e.g. Ubuntu
  /// security tracker.
  public var sourceUpdateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._sourceUpdateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._sourceUpdateTime = newValue}
  }
  /// Returns true if `sourceUpdateTime` has been explicitly set.
  public var hasSourceUpdateTime: Bool {return _storage._sourceUpdateTime != nil}
  /// Clears the value of `sourceUpdateTime`. Subsequent reads from it will return its default value.
  public mutating func clearSourceUpdateTime() {_uniqueStorage()._sourceUpdateTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A detail for a distro and package affected by this vulnerability and its
  /// associated fix (if one is available).
  public struct Detail {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The distro assigned severity of this vulnerability.
    public var severityName: String {
      get {return _storage._severityName}
      set {_uniqueStorage()._severityName = newValue}
    }

    /// A vendor-specific description of this vulnerability.
    public var description_p: String {
      get {return _storage._description_p}
      set {_uniqueStorage()._description_p = newValue}
    }

    /// The type of package; whether native or non native (e.g., ruby gems,
    /// node.js packages, etc.).
    public var packageType: String {
      get {return _storage._packageType}
      set {_uniqueStorage()._packageType = newValue}
    }

    /// Required. The [CPE URI](https://cpe.mitre.org/specification/) this
    /// vulnerability affects.
    public var affectedCpeUri: String {
      get {return _storage._affectedCpeUri}
      set {_uniqueStorage()._affectedCpeUri = newValue}
    }

    /// Required. The package this vulnerability affects.
    public var affectedPackage: String {
      get {return _storage._affectedPackage}
      set {_uniqueStorage()._affectedPackage = newValue}
    }

    /// The version number at the start of an interval in which this
    /// vulnerability exists. A vulnerability can affect a package between
    /// version numbers that are disjoint sets of intervals (example:
    /// [1.0.0-1.1.0], [2.4.6-2.4.8] and [4.5.6-4.6.8]) each of which will be
    /// represented in its own Detail. If a specific affected version is provided
    /// by a vulnerability database, affected_version_start and
    /// affected_version_end will be the same in that Detail.
    public var affectedVersionStart: Grafeas_V1_Version {
      get {return _storage._affectedVersionStart ?? Grafeas_V1_Version()}
      set {_uniqueStorage()._affectedVersionStart = newValue}
    }
    /// Returns true if `affectedVersionStart` has been explicitly set.
    public var hasAffectedVersionStart: Bool {return _storage._affectedVersionStart != nil}
    /// Clears the value of `affectedVersionStart`. Subsequent reads from it will return its default value.
    public mutating func clearAffectedVersionStart() {_uniqueStorage()._affectedVersionStart = nil}

    /// The version number at the end of an interval in which this vulnerability
    /// exists. A vulnerability can affect a package between version numbers
    /// that are disjoint sets of intervals (example: [1.0.0-1.1.0],
    /// [2.4.6-2.4.8] and [4.5.6-4.6.8]) each of which will be represented in its
    /// own Detail. If a specific affected version is provided by a vulnerability
    /// database, affected_version_start and affected_version_end will be the
    /// same in that Detail.
    public var affectedVersionEnd: Grafeas_V1_Version {
      get {return _storage._affectedVersionEnd ?? Grafeas_V1_Version()}
      set {_uniqueStorage()._affectedVersionEnd = newValue}
    }
    /// Returns true if `affectedVersionEnd` has been explicitly set.
    public var hasAffectedVersionEnd: Bool {return _storage._affectedVersionEnd != nil}
    /// Clears the value of `affectedVersionEnd`. Subsequent reads from it will return its default value.
    public mutating func clearAffectedVersionEnd() {_uniqueStorage()._affectedVersionEnd = nil}

    /// The distro recommended [CPE URI](https://cpe.mitre.org/specification/)
    /// to update to that contains a fix for this vulnerability. It is possible
    /// for this to be different from the affected_cpe_uri.
    public var fixedCpeUri: String {
      get {return _storage._fixedCpeUri}
      set {_uniqueStorage()._fixedCpeUri = newValue}
    }

    /// The distro recommended package to update to that contains a fix for this
    /// vulnerability. It is possible for this to be different from the
    /// affected_package.
    public var fixedPackage: String {
      get {return _storage._fixedPackage}
      set {_uniqueStorage()._fixedPackage = newValue}
    }

    /// The distro recommended version to update to that contains a
    /// fix for this vulnerability. Setting this to VersionKind.MAXIMUM means no
    /// such version is yet available.
    public var fixedVersion: Grafeas_V1_Version {
      get {return _storage._fixedVersion ?? Grafeas_V1_Version()}
      set {_uniqueStorage()._fixedVersion = newValue}
    }
    /// Returns true if `fixedVersion` has been explicitly set.
    public var hasFixedVersion: Bool {return _storage._fixedVersion != nil}
    /// Clears the value of `fixedVersion`. Subsequent reads from it will return its default value.
    public mutating func clearFixedVersion() {_uniqueStorage()._fixedVersion = nil}

    /// Whether this detail is obsolete. Occurrences are expected not to point to
    /// obsolete details.
    public var isObsolete: Bool {
      get {return _storage._isObsolete}
      set {_uniqueStorage()._isObsolete = newValue}
    }

    /// The time this information was last changed at the source. This is an
    /// upstream timestamp from the underlying information source - e.g. Ubuntu
    /// security tracker.
    public var sourceUpdateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _storage._sourceUpdateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._sourceUpdateTime = newValue}
    }
    /// Returns true if `sourceUpdateTime` has been explicitly set.
    public var hasSourceUpdateTime: Bool {return _storage._sourceUpdateTime != nil}
    /// Clears the value of `sourceUpdateTime`. Subsequent reads from it will return its default value.
    public mutating func clearSourceUpdateTime() {_uniqueStorage()._sourceUpdateTime = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct WindowsDetail {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. The [CPE URI](https://cpe.mitre.org/specification/) this
    /// vulnerability affects.
    public var cpeUri: String = String()

    /// Required. The name of this vulnerability.
    public var name: String = String()

    /// The description of this vulnerability.
    public var description_p: String = String()

    /// Required. The names of the KBs which have hotfixes to mitigate this
    /// vulnerability. Note that there may be multiple hotfixes (and thus
    /// multiple KBs) that mitigate a given vulnerability. Currently any listed
    /// KBs presence is considered a fix.
    public var fixingKbs: [Grafeas_V1_VulnerabilityNote.WindowsDetail.KnowledgeBase] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct KnowledgeBase {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The KB name (generally of the form KB[0-9]+ (e.g., KB123456)).
      public var name: String = String()

      /// A link to the KB in the [Windows update catalog]
      /// (https://www.catalog.update.microsoft.com/).
      public var url: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// An occurrence of a severity vulnerability on a resource.
public struct Grafeas_V1_VulnerabilityOccurrence {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of package; whether native or non native (e.g., ruby gems, node.js
  /// packages, etc.).
  public var type: String = String()

  /// Output only. The note provider assigned severity of this vulnerability.
  public var severity: Grafeas_V1_Severity = .unspecified

  /// Output only. The CVSS score of this vulnerability. CVSS score is on a
  /// scale of 0 - 10 where 0 indicates low severity and 10 indicates high
  /// severity.
  public var cvssScore: Float = 0

  /// Required. The set of affected locations and their fixes (if available)
  /// within the associated resource.
  public var packageIssue: [Grafeas_V1_VulnerabilityOccurrence.PackageIssue] = []

  /// Output only. A one sentence description of this vulnerability.
  public var shortDescription: String = String()

  /// Output only. A detailed description of this vulnerability.
  public var longDescription: String = String()

  /// Output only. URLs related to this vulnerability.
  public var relatedUrls: [Grafeas_V1_RelatedUrl] = []

  /// The distro assigned severity for this vulnerability when it is available,
  /// otherwise this is the note provider assigned severity.
  public var effectiveSeverity: Grafeas_V1_Severity = .unspecified

  /// Output only. Whether at least one of the affected packages has a fix
  /// available.
  public var fixAvailable: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A detail for a distro and package this vulnerability occurrence was found
  /// in and its associated fix (if one is available).
  public struct PackageIssue {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. The [CPE URI](https://cpe.mitre.org/specification/) this
    /// vulnerability was found in.
    public var affectedCpeUri: String = String()

    /// Required. The package this vulnerability was found in.
    public var affectedPackage: String = String()

    /// Required. The version of the package that is installed on the resource
    /// affected by this vulnerability.
    public var affectedVersion: Grafeas_V1_Version {
      get {return _affectedVersion ?? Grafeas_V1_Version()}
      set {_affectedVersion = newValue}
    }
    /// Returns true if `affectedVersion` has been explicitly set.
    public var hasAffectedVersion: Bool {return self._affectedVersion != nil}
    /// Clears the value of `affectedVersion`. Subsequent reads from it will return its default value.
    public mutating func clearAffectedVersion() {self._affectedVersion = nil}

    /// The [CPE URI](https://cpe.mitre.org/specification/) this vulnerability
    /// was fixed in. It is possible for this to be different from the
    /// affected_cpe_uri.
    public var fixedCpeUri: String = String()

    /// The package this vulnerability was fixed in. It is possible for this to
    /// be different from the affected_package.
    public var fixedPackage: String = String()

    /// Required. The version of the package this vulnerability was fixed in.
    /// Setting this to VersionKind.MAXIMUM means no fix is yet available.
    public var fixedVersion: Grafeas_V1_Version {
      get {return _fixedVersion ?? Grafeas_V1_Version()}
      set {_fixedVersion = newValue}
    }
    /// Returns true if `fixedVersion` has been explicitly set.
    public var hasFixedVersion: Bool {return self._fixedVersion != nil}
    /// Clears the value of `fixedVersion`. Subsequent reads from it will return its default value.
    public mutating func clearFixedVersion() {self._fixedVersion = nil}

    /// Output only. Whether a fix is available for this package.
    public var fixAvailable: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _affectedVersion: Grafeas_V1_Version? = nil
    fileprivate var _fixedVersion: Grafeas_V1_Version? = nil
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "grafeas.v1"

extension Grafeas_V1_Severity: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SEVERITY_UNSPECIFIED"),
    1: .same(proto: "MINIMAL"),
    2: .same(proto: "LOW"),
    3: .same(proto: "MEDIUM"),
    4: .same(proto: "HIGH"),
    5: .same(proto: "CRITICAL"),
  ]
}

extension Grafeas_V1_VulnerabilityNote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VulnerabilityNote"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cvss_score"),
    2: .same(proto: "severity"),
    3: .same(proto: "details"),
    4: .standard(proto: "cvss_v3"),
    5: .standard(proto: "windows_details"),
    6: .standard(proto: "source_update_time"),
  ]

  fileprivate class _StorageClass {
    var _cvssScore: Float = 0
    var _severity: Grafeas_V1_Severity = .unspecified
    var _details: [Grafeas_V1_VulnerabilityNote.Detail] = []
    var _cvssV3: Grafeas_V1_CVSSv3? = nil
    var _windowsDetails: [Grafeas_V1_VulnerabilityNote.WindowsDetail] = []
    var _sourceUpdateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _cvssScore = source._cvssScore
      _severity = source._severity
      _details = source._details
      _cvssV3 = source._cvssV3
      _windowsDetails = source._windowsDetails
      _sourceUpdateTime = source._sourceUpdateTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularFloatField(value: &_storage._cvssScore) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._severity) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._details) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._cvssV3) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._windowsDetails) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._sourceUpdateTime) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._cvssScore != 0 {
        try visitor.visitSingularFloatField(value: _storage._cvssScore, fieldNumber: 1)
      }
      if _storage._severity != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._severity, fieldNumber: 2)
      }
      if !_storage._details.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._details, fieldNumber: 3)
      }
      if let v = _storage._cvssV3 {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._windowsDetails.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._windowsDetails, fieldNumber: 5)
      }
      if let v = _storage._sourceUpdateTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1_VulnerabilityNote, rhs: Grafeas_V1_VulnerabilityNote) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._cvssScore != rhs_storage._cvssScore {return false}
        if _storage._severity != rhs_storage._severity {return false}
        if _storage._details != rhs_storage._details {return false}
        if _storage._cvssV3 != rhs_storage._cvssV3 {return false}
        if _storage._windowsDetails != rhs_storage._windowsDetails {return false}
        if _storage._sourceUpdateTime != rhs_storage._sourceUpdateTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grafeas_V1_VulnerabilityNote.Detail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Grafeas_V1_VulnerabilityNote.protoMessageName + ".Detail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "severity_name"),
    2: .same(proto: "description"),
    3: .standard(proto: "package_type"),
    4: .standard(proto: "affected_cpe_uri"),
    5: .standard(proto: "affected_package"),
    6: .standard(proto: "affected_version_start"),
    7: .standard(proto: "affected_version_end"),
    8: .standard(proto: "fixed_cpe_uri"),
    9: .standard(proto: "fixed_package"),
    10: .standard(proto: "fixed_version"),
    11: .standard(proto: "is_obsolete"),
    12: .standard(proto: "source_update_time"),
  ]

  fileprivate class _StorageClass {
    var _severityName: String = String()
    var _description_p: String = String()
    var _packageType: String = String()
    var _affectedCpeUri: String = String()
    var _affectedPackage: String = String()
    var _affectedVersionStart: Grafeas_V1_Version? = nil
    var _affectedVersionEnd: Grafeas_V1_Version? = nil
    var _fixedCpeUri: String = String()
    var _fixedPackage: String = String()
    var _fixedVersion: Grafeas_V1_Version? = nil
    var _isObsolete: Bool = false
    var _sourceUpdateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _severityName = source._severityName
      _description_p = source._description_p
      _packageType = source._packageType
      _affectedCpeUri = source._affectedCpeUri
      _affectedPackage = source._affectedPackage
      _affectedVersionStart = source._affectedVersionStart
      _affectedVersionEnd = source._affectedVersionEnd
      _fixedCpeUri = source._fixedCpeUri
      _fixedPackage = source._fixedPackage
      _fixedVersion = source._fixedVersion
      _isObsolete = source._isObsolete
      _sourceUpdateTime = source._sourceUpdateTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._severityName) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._packageType) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._affectedCpeUri) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._affectedPackage) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._affectedVersionStart) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._affectedVersionEnd) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._fixedCpeUri) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._fixedPackage) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._fixedVersion) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._isObsolete) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._sourceUpdateTime) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._severityName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._severityName, fieldNumber: 1)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 2)
      }
      if !_storage._packageType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._packageType, fieldNumber: 3)
      }
      if !_storage._affectedCpeUri.isEmpty {
        try visitor.visitSingularStringField(value: _storage._affectedCpeUri, fieldNumber: 4)
      }
      if !_storage._affectedPackage.isEmpty {
        try visitor.visitSingularStringField(value: _storage._affectedPackage, fieldNumber: 5)
      }
      if let v = _storage._affectedVersionStart {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._affectedVersionEnd {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if !_storage._fixedCpeUri.isEmpty {
        try visitor.visitSingularStringField(value: _storage._fixedCpeUri, fieldNumber: 8)
      }
      if !_storage._fixedPackage.isEmpty {
        try visitor.visitSingularStringField(value: _storage._fixedPackage, fieldNumber: 9)
      }
      if let v = _storage._fixedVersion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if _storage._isObsolete != false {
        try visitor.visitSingularBoolField(value: _storage._isObsolete, fieldNumber: 11)
      }
      if let v = _storage._sourceUpdateTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1_VulnerabilityNote.Detail, rhs: Grafeas_V1_VulnerabilityNote.Detail) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._severityName != rhs_storage._severityName {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._packageType != rhs_storage._packageType {return false}
        if _storage._affectedCpeUri != rhs_storage._affectedCpeUri {return false}
        if _storage._affectedPackage != rhs_storage._affectedPackage {return false}
        if _storage._affectedVersionStart != rhs_storage._affectedVersionStart {return false}
        if _storage._affectedVersionEnd != rhs_storage._affectedVersionEnd {return false}
        if _storage._fixedCpeUri != rhs_storage._fixedCpeUri {return false}
        if _storage._fixedPackage != rhs_storage._fixedPackage {return false}
        if _storage._fixedVersion != rhs_storage._fixedVersion {return false}
        if _storage._isObsolete != rhs_storage._isObsolete {return false}
        if _storage._sourceUpdateTime != rhs_storage._sourceUpdateTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grafeas_V1_VulnerabilityNote.WindowsDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Grafeas_V1_VulnerabilityNote.protoMessageName + ".WindowsDetail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cpe_uri"),
    2: .same(proto: "name"),
    3: .same(proto: "description"),
    4: .standard(proto: "fixing_kbs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cpeUri) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.fixingKbs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cpeUri.isEmpty {
      try visitor.visitSingularStringField(value: self.cpeUri, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if !self.fixingKbs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fixingKbs, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1_VulnerabilityNote.WindowsDetail, rhs: Grafeas_V1_VulnerabilityNote.WindowsDetail) -> Bool {
    if lhs.cpeUri != rhs.cpeUri {return false}
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.fixingKbs != rhs.fixingKbs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grafeas_V1_VulnerabilityNote.WindowsDetail.KnowledgeBase: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Grafeas_V1_VulnerabilityNote.WindowsDetail.protoMessageName + ".KnowledgeBase"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1_VulnerabilityNote.WindowsDetail.KnowledgeBase, rhs: Grafeas_V1_VulnerabilityNote.WindowsDetail.KnowledgeBase) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grafeas_V1_VulnerabilityOccurrence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VulnerabilityOccurrence"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "severity"),
    3: .standard(proto: "cvss_score"),
    4: .standard(proto: "package_issue"),
    5: .standard(proto: "short_description"),
    6: .standard(proto: "long_description"),
    7: .standard(proto: "related_urls"),
    8: .standard(proto: "effective_severity"),
    9: .standard(proto: "fix_available"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.severity) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.cvssScore) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.packageIssue) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.shortDescription) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.longDescription) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.relatedUrls) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.effectiveSeverity) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.fixAvailable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if self.severity != .unspecified {
      try visitor.visitSingularEnumField(value: self.severity, fieldNumber: 2)
    }
    if self.cvssScore != 0 {
      try visitor.visitSingularFloatField(value: self.cvssScore, fieldNumber: 3)
    }
    if !self.packageIssue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.packageIssue, fieldNumber: 4)
    }
    if !self.shortDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.shortDescription, fieldNumber: 5)
    }
    if !self.longDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.longDescription, fieldNumber: 6)
    }
    if !self.relatedUrls.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.relatedUrls, fieldNumber: 7)
    }
    if self.effectiveSeverity != .unspecified {
      try visitor.visitSingularEnumField(value: self.effectiveSeverity, fieldNumber: 8)
    }
    if self.fixAvailable != false {
      try visitor.visitSingularBoolField(value: self.fixAvailable, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1_VulnerabilityOccurrence, rhs: Grafeas_V1_VulnerabilityOccurrence) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.severity != rhs.severity {return false}
    if lhs.cvssScore != rhs.cvssScore {return false}
    if lhs.packageIssue != rhs.packageIssue {return false}
    if lhs.shortDescription != rhs.shortDescription {return false}
    if lhs.longDescription != rhs.longDescription {return false}
    if lhs.relatedUrls != rhs.relatedUrls {return false}
    if lhs.effectiveSeverity != rhs.effectiveSeverity {return false}
    if lhs.fixAvailable != rhs.fixAvailable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grafeas_V1_VulnerabilityOccurrence.PackageIssue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Grafeas_V1_VulnerabilityOccurrence.protoMessageName + ".PackageIssue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "affected_cpe_uri"),
    2: .standard(proto: "affected_package"),
    3: .standard(proto: "affected_version"),
    4: .standard(proto: "fixed_cpe_uri"),
    5: .standard(proto: "fixed_package"),
    6: .standard(proto: "fixed_version"),
    7: .standard(proto: "fix_available"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.affectedCpeUri) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.affectedPackage) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._affectedVersion) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.fixedCpeUri) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.fixedPackage) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._fixedVersion) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.fixAvailable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.affectedCpeUri.isEmpty {
      try visitor.visitSingularStringField(value: self.affectedCpeUri, fieldNumber: 1)
    }
    if !self.affectedPackage.isEmpty {
      try visitor.visitSingularStringField(value: self.affectedPackage, fieldNumber: 2)
    }
    if let v = self._affectedVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.fixedCpeUri.isEmpty {
      try visitor.visitSingularStringField(value: self.fixedCpeUri, fieldNumber: 4)
    }
    if !self.fixedPackage.isEmpty {
      try visitor.visitSingularStringField(value: self.fixedPackage, fieldNumber: 5)
    }
    if let v = self._fixedVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if self.fixAvailable != false {
      try visitor.visitSingularBoolField(value: self.fixAvailable, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1_VulnerabilityOccurrence.PackageIssue, rhs: Grafeas_V1_VulnerabilityOccurrence.PackageIssue) -> Bool {
    if lhs.affectedCpeUri != rhs.affectedCpeUri {return false}
    if lhs.affectedPackage != rhs.affectedPackage {return false}
    if lhs._affectedVersion != rhs._affectedVersion {return false}
    if lhs.fixedCpeUri != rhs.fixedCpeUri {return false}
    if lhs.fixedPackage != rhs.fixedPackage {return false}
    if lhs._fixedVersion != rhs._fixedVersion {return false}
    if lhs.fixAvailable != rhs.fixAvailable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: grafeas/v1/common.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019 The Grafeas Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Kind represents the kinds of notes supported.
public enum Grafeas_V1_NoteKind: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Unknown.
  case unspecified // = 0

  /// The note and occurrence represent a package vulnerability.
  case vulnerability // = 1

  /// The note and occurrence assert build provenance.
  case build // = 2

  /// This represents an image basis relationship.
  case image // = 3

  /// This represents a package installed via a package manager.
  case package // = 4

  /// The note and occurrence track deployment events.
  case deployment // = 5

  /// The note and occurrence track the initial discovery status of a resource.
  case discovery // = 6

  /// This represents a logical "role" that can attest to artifacts.
  case attestation // = 7

  /// This represents an available package upgrade.
  case upgrade // = 8
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .vulnerability
    case 2: self = .build
    case 3: self = .image
    case 4: self = .package
    case 5: self = .deployment
    case 6: self = .discovery
    case 7: self = .attestation
    case 8: self = .upgrade
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .vulnerability: return 1
    case .build: return 2
    case .image: return 3
    case .package: return 4
    case .deployment: return 5
    case .discovery: return 6
    case .attestation: return 7
    case .upgrade: return 8
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Grafeas_V1_NoteKind: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Grafeas_V1_NoteKind] = [
    .unspecified,
    .vulnerability,
    .build,
    .image,
    .package,
    .deployment,
    .discovery,
    .attestation,
    .upgrade,
  ]
}

#endif  // swift(>=4.2)

/// Metadata for any related URL information.
public struct Grafeas_V1_RelatedUrl {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specific URL associated with the resource.
  public var url: String = String()

  /// Label to describe usage of the URL.
  public var label: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Verifiers (e.g. Kritis implementations) MUST verify signatures
/// with respect to the trust anchors defined in policy (e.g. a Kritis policy).
/// Typically this means that the verifier has been configured with a map from
/// `public_key_id` to public key material (and any required parameters, e.g.
/// signing algorithm).
///
/// In particular, verification implementations MUST NOT treat the signature
/// `public_key_id` as anything more than a key lookup hint. The `public_key_id`
/// DOES NOT validate or authenticate a public key; it only provides a mechanism
/// for quickly selecting a public key ALREADY CONFIGURED on the verifier through
/// a trusted channel. Verification implementations MUST reject signatures in any
/// of the following circumstances:
///   * The `public_key_id` is not recognized by the verifier.
///   * The public key that `public_key_id` refers to does not verify the
///     signature with respect to the payload.
///
/// The `signature` contents SHOULD NOT be "attached" (where the payload is
/// included with the serialized `signature` bytes). Verifiers MUST ignore any
/// "attached" payload and only verify signatures with respect to explicitly
/// provided payload (e.g. a `payload` field on the proto message that holds
/// this Signature, or the canonical serialization of the proto message that
/// holds this signature).
public struct Grafeas_V1_Signature {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The content of the signature, an opaque bytestring.
  /// The payload that this signature verifies MUST be unambiguously provided
  /// with the Signature during verification. A wrapper message might provide
  /// the payload explicitly. Alternatively, a message might have a canonical
  /// serialization that can always be unambiguously computed to derive the
  /// payload.
  public var signature: Data = SwiftProtobuf.Internal.emptyData

  /// The identifier for the public key that verifies this signature.
  ///   * The `public_key_id` is required.
  ///   * The `public_key_id` MUST be an RFC3986 conformant URI.
  ///   * When possible, the `public_key_id` SHOULD be an immutable reference,
  ///     such as a cryptographic digest.
  ///
  /// Examples of valid `public_key_id`s:
  ///
  /// OpenPGP V4 public key fingerprint:
  ///   * "openpgp4fpr:74FAF3B861BDA0870C7B6DEF607E48D2A663AEEA"
  /// See https://www.iana.org/assignments/uri-schemes/prov/openpgp4fpr for more
  /// details on this scheme.
  ///
  /// RFC6920 digest-named SubjectPublicKeyInfo (digest of the DER
  /// serialization):
  ///   * "ni:///sha-256;cD9o9Cq6LG3jD0iKXqEi_vdjJGecm_iXkbqVoScViaU"
  ///   * "nih:///sha-256;703f68f42aba2c6de30f488a5ea122fef76324679c9bf89791ba95a1271589a5"
  public var publicKeyID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "grafeas.v1"

extension Grafeas_V1_NoteKind: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NOTE_KIND_UNSPECIFIED"),
    1: .same(proto: "VULNERABILITY"),
    2: .same(proto: "BUILD"),
    3: .same(proto: "IMAGE"),
    4: .same(proto: "PACKAGE"),
    5: .same(proto: "DEPLOYMENT"),
    6: .same(proto: "DISCOVERY"),
    7: .same(proto: "ATTESTATION"),
    8: .same(proto: "UPGRADE"),
  ]
}

extension Grafeas_V1_RelatedUrl: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RelatedUrl"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "label"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.url)
      case 2: try decoder.decodeSingularStringField(value: &self.label)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1_RelatedUrl, rhs: Grafeas_V1_RelatedUrl) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.label != rhs.label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grafeas_V1_Signature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Signature"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signature"),
    2: .standard(proto: "public_key_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.signature)
      case 2: try decoder.decodeSingularStringField(value: &self.publicKeyID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 1)
    }
    if !self.publicKeyID.isEmpty {
      try visitor.visitSingularStringField(value: self.publicKeyID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1_Signature, rhs: Grafeas_V1_Signature) -> Bool {
    if lhs.signature != rhs.signature {return false}
    if lhs.publicKeyID != rhs.publicKeyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
